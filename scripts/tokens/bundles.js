/**
 * Build CSS Bundles with Optimized Structure
 *
 * Creates a clean, consumption-ready CSS structure:
 *
 * dist/css/
 * ‚îú‚îÄ‚îÄ shared/
 * ‚îÇ   ‚îî‚îÄ‚îÄ primitives.css          ‚Üê All primitives (space, size, color, font)
 * ‚îÇ
 * ‚îú‚îÄ‚îÄ bild/
 * ‚îÇ   ‚îú‚îÄ‚îÄ theme.css               ‚Üê Light/Dark colors + effects
 * ‚îÇ   ‚îú‚îÄ‚îÄ tokens.css              ‚Üê Breakpoints + Typography + Density
 * ‚îÇ   ‚îî‚îÄ‚îÄ components/
 * ‚îÇ       ‚îî‚îÄ‚îÄ button.css          ‚Üê All button tokens combined
 * ‚îÇ
 * ‚îú‚îÄ‚îÄ sportbild/                  ‚Üê Same structure
 * ‚îú‚îÄ‚îÄ advertorial/                ‚Üê Same structure
 * ‚îÇ
 * ‚îî‚îÄ‚îÄ bundles/
 *     ‚îú‚îÄ‚îÄ bild.css                ‚Üê Full bundle (primitives + theme + tokens + components)
 *     ‚îú‚îÄ‚îÄ sportbild.css
 *     ‚îî‚îÄ‚îÄ advertorial.css
 *
 * Optimization Features:
 * - Single primitives.css for all brands
 * - Theme switching via data-theme="light/dark"
 * - Responsive breakpoints with @media queries
 * - Per-component bundles with all tokens combined
 * - Full brand bundles for quick start
 */

const fs = require('fs');
const path = require('path');
const { glob } = require('glob');

const DIST_DIR = path.join(__dirname, '../..', 'dist');
const CSS_DIR = path.join(DIST_DIR, 'css');
const BRANDS = ['bild', 'sportbild', 'advertorial'];
const PACKAGE_VERSION = require('../../package.json').version;

// ============================================================================
// HEADER GENERATORS
// ============================================================================

function generateHeader(brand, bundleType, customDescription = null) {
  const brandName = brand ? brand.charAt(0).toUpperCase() + brand.slice(1) : 'Shared';

  const typeDescriptions = {
    'primitives': 'Primitives (Base values: space, size, colors, fonts)',
    'theme': 'Theme (Color tokens + Effects for light/dark mode)',
    'tokens': 'Tokens (Responsive breakpoints + Typography + Density)',
    'component': 'Component Bundle (Component-specific tokens)',
    'full': 'Full Bundle (Primitives + Theme + Tokens + Components)',
  };

  const description = customDescription || typeDescriptions[bundleType] || 'CSS Bundle';

  return `/**
 * Do not edit directly, this file was auto-generated.
 *
 * ${brandName.toUpperCase()} Design System Tokens v${PACKAGE_VERSION}
 * Generated by Style Dictionary v4.0.0
 *
 * ${brand ? `Brand: ${brandName} | ` : ''}Bundle: ${description}
 *
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 * Proprietary and confidential. All rights reserved.
 *
 * Documentation: https://github.com/UXWizard25/vv-token-test-v3#readme
 */

`;
}

// ============================================================================
// FILE UTILITIES
// ============================================================================

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function readAndStripHeader(filePath) {
  if (!fs.existsSync(filePath)) return '';
  let content = fs.readFileSync(filePath, 'utf8');
  // Remove file header comments
  content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
  return content.trim();
}

function getFileSize(content) {
  return (content.length / 1024).toFixed(2);
}

function removeDir(dir) {
  if (fs.existsSync(dir)) {
    fs.rmSync(dir, { recursive: true, force: true });
    return true;
  }
  return false;
}

// ============================================================================
// CLEANUP LEGACY STRUCTURE
// ============================================================================

function cleanupLegacyStructure() {
  console.log('\nüßπ Cleaning up legacy/intermediate files...');

  const legacyDirs = [
    // Old bundle subfolders (legacy structure)
    path.join(CSS_DIR, 'bundles', 'components'),
    path.join(CSS_DIR, 'bundles', 'layered'),
    path.join(CSS_DIR, 'bundles', 'quick-start'),
    path.join(CSS_DIR, 'bundles', 'semantic'),
    // Intermediate build output (used as source, not needed in final output)
    path.join(CSS_DIR, 'brands'),
  ];

  const removedDirs = [];
  for (const dir of legacyDirs) {
    if (removeDir(dir)) {
      removedDirs.push(path.basename(dir));
    }
  }

  if (removedDirs.length > 0) {
    console.log(`   ‚úÖ Removed: ${removedDirs.join(', ')}`);
  } else {
    console.log('   ‚úÖ No cleanup needed');
  }
}

// ============================================================================
// BUILD SHARED PRIMITIVES
// ============================================================================

async function buildSharedPrimitives() {
  console.log('\nüì¶ Building Shared Primitives:');

  const sharedDir = path.join(CSS_DIR, 'shared');
  ensureDir(sharedDir);

  // Source from build output
  const sourceSharedDir = path.join(CSS_DIR, 'shared');

  // Check for primitive files in the old structure (brands/bild/... etc) or shared
  let primitiveFiles = [];

  // Try to find primitives from the original build
  const possiblePaths = [
    path.join(DIST_DIR, 'css', 'shared', '*.css'),
  ];

  for (const pattern of possiblePaths) {
    const files = await glob(pattern);
    if (files.length > 0) {
      primitiveFiles = files;
      break;
    }
  }

  if (primitiveFiles.length === 0) {
    console.log('  ‚ö†Ô∏è  No primitive files found');
    return '';
  }

  let content = generateHeader(null, 'primitives');

  // Combine all primitive files
  for (const file of primitiveFiles.sort()) {
    const fileContent = readAndStripHeader(file);
    if (fileContent) {
      const fileName = path.basename(file, '.css');
      content += `/* === ${fileName.toUpperCase()} === */\n\n`;
      content += fileContent + '\n\n';
    }
  }

  const outputPath = path.join(sharedDir, 'primitives.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  console.log(`  ‚úÖ primitives.css (${primitiveFiles.length} sources, ${getFileSize(content)} KB)`);

  return content;
}

// ============================================================================
// BUILD BRAND THEME (Light/Dark + Effects)
// ============================================================================

async function buildBrandTheme(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  ensureDir(brandOutputDir);

  // Source directories
  const colorDir = path.join(brandSourceDir, 'semantic', 'color');
  const effectsDir = path.join(brandSourceDir, 'semantic', 'effects');

  let content = generateHeader(brand, 'theme');

  // Process color files (light first, then dark)
  if (fs.existsSync(colorDir)) {
    const colorFiles = await glob(`${colorDir}/*.css`);
    const lightFiles = colorFiles.filter(f => f.includes('light')).sort();
    const darkFiles = colorFiles.filter(f => f.includes('dark')).sort();

    if (lightFiles.length > 0) {
      content += '/* === LIGHT MODE === */\n\n';
      for (const file of lightFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += fileContent + '\n\n';
        }
      }
    }

    if (darkFiles.length > 0) {
      content += '/* === DARK MODE === */\n\n';
      for (const file of darkFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += fileContent + '\n\n';
        }
      }
    }
  }

  // Process effects (light first, then dark)
  if (fs.existsSync(effectsDir)) {
    const effectFiles = await glob(`${effectsDir}/*.css`);
    const lightEffects = effectFiles.filter(f => f.includes('light')).sort();
    const darkEffects = effectFiles.filter(f => f.includes('dark')).sort();

    if (lightEffects.length > 0 || darkEffects.length > 0) {
      content += '/* === EFFECTS === */\n\n';

      for (const file of lightEffects) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += `/* Effects - Light */\n${fileContent}\n\n`;
        }
      }

      for (const file of darkEffects) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += `/* Effects - Dark */\n${fileContent}\n\n`;
        }
      }
    }
  }

  const outputPath = path.join(brandOutputDir, 'theme.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// BUILD BRAND TOKENS (Breakpoints + Typography + Density)
// ============================================================================

async function buildBrandTokens(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  ensureDir(brandOutputDir);

  let content = generateHeader(brand, 'tokens');

  // 1. Density tokens (from component density files)
  const componentsDir = path.join(brandSourceDir, 'components');
  if (fs.existsSync(componentsDir)) {
    const densityFiles = await glob(`${componentsDir}/**/*-density-*.css`);

    if (densityFiles.length > 0) {
      // Group by density mode
      const densityByMode = { compact: [], default: [], spacious: [] };

      for (const file of densityFiles) {
        const modeMatch = path.basename(file).match(/density-(compact|default|spacious)/);
        if (modeMatch && densityByMode[modeMatch[1]]) {
          densityByMode[modeMatch[1]].push(file);
        }
      }

      content += '/* === DENSITY TOKENS === */\n\n';

      for (const mode of ['compact', 'default', 'spacious']) {
        if (densityByMode[mode].length > 0) {
          content += `/* Density: ${mode} */\n`;
          for (const file of densityByMode[mode].sort()) {
            const fileContent = readAndStripHeader(file);
            if (fileContent) {
              content += fileContent + '\n\n';
            }
          }
        }
      }
    }
  }

  // 2. Responsive breakpoint tokens
  const breakpointResponsive = path.join(brandSourceDir, 'semantic', 'breakpoints', 'breakpoint-responsive.css');
  if (fs.existsSync(breakpointResponsive)) {
    content += '/* === RESPONSIVE BREAKPOINT TOKENS === */\n\n';
    const fileContent = readAndStripHeader(breakpointResponsive);
    if (fileContent) {
      content += fileContent + '\n\n';
    }
  }

  // 3. Responsive typography
  const typographyResponsive = path.join(brandSourceDir, 'semantic', 'typography', 'typography-responsive.css');
  if (fs.existsSync(typographyResponsive)) {
    content += '/* === RESPONSIVE TYPOGRAPHY === */\n\n';
    const fileContent = readAndStripHeader(typographyResponsive);
    if (fileContent) {
      content += fileContent + '\n\n';
    }
  }

  const outputPath = path.join(brandOutputDir, 'tokens.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// BUILD BRAND COMPONENTS
// ============================================================================

async function buildBrandComponents(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  const componentsOutputDir = path.join(brandOutputDir, 'components');
  ensureDir(componentsOutputDir);

  const componentsSourceDir = path.join(brandSourceDir, 'components');
  if (!fs.existsSync(componentsSourceDir)) {
    return { count: 0, content: '' };
  }

  const componentDirs = fs.readdirSync(componentsSourceDir).filter(name => {
    const componentPath = path.join(componentsSourceDir, name);
    return fs.statSync(componentPath).isDirectory();
  });

  let allComponentsContent = '';
  let componentCount = 0;

  for (const componentName of componentDirs.sort()) {
    const componentDir = path.join(componentsSourceDir, componentName);
    const files = await glob(`${componentDir}/*.css`);

    if (files.length === 0) continue;

    let componentContent = generateHeader(brand, 'component', `${componentName} Component Tokens`);

    // Group files by type for better organization
    const colorLightFiles = files.filter(f => f.includes('color-light')).sort();
    const colorDarkFiles = files.filter(f => f.includes('color-dark')).sort();
    const densityFiles = files.filter(f => f.includes('density')).sort();
    const typographyFiles = files.filter(f => f.includes('typography')).sort();
    const breakpointFiles = files.filter(f => f.includes('breakpoint')).sort();
    const otherFiles = files.filter(f =>
      !f.includes('color-') &&
      !f.includes('density') &&
      !f.includes('typography') &&
      !f.includes('breakpoint')
    ).sort();

    // Color tokens (Light)
    if (colorLightFiles.length > 0) {
      componentContent += '/* === COLOR TOKENS (LIGHT MODE) === */\n\n';
      for (const file of colorLightFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Color tokens (Dark)
    if (colorDarkFiles.length > 0) {
      componentContent += '/* === COLOR TOKENS (DARK MODE) === */\n\n';
      for (const file of colorDarkFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Density tokens
    if (densityFiles.length > 0) {
      componentContent += '/* === DENSITY TOKENS === */\n\n';
      for (const file of densityFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Typography tokens
    if (typographyFiles.length > 0) {
      componentContent += '/* === TYPOGRAPHY TOKENS === */\n\n';
      for (const file of typographyFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Breakpoint tokens
    if (breakpointFiles.length > 0) {
      componentContent += '/* === BREAKPOINT TOKENS === */\n\n';
      for (const file of breakpointFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Other tokens
    if (otherFiles.length > 0) {
      componentContent += '/* === OTHER TOKENS === */\n\n';
      for (const file of otherFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Write component file
    const outputPath = path.join(componentsOutputDir, `${componentName.toLowerCase()}.css`);
    fs.writeFileSync(outputPath, componentContent.trim() + '\n');

    allComponentsContent += componentContent;
    componentCount++;
  }

  return { count: componentCount, content: allComponentsContent };
}

// ============================================================================
// BUILD FULL BRAND BUNDLE
// ============================================================================

async function buildFullBundle(brand, primitivesContent, themeContent, tokensContent, componentsContent) {
  const bundlesDir = path.join(CSS_DIR, 'bundles');
  ensureDir(bundlesDir);

  let content = generateHeader(brand, 'full');

  // Add primitives (without header)
  if (primitivesContent) {
    content += '/* ============================================================\n';
    content += '   PRIMITIVES\n';
    content += '   ============================================================ */\n\n';
    // Strip the header from primitives content
    const primitivesBody = primitivesContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += primitivesBody + '\n\n';
  }

  // Add theme (without header)
  if (themeContent) {
    content += '/* ============================================================\n';
    content += '   THEME (COLORS + EFFECTS)\n';
    content += '   ============================================================ */\n\n';
    const themeBody = themeContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += themeBody + '\n\n';
  }

  // Add tokens (without header)
  if (tokensContent) {
    content += '/* ============================================================\n';
    content += '   TOKENS (DENSITY + BREAKPOINTS + TYPOGRAPHY)\n';
    content += '   ============================================================ */\n\n';
    const tokensBody = tokensContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += tokensBody + '\n\n';
  }

  // Add components (without headers)
  if (componentsContent) {
    content += '/* ============================================================\n';
    content += '   COMPONENTS\n';
    content += '   ============================================================ */\n\n';
    // Strip all headers from components
    const componentsBody = componentsContent.replace(/\/\*\*[\s\S]*?\*\/\s*/g, '');
    content += componentsBody + '\n\n';
  }

  const outputPath = path.join(bundlesDir, `${brand}.css`);
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// MAIN BUILD FUNCTION
// ============================================================================

async function buildAllBundles() {
  console.log('\nüé® ============================================');
  console.log('   CSS Bundle Builder v3 (Optimized Structure)');
  console.log('   ============================================\n');

  const startTime = Date.now();

  // 1. Build shared primitives (once for all brands)
  const primitivesContent = await buildSharedPrimitives();

  // 2. Build per-brand bundles
  console.log('\nüè∑Ô∏è  Building Brand Bundles:');

  for (const brand of BRANDS) {
    console.log(`\n  üì¶ ${brand.toUpperCase()}:`);

    // Theme (Light/Dark + Effects)
    const themeContent = await buildBrandTheme(brand);
    console.log(`     ‚úÖ theme.css (${getFileSize(themeContent)} KB)`);

    // Tokens (Density + Breakpoints + Typography)
    const tokensContent = await buildBrandTokens(brand);
    console.log(`     ‚úÖ tokens.css (${getFileSize(tokensContent)} KB)`);

    // Components
    const { count: componentCount, content: componentsContent } = await buildBrandComponents(brand);
    console.log(`     ‚úÖ components/ (${componentCount} components)`);

    // Full bundle
    const fullContent = await buildFullBundle(brand, primitivesContent, themeContent, tokensContent, componentsContent);
    console.log(`     ‚úÖ bundles/${brand}.css (${getFileSize(fullContent)} KB)`);
  }

  // 3. Cleanup legacy/intermediate directories
  cleanupLegacyStructure();

  const duration = ((Date.now() - startTime) / 1000).toFixed(2);

  console.log('\n‚ú® Bundle Build Complete!');
  console.log(`\nüìä Duration: ${duration}s`);

  console.log('\nüìÅ Output Structure:');
  console.log('   dist/css/');
  console.log('   ‚îú‚îÄ‚îÄ shared/');
  console.log('   ‚îÇ   ‚îî‚îÄ‚îÄ primitives.css');
  for (const brand of BRANDS) {
    console.log(`   ‚îú‚îÄ‚îÄ ${brand}/`);
    console.log('   ‚îÇ   ‚îú‚îÄ‚îÄ theme.css');
    console.log('   ‚îÇ   ‚îú‚îÄ‚îÄ tokens.css');
    console.log('   ‚îÇ   ‚îî‚îÄ‚îÄ components/');
  }
  console.log('   ‚îî‚îÄ‚îÄ bundles/');
  for (const brand of BRANDS) {
    console.log(`       ‚îú‚îÄ‚îÄ ${brand}.css`);
  }
}

// Run
buildAllBundles().catch(console.error);

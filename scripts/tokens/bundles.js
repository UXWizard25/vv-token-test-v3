/**
 * Build CSS Bundles with Optimized Structure (Dual-Axis Architecture)
 *
 * Creates a clean, consumption-ready CSS structure:
 *
 * dist/css/
 * â”œâ”€â”€ shared/
 * â”‚   â””â”€â”€ primitives.css          â† All primitives (space, size, color, font)
 * â”‚
 * â”œâ”€â”€ bild/
 * â”‚   â”œâ”€â”€ theme.css               â† Light/Dark colors + effects (data-color-brand)
 * â”‚   â”œâ”€â”€ tokens.css              â† Breakpoints + Typography + Density (data-content-brand)
 * â”‚   â””â”€â”€ components/
 * â”‚       â””â”€â”€ button.css          â† All button tokens combined
 * â”‚
 * â”œâ”€â”€ sportbild/                  â† Same structure
 * â”œâ”€â”€ advertorial/                â† Content tokens only (no color tokens!)
 * â”‚
 * â””â”€â”€ bundles/
 *     â”œâ”€â”€ bild.css                â† Full bundle (primitives + theme + tokens + components)
 *     â”œâ”€â”€ sportbild.css
 *     â””â”€â”€ advertorial.css
 *
 * Dual-Axis Architecture:
 * - ColorBrand (data-color-brand): colors, effects - BILD, SportBILD only
 * - ContentBrand (data-content-brand): breakpoints, typography, density - all brands
 * - Theme switching via data-theme="light/dark" (combined with data-color-brand)
 * - Responsive breakpoints with @media queries
 *
 * Usage:
 * <html data-color-brand="bild" data-content-brand="bild" data-theme="light">
 * <article data-content-brand="advertorial"> <!-- Inherits colors from parent -->
 */

const fs = require('fs');
const path = require('path');
const { glob } = require('glob');

const DIST_DIR = path.join(__dirname, '../..', 'packages/tokens/dist');
const CSS_DIR = path.join(DIST_DIR, 'css');
const BRANDS = ['bild', 'sportbild', 'advertorial'];
const PACKAGE_VERSION = require('../../packages/tokens/package.json').version;

// ============================================================================
// HEADER GENERATORS
// ============================================================================

function generateHeader(brand, bundleType, customDescription = null) {
  const brandName = brand ? brand.charAt(0).toUpperCase() + brand.slice(1) : 'Shared';

  const typeDescriptions = {
    'primitives': 'Primitives (Base values: space, size, colors, fonts)',
    'theme': 'Theme (Color tokens + Effects for light/dark mode)',
    'tokens': 'Tokens (Responsive breakpoints + Typography + Density)',
    'component': 'Component Bundle (Component-specific tokens)',
    'full': 'Full Bundle (Primitives + Theme + Tokens + Components)',
  };

  const description = customDescription || typeDescriptions[bundleType] || 'CSS Bundle';

  return `/**
 * Do not edit directly, this file was auto-generated.
 *
 * ${brandName.toUpperCase()} Design System Tokens v${PACKAGE_VERSION}
 * Generated by Style Dictionary v4.0.0
 *
 * ${brand ? `Brand: ${brandName} | ` : ''}Bundle: ${description}
 *
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 * Proprietary and confidential. All rights reserved.
 *
 * Documentation: https://github.com/UXWizard25/vv-token-test-v3#readme
 */

`;
}

// ============================================================================
// FILE UTILITIES
// ============================================================================

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function readAndStripHeader(filePath) {
  if (!fs.existsSync(filePath)) return '';
  let content = fs.readFileSync(filePath, 'utf8');
  // Remove file header comments
  content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
  return content.trim();
}

function getFileSize(content) {
  return (content.length / 1024).toFixed(2);
}

function removeDir(dir) {
  if (fs.existsSync(dir)) {
    fs.rmSync(dir, { recursive: true, force: true });
    return true;
  }
  return false;
}

// ============================================================================
// CLEANUP LEGACY STRUCTURE
// ============================================================================

function cleanupLegacyStructure() {
  console.log('\nğŸ§¹ Cleaning up legacy/intermediate files...');

  const legacyDirs = [
    // Old bundle subfolders (legacy structure)
    path.join(CSS_DIR, 'bundles', 'components'),
    path.join(CSS_DIR, 'bundles', 'layered'),
    path.join(CSS_DIR, 'bundles', 'quick-start'),
    path.join(CSS_DIR, 'bundles', 'semantic'),
    // Intermediate build output (used as source, not needed in final output)
    path.join(CSS_DIR, 'brands'),
  ];

  const removedDirs = [];
  for (const dir of legacyDirs) {
    if (removeDir(dir)) {
      removedDirs.push(path.basename(dir));
    }
  }

  if (removedDirs.length > 0) {
    console.log(`   âœ… Removed: ${removedDirs.join(', ')}`);
  } else {
    console.log('   âœ… No cleanup needed');
  }
}

// ============================================================================
// BUILD SHARED PRIMITIVES
// ============================================================================

async function buildSharedPrimitives() {
  console.log('\nğŸ“¦ Building Shared Primitives:');

  const sharedDir = path.join(CSS_DIR, 'shared');
  ensureDir(sharedDir);

  // Source from build output
  const sourceSharedDir = path.join(CSS_DIR, 'shared');

  // Check for primitive files in the old structure (brands/bild/... etc) or shared
  let primitiveFiles = [];

  // Try to find primitives from the original build
  const possiblePaths = [
    path.join(DIST_DIR, 'css', 'shared', '*.css'),
  ];

  for (const pattern of possiblePaths) {
    const files = await glob(pattern);
    if (files.length > 0) {
      primitiveFiles = files;
      break;
    }
  }

  if (primitiveFiles.length === 0) {
    console.log('  âš ï¸  No primitive files found');
    return '';
  }

  let content = generateHeader(null, 'primitives');

  // Combine all primitive files
  for (const file of primitiveFiles.sort()) {
    const fileContent = readAndStripHeader(file);
    if (fileContent) {
      const fileName = path.basename(file, '.css');
      content += `/* === ${fileName.toUpperCase()} === */\n\n`;
      content += fileContent + '\n\n';
    }
  }

  const outputPath = path.join(sharedDir, 'primitives.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  console.log(`  âœ… primitives.css (${primitiveFiles.length} sources, ${getFileSize(content)} KB)`);

  return content;
}

// ============================================================================
// BUILD BRAND THEME (Light/Dark + Effects)
// ============================================================================

async function buildBrandTheme(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  ensureDir(brandOutputDir);

  // Source directories
  const colorDir = path.join(brandSourceDir, 'semantic', 'color');
  const effectsDir = path.join(brandSourceDir, 'semantic', 'effects');

  let content = generateHeader(brand, 'theme');

  // Process color files (light first, then dark)
  if (fs.existsSync(colorDir)) {
    const colorFiles = await glob(`${colorDir}/*.css`);
    const lightFiles = colorFiles.filter(f => f.includes('light')).sort();
    const darkFiles = colorFiles.filter(f => f.includes('dark')).sort();

    if (lightFiles.length > 0) {
      content += '/* === LIGHT MODE === */\n\n';
      for (const file of lightFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += fileContent + '\n\n';
        }
      }
    }

    if (darkFiles.length > 0) {
      content += '/* === DARK MODE === */\n\n';
      for (const file of darkFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += fileContent + '\n\n';
        }
      }
    }
  }

  // Process effects (light first, then dark)
  if (fs.existsSync(effectsDir)) {
    const effectFiles = await glob(`${effectsDir}/*.css`);
    const lightEffects = effectFiles.filter(f => f.includes('light')).sort();
    const darkEffects = effectFiles.filter(f => f.includes('dark')).sort();

    if (lightEffects.length > 0 || darkEffects.length > 0) {
      content += '/* === EFFECTS === */\n\n';

      for (const file of lightEffects) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += `/* Effects - Light */\n${fileContent}\n\n`;
        }
      }

      for (const file of darkEffects) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += `/* Effects - Dark */\n${fileContent}\n\n`;
        }
      }
    }
  }

  const outputPath = path.join(brandOutputDir, 'theme.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// BUILD BRAND TOKENS (Breakpoints + Typography + Density)
// ============================================================================

async function buildBrandTokens(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  ensureDir(brandOutputDir);

  let content = generateHeader(brand, 'tokens');

  // Note: Component density tokens are now ONLY in component bundles, not here.
  // This avoids duplication between tokens.css and component files.

  // 1. Responsive breakpoint tokens
  const breakpointResponsive = path.join(brandSourceDir, 'semantic', 'breakpoints', 'breakpoint-responsive.css');
  if (fs.existsSync(breakpointResponsive)) {
    content += '/* === RESPONSIVE BREAKPOINT TOKENS === */\n\n';
    const fileContent = readAndStripHeader(breakpointResponsive);
    if (fileContent) {
      content += fileContent + '\n\n';
    }
  }

  // 2. Responsive typography
  const typographyResponsive = path.join(brandSourceDir, 'semantic', 'typography', 'typography-responsive.css');
  if (fs.existsSync(typographyResponsive)) {
    content += '/* === RESPONSIVE TYPOGRAPHY === */\n\n';
    const fileContent = readAndStripHeader(typographyResponsive);
    if (fileContent) {
      content += fileContent + '\n\n';
    }
  }

  const outputPath = path.join(brandOutputDir, 'tokens.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// BUILD BRAND COMPONENTS
// ============================================================================

async function buildBrandComponents(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  const componentsOutputDir = path.join(brandOutputDir, 'components');
  ensureDir(componentsOutputDir);

  const componentsSourceDir = path.join(brandSourceDir, 'components');
  if (!fs.existsSync(componentsSourceDir)) {
    return { count: 0, content: '' };
  }

  const componentDirs = fs.readdirSync(componentsSourceDir).filter(name => {
    const componentPath = path.join(componentsSourceDir, name);
    return fs.statSync(componentPath).isDirectory();
  });

  let allComponentsContent = '';
  let componentCount = 0;

  for (const componentName of componentDirs.sort()) {
    const componentDir = path.join(componentsSourceDir, componentName);
    const files = await glob(`${componentDir}/*.css`);

    if (files.length === 0) continue;

    let componentContent = generateHeader(brand, 'component', `${componentName} Component Tokens`);

    // Group files by type for better organization
    const colorLightFiles = files.filter(f => f.includes('color-light')).sort();
    const colorDarkFiles = files.filter(f => f.includes('color-dark')).sort();
    const densityFiles = files.filter(f => f.includes('density')).sort();
    // For typography: prefer responsive file over individual breakpoint files
    const typographyResponsiveFile = files.find(f => f.includes('typography') && f.includes('-responsive'));
    const typographyFiles = typographyResponsiveFile
      ? [typographyResponsiveFile]
      : files.filter(f => f.includes('typography')).sort();
    const breakpointFiles = files.filter(f => f.includes('breakpoint')).sort();
    const otherFiles = files.filter(f =>
      !f.includes('color-') &&
      !f.includes('density') &&
      !f.includes('typography') &&
      !f.includes('breakpoint')
    ).sort();

    // Color tokens (Light)
    if (colorLightFiles.length > 0) {
      componentContent += '/* === COLOR TOKENS (LIGHT MODE) === */\n\n';
      for (const file of colorLightFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Color tokens (Dark)
    if (colorDarkFiles.length > 0) {
      componentContent += '/* === COLOR TOKENS (DARK MODE) === */\n\n';
      for (const file of colorDarkFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Density tokens
    if (densityFiles.length > 0) {
      componentContent += '/* === DENSITY TOKENS === */\n\n';
      for (const file of densityFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Typography tokens
    if (typographyFiles.length > 0) {
      componentContent += '/* === TYPOGRAPHY TOKENS === */\n\n';
      for (const file of typographyFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Breakpoint tokens
    if (breakpointFiles.length > 0) {
      componentContent += '/* === BREAKPOINT TOKENS === */\n\n';
      for (const file of breakpointFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Other tokens
    if (otherFiles.length > 0) {
      componentContent += '/* === OTHER TOKENS === */\n\n';
      for (const file of otherFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Write component file
    const outputPath = path.join(componentsOutputDir, `${componentName.toLowerCase()}.css`);
    fs.writeFileSync(outputPath, componentContent.trim() + '\n');

    allComponentsContent += componentContent;
    componentCount++;
  }

  return { count: componentCount, content: allComponentsContent };
}

// ============================================================================
// BUILD FULL BRAND BUNDLE
// ============================================================================

async function buildFullBundle(brand, primitivesContent, themeContent, tokensContent, componentsContent) {
  const bundlesDir = path.join(CSS_DIR, 'bundles');
  ensureDir(bundlesDir);

  let content = generateHeader(brand, 'full');

  // Add primitives (without header)
  if (primitivesContent) {
    content += '/* ============================================================\n';
    content += '   PRIMITIVES\n';
    content += '   ============================================================ */\n\n';
    // Strip the header from primitives content
    const primitivesBody = primitivesContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += primitivesBody + '\n\n';
  }

  // Add theme (without header)
  if (themeContent) {
    content += '/* ============================================================\n';
    content += '   THEME (COLORS + EFFECTS)\n';
    content += '   ============================================================ */\n\n';
    const themeBody = themeContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += themeBody + '\n\n';
  }

  // Add tokens (without header)
  if (tokensContent) {
    content += '/* ============================================================\n';
    content += '   TOKENS (DENSITY + BREAKPOINTS + TYPOGRAPHY)\n';
    content += '   ============================================================ */\n\n';
    const tokensBody = tokensContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += tokensBody + '\n\n';
  }

  // Add components (without headers)
  if (componentsContent) {
    content += '/* ============================================================\n';
    content += '   COMPONENTS\n';
    content += '   ============================================================ */\n\n';
    // Strip all headers from components
    const componentsBody = componentsContent.replace(/\/\*\*[\s\S]*?\*\/\s*/g, '');
    content += componentsBody + '\n\n';
  }

  const outputPath = path.join(bundlesDir, `${brand}.css`);
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// MAIN BUILD FUNCTION
// ============================================================================

async function buildAllBundles() {
  console.log('\nğŸ¨ ============================================');
  console.log('   CSS Bundle Builder v3 (Optimized Structure)');
  console.log('   ============================================\n');

  const startTime = Date.now();

  // 1. Build shared primitives (once for all brands)
  const primitivesContent = await buildSharedPrimitives();

  // 2. Build per-brand bundles
  console.log('\nğŸ·ï¸  Building Brand Bundles:');

  for (const brand of BRANDS) {
    console.log(`\n  ğŸ“¦ ${brand.toUpperCase()}:`);

    // Theme (Light/Dark + Effects)
    const themeContent = await buildBrandTheme(brand);
    console.log(`     âœ… theme.css (${getFileSize(themeContent)} KB)`);

    // Tokens (Density + Breakpoints + Typography)
    const tokensContent = await buildBrandTokens(brand);
    console.log(`     âœ… tokens.css (${getFileSize(tokensContent)} KB)`);

    // Components
    const { count: componentCount, content: componentsContent } = await buildBrandComponents(brand);
    console.log(`     âœ… components/ (${componentCount} components)`);

    // Full bundle
    const fullContent = await buildFullBundle(brand, primitivesContent, themeContent, tokensContent, componentsContent);
    console.log(`     âœ… bundles/${brand}.css (${getFileSize(fullContent)} KB)`);
  }

  // 3. Cleanup legacy/intermediate directories
  cleanupLegacyStructure();

  const duration = ((Date.now() - startTime) / 1000).toFixed(2);

  console.log('\nâœ¨ Bundle Build Complete!');
  console.log(`\nğŸ“Š Duration: ${duration}s`);

  console.log('\nğŸ“ Output Structure:');
  console.log('   dist/css/');
  console.log('   â”œâ”€â”€ shared/');
  console.log('   â”‚   â””â”€â”€ primitives.css');
  for (const brand of BRANDS) {
    console.log(`   â”œâ”€â”€ ${brand}/`);
    console.log('   â”‚   â”œâ”€â”€ theme.css');
    console.log('   â”‚   â”œâ”€â”€ tokens.css');
    console.log('   â”‚   â””â”€â”€ components/');
  }
  console.log('   â””â”€â”€ bundles/');
  for (const brand of BRANDS) {
    console.log(`       â”œâ”€â”€ ${brand}.css`);
  }
}

// Run
buildAllBundles().catch(console.error);

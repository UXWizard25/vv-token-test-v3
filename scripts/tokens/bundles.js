/**
 * Build CSS Bundles with Optimization
 *
 * Creates optimized CSS bundles from individual token files:
 *
 * NEW LAYERED STRUCTURE:
 * - primitives.css: Base values (space, size, color primitives, fonts)
 * - theme.css: Color tokens + Effects (light/dark mode via data-theme)
 * - tokens.css: Density + Breakpoints + Typography (responsive via @media)
 * - components/: Individual component bundles
 *
 * LEGACY BUNDLES (for backwards compatibility):
 * - Quick Start: All tokens (semantic + components)
 * - Semantic: Only semantic tokens
 * - Components: Individual component bundles
 *
 * Optimization Features:
 * - CSS Nesting for better organization
 * - Metadata headers with brand, version, usage info
 * - Section comments for navigation
 * - Removed unnecessary whitespace
 * - Grouped selectors for readability
 */

const fs = require('fs');
const path = require('path');
const { glob } = require('glob');

const DIST_DIR = path.join(__dirname, '../..', 'dist');
const BUNDLES_DIR = path.join(DIST_DIR, 'css', 'bundles');
const BRANDS = ['bild', 'sportbild', 'advertorial'];
const PACKAGE_VERSION = require('../../package.json').version;

// ============================================================================
// HEADER GENERATORS
// ============================================================================

/**
 * Generates bundle header with metadata
 */
function generateBundleHeader(brand, bundleType, customDescription = null) {
  const brandName = brand.charAt(0).toUpperCase() + brand.slice(1);

  const typeDescriptions = {
    'quick-start': 'Quick Start Bundle (All semantic + component tokens)',
    'semantic': 'Semantic Bundle (Foundation tokens: colors, spacing, typography, effects)',
    'component': 'Component Bundle (Component-specific tokens)',
    'primitives': 'Primitives Layer (Base values: space, size, colors, fonts)',
    'theme': 'Theme Layer (Color tokens + Effects for light/dark mode)',
    'tokens': 'Tokens Layer (Density + Responsive breakpoints + Typography)',
  };

  const description = customDescription || typeDescriptions[bundleType] || 'CSS Bundle';

  return `/**
 * Do not edit directly, this file was auto-generated.
 *
 * ${brandName.toUpperCase()} Design System Tokens v${PACKAGE_VERSION}
 * Generated by Style Dictionary v4.0.0
 *
 * Brand: ${brandName} | Bundle: ${description}
 *
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 * Proprietary and confidential. All rights reserved.
 *
 * Documentation: https://github.com/UXWizard25/vv-token-test-v3#readme
 */

`;
}

// ============================================================================
// CSS PARSING & OPTIMIZATION
// ============================================================================

/**
 * Parses CSS and groups rules by selector for nesting
 */
function parseCSS(css) {
  const rules = [];

  // Match CSS rules: selector { properties }
  const ruleRegex = /([^{]+)\{([^}]+)\}/g;
  let match;

  while ((match = ruleRegex.exec(css)) !== null) {
    const selector = match[1].trim();
    const properties = match[2].trim();

    if (selector && properties) {
      rules.push({ selector, properties });
    }
  }

  return rules;
}

/**
 * Groups rules by base selector for CSS nesting
 */
function groupRulesForNesting(rules) {
  const grouped = new Map();

  for (const rule of rules) {
    const { selector, properties } = rule;

    // Check if selector is a data-attribute selector with a class
    const match = selector.match(/^(\[data-[^\]]+\](?:\[data-[^\]]+\])*)\s+\.([a-zA-Z0-9_-]+)$/);

    if (match) {
      // This is a nested rule: [data-brand="x"][data-theme="y"] .classname
      const baseSelector = match[1];
      const className = match[2];

      if (!grouped.has(baseSelector)) {
        grouped.set(baseSelector, { properties: [], classes: [] });
      }

      grouped.get(baseSelector).classes.push({ className, properties });
    } else {
      // This is a regular rule (custom properties block or simple selector)
      if (!grouped.has(selector)) {
        grouped.set(selector, { properties: [], classes: [] });
      }

      // Split properties into individual lines
      const propLines = properties.split(';')
        .map(p => p.trim())
        .filter(p => p.length > 0);

      grouped.get(selector).properties.push(...propLines);
    }
  }

  return grouped;
}

/**
 * Generates optimized CSS with nesting
 */
function generateNestedCSS(grouped) {
  let output = '';

  for (const [selector, data] of grouped.entries()) {
    const { properties, classes } = data;

    // Skip empty blocks
    if (properties.length === 0 && classes.length === 0) {
      continue;
    }

    output += `${selector} {\n`;

    // Add custom properties first
    if (properties.length > 0) {
      for (const prop of properties) {
        output += `  ${prop};\n`;
      }
    }

    // Add nested classes with CSS nesting
    if (classes.length > 0) {
      if (properties.length > 0) {
        output += `\n`; // Separator between properties and classes
      }

      for (const cls of classes) {
        output += `  .${cls.className} {\n`;

        const propLines = cls.properties.split(';')
          .map(p => p.trim())
          .filter(p => p.length > 0);

        for (const prop of propLines) {
          output += `    ${prop};\n`;
        }

        output += `  }\n`;

        if (cls !== classes[classes.length - 1]) {
          output += `\n`; // Space between classes
        }
      }
    }

    output += `}\n\n`;
  }

  return output.trim();
}

/**
 * Organizes CSS with section comments
 */
function organizeWithSections(grouped) {
  const sections = {
    primitives: [],
    colorLight: [],
    colorDark: [],
    breakpoints: [],
    density: [],
    other: []
  };

  for (const [selector, data] of grouped.entries()) {
    if (selector === ':root') {
      sections.primitives.push([selector, data]);
    } else if (selector.includes('data-theme="light"')) {
      sections.colorLight.push([selector, data]);
    } else if (selector.includes('data-theme="dark"')) {
      sections.colorDark.push([selector, data]);
    } else if (selector.includes('data-breakpoint')) {
      sections.breakpoints.push([selector, data]);
    } else if (selector.includes('data-density')) {
      sections.density.push([selector, data]);
    } else {
      sections.other.push([selector, data]);
    }
  }

  let output = '';

  // Shared Primitives
  if (sections.primitives.length > 0) {
    output += `/* === SHARED PRIMITIVES === */\n\n`;
    output += generateNestedCSS(new Map(sections.primitives)) + '\n\n';
  }

  // Color Tokens - Light
  if (sections.colorLight.length > 0) {
    output += `/* === COLOR TOKENS (LIGHT MODE) === */\n\n`;
    output += generateNestedCSS(new Map(sections.colorLight)) + '\n\n';
  }

  // Color Tokens - Dark
  if (sections.colorDark.length > 0) {
    output += `/* === COLOR TOKENS (DARK MODE) === */\n\n`;
    output += generateNestedCSS(new Map(sections.colorDark)) + '\n\n';
  }

  // Breakpoint Tokens - Now handled by responsive files
  // Skip breakpoint tokens here as they're included via typography-responsive.css
  if (sections.breakpoints.length > 0) {
    // Breakpoint tokens are now in responsive files, skip parsing them here
  }

  // Density Tokens
  if (sections.density.length > 0) {
    output += `/* === DENSITY TOKENS === */\n\n`;
    output += generateNestedCSS(new Map(sections.density)) + '\n\n';
  }

  // Other (Components, Effects, etc.)
  if (sections.other.length > 0) {
    output += `/* === COMPONENT TOKENS & EFFECTS === */\n\n`;
    output += generateNestedCSS(new Map(sections.other)) + '\n\n';
  }

  return output.trim();
}

/**
 * Optimizes CSS bundle with nesting and structure
 */
function optimizeBundleCSS(css, brand, bundleType) {
  // Remove existing comments
  css = css.replace(/\/\*[\s\S]*?\*\//g, '');

  // Remove excessive whitespace
  css = css.replace(/\n{3,}/g, '\n\n');
  css = css.trim();

  // Parse CSS into rules
  const rules = parseCSS(css);

  // Group rules for nesting
  const grouped = groupRulesForNesting(rules);

  // Organize with section comments
  const organized = organizeWithSections(grouped);

  // Add header
  const header = generateBundleHeader(brand, bundleType);

  return header + organized;
}

/**
 * Combines and optimizes multiple CSS files
 */
async function combineAndOptimize(files, brand, bundleType) {
  let combinedStandard = '';
  let combinedResponsive = '';

  // Separate responsive files from standard files
  const responsiveFiles = files.filter(f => path.basename(f).includes('-responsive.css'));
  const standardFiles = files.filter(f => !path.basename(f).includes('-responsive.css'));

  // Process standard files (these get parsed and optimized)
  for (const file of standardFiles) {
    if (fs.existsSync(file)) {
      const content = fs.readFileSync(file, 'utf8');
      if (content.trim()) {
        combinedStandard += content + '\n\n';
      }
    }
  }

  // Process responsive files (keep as-is, just remove their headers)
  for (const file of responsiveFiles) {
    if (fs.existsSync(file)) {
      let content = fs.readFileSync(file, 'utf8');
      // Remove the file header but keep the CSS structure
      content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
      if (content.trim()) {
        combinedResponsive += content + '\n\n';
      }
    }
  }

  if (!combinedStandard.trim() && !combinedResponsive.trim()) {
    return '';
  }

  // Optimize standard files
  let result = '';
  if (combinedStandard.trim()) {
    result = optimizeBundleCSS(combinedStandard, brand, bundleType);
  } else {
    // If only responsive files, still add header
    result = generateBundleHeader(brand, bundleType);
  }

  // Append responsive files (already correctly structured with media queries)
  if (combinedResponsive.trim()) {
    // Add section comment before responsive content
    result += '\n/* === RESPONSIVE TOKENS & TYPOGRAPHY === */\n\n';
    result += combinedResponsive.trim();
  }

  return result;
}

/**
 * Ensures directory exists
 */
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

// ============================================================================
// NEW LAYERED BUNDLE BUILDERS
// ============================================================================

/**
 * Build Layered Bundles (NEW STRUCTURE)
 * Creates: primitives.css, theme.css, tokens.css per brand
 */
async function buildLayeredBundles() {
  console.log('\nüéØ Building Layered Bundles (NEW):');

  let totalBundles = 0;
  let successfulBundles = 0;

  for (const brand of BRANDS) {
    const brandCssDir = path.join(DIST_DIR, 'css', 'brands', brand);
    const layeredDir = path.join(BUNDLES_DIR, 'layered', brand);
    ensureDir(layeredDir);

    console.log(`\n  üè∑Ô∏è  ${brand}:`);

    // ========================================
    // 1. PRIMITIVES.CSS
    // ========================================
    try {
      const sharedDir = path.join(DIST_DIR, 'css', 'shared');
      const sharedFiles = fs.existsSync(sharedDir)
        ? await glob(`${sharedDir}/*.css`)
        : [];

      if (sharedFiles.length > 0) {
        let primitivesContent = generateBundleHeader(brand, 'primitives');

        for (const file of sharedFiles) {
          let content = fs.readFileSync(file, 'utf8');
          // Remove header
          content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
          if (content.trim()) {
            primitivesContent += content + '\n\n';
          }
        }

        const primitivesPath = path.join(layeredDir, 'primitives.css');
        fs.writeFileSync(primitivesPath, primitivesContent.trim() + '\n');

        const sizeKB = (primitivesContent.length / 1024).toFixed(2);
        console.log(`     ‚úÖ primitives.css (${sharedFiles.length} files, ${sizeKB} KB)`);
        successfulBundles++;
      }
      totalBundles++;
    } catch (error) {
      console.error(`     ‚ùå primitives.css: ${error.message}`);
      totalBundles++;
    }

    // ========================================
    // 2. THEME.CSS (Color + Effects)
    // ========================================
    try {
      const colorDir = path.join(brandCssDir, 'semantic', 'color');
      const effectsDir = path.join(brandCssDir, 'semantic', 'effects');

      const colorFiles = fs.existsSync(colorDir)
        ? await glob(`${colorDir}/*.css`)
        : [];
      const effectsFiles = fs.existsSync(effectsDir)
        ? await glob(`${effectsDir}/*.css`)
        : [];

      const themeFiles = [...colorFiles, ...effectsFiles];

      if (themeFiles.length > 0) {
        let themeContent = generateBundleHeader(brand, 'theme');

        // Process light mode first, then dark mode
        const lightFiles = themeFiles.filter(f => f.includes('light'));
        const darkFiles = themeFiles.filter(f => f.includes('dark'));

        // Light mode
        if (lightFiles.length > 0) {
          themeContent += '/* === LIGHT MODE === */\n\n';
          for (const file of lightFiles) {
            let content = fs.readFileSync(file, 'utf8');
            content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
            if (content.trim()) {
              themeContent += content + '\n\n';
            }
          }
        }

        // Dark mode
        if (darkFiles.length > 0) {
          themeContent += '/* === DARK MODE === */\n\n';
          for (const file of darkFiles) {
            let content = fs.readFileSync(file, 'utf8');
            content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
            if (content.trim()) {
              themeContent += content + '\n\n';
            }
          }
        }

        const themePath = path.join(layeredDir, 'theme.css');
        fs.writeFileSync(themePath, themeContent.trim() + '\n');

        const sizeKB = (themeContent.length / 1024).toFixed(2);
        console.log(`     ‚úÖ theme.css (${themeFiles.length} files, ${sizeKB} KB)`);
        successfulBundles++;
      }
      totalBundles++;
    } catch (error) {
      console.error(`     ‚ùå theme.css: ${error.message}`);
      totalBundles++;
    }

    // ========================================
    // 3. TOKENS.CSS (Density + Breakpoints + Typography)
    // ========================================
    try {
      const breakpointsDir = path.join(brandCssDir, 'semantic', 'breakpoints');
      const typographyDir = path.join(brandCssDir, 'semantic', 'typography');

      // Only get responsive files (with @media queries)
      const breakpointResponsive = path.join(breakpointsDir, 'breakpoint-responsive.css');
      const typographyResponsive = path.join(typographyDir, 'typography-responsive.css');

      let tokensContent = generateBundleHeader(brand, 'tokens');

      // Density tokens from components (if available at brand level)
      // We'll extract density from the first component that has it
      const componentsDir = path.join(brandCssDir, 'components');
      let densityAdded = false;

      if (fs.existsSync(componentsDir)) {
        const componentDirs = fs.readdirSync(componentsDir).filter(name => {
          const componentPath = path.join(componentsDir, name);
          return fs.statSync(componentPath).isDirectory();
        });

        // Collect all unique density rules
        const densityRules = new Map();

        for (const compName of componentDirs) {
          const densityFiles = await glob(`${componentsDir}/${compName}/*-density-*.css`);
          for (const file of densityFiles) {
            let content = fs.readFileSync(file, 'utf8');
            content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');

            // Extract density mode from filename
            const modeMatch = path.basename(file).match(/density-(compact|default|spacious)/);
            if (modeMatch) {
              const mode = modeMatch[1];
              if (!densityRules.has(mode)) {
                densityRules.set(mode, []);
              }
              densityRules.get(mode).push(content);
            }
          }
        }

        if (densityRules.size > 0) {
          tokensContent += '/* === DENSITY TOKENS === */\n\n';

          // Order: compact, default, spacious
          const orderedModes = ['compact', 'default', 'spacious'];
          for (const mode of orderedModes) {
            if (densityRules.has(mode)) {
              tokensContent += `/* Density: ${mode} */\n`;
              for (const content of densityRules.get(mode)) {
                if (content.trim()) {
                  tokensContent += content + '\n';
                }
              }
              tokensContent += '\n';
            }
          }
          densityAdded = true;
        }
      }

      // Add breakpoint responsive tokens
      if (fs.existsSync(breakpointResponsive)) {
        tokensContent += '/* === RESPONSIVE BREAKPOINT TOKENS === */\n\n';
        let content = fs.readFileSync(breakpointResponsive, 'utf8');
        content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
        if (content.trim()) {
          tokensContent += content + '\n\n';
        }
      }

      // Add typography responsive tokens
      if (fs.existsSync(typographyResponsive)) {
        tokensContent += '/* === RESPONSIVE TYPOGRAPHY === */\n\n';
        let content = fs.readFileSync(typographyResponsive, 'utf8');
        content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
        if (content.trim()) {
          tokensContent += content + '\n\n';
        }
      }

      const tokensPath = path.join(layeredDir, 'tokens.css');
      fs.writeFileSync(tokensPath, tokensContent.trim() + '\n');

      const sizeKB = (tokensContent.length / 1024).toFixed(2);
      console.log(`     ‚úÖ tokens.css (${sizeKB} KB)`);
      successfulBundles++;
      totalBundles++;
    } catch (error) {
      console.error(`     ‚ùå tokens.css: ${error.message}`);
      totalBundles++;
    }

    // ========================================
    // 4. COMPONENT BUNDLES (Simplified)
    // ========================================
    try {
      const componentsDir = path.join(brandCssDir, 'components');
      const layeredComponentsDir = path.join(layeredDir, 'components');
      ensureDir(layeredComponentsDir);

      if (fs.existsSync(componentsDir)) {
        const componentNames = fs.readdirSync(componentsDir).filter(name => {
          const componentPath = path.join(componentsDir, name);
          return fs.statSync(componentPath).isDirectory();
        });

        let componentCount = 0;
        for (const componentName of componentNames) {
          const componentDir = path.join(componentsDir, componentName);
          const files = await glob(`${componentDir}/*.css`);

          if (files.length === 0) continue;

          // Combine all component files
          const bundleContent = await combineAndOptimize(files, brand, 'component');

          // Write to simplified path: components/button.css (not Button/button.css)
          const bundlePath = path.join(layeredComponentsDir, `${componentName.toLowerCase()}.css`);
          fs.writeFileSync(bundlePath, bundleContent);
          componentCount++;
        }

        console.log(`     ‚úÖ components/ (${componentCount} components)`);
        successfulBundles++;
      }
      totalBundles++;
    } catch (error) {
      console.error(`     ‚ùå components/: ${error.message}`);
      totalBundles++;
    }
  }

  return { totalBundles, successfulBundles };
}

// ============================================================================
// LEGACY BUNDLE BUILDERS (Backwards Compatibility)
// ============================================================================

/**
 * Build Quick Start Bundles (semantic + all components)
 */
async function buildQuickStartBundles() {
  console.log('\nüì¶ Building Quick Start Bundles:');

  const quickStartDir = path.join(BUNDLES_DIR, 'quick-start');
  ensureDir(quickStartDir);

  let totalBundles = 0;
  let successfulBundles = 0;

  for (const brand of BRANDS) {
    const brandCssDir = path.join(DIST_DIR, 'css', 'brands', brand);

    if (!fs.existsSync(brandCssDir)) {
      console.log(`  ‚ö†Ô∏è  ${brand}: No CSS files found`);
      continue;
    }

    try {
      // Find shared primitives first
      const sharedDir = path.join(DIST_DIR, 'css', 'shared');
      const sharedFiles = fs.existsSync(sharedDir)
        ? await glob(`${sharedDir}/*.css`)
        : [];

      // Find all CSS files for this brand
      let brandFiles = await glob(`${brandCssDir}/**/*.css`);

      // Exclude files that shouldn't be in the consumption bundle
      brandFiles = brandFiles.filter(f => {
        const basename = path.basename(f);
        const relativePath = path.relative(brandCssDir, f);

        // Exclude typography-xs/sm/md/lg.css but keep typography-responsive.css
        // Exclude breakpoint-*.css but keep breakpoint-responsive.css
        // Exclude overrides/ folder (mapping layers, not consumption layers)
        return !(
          basename.match(/^typography-(xs|sm|md|lg)\.css$/) ||
          basename.match(/^breakpoint-(xs|sm|md|lg)/) ||
          relativePath.startsWith('overrides/')
        );
      });

      // Combine shared primitives + brand files
      const files = [...sharedFiles, ...brandFiles];

      if (files.length === 0) {
        console.log(`  ‚ö†Ô∏è  ${brand}: No CSS files to bundle`);
        continue;
      }

      // Combine and optimize files
      const bundleContent = await combineAndOptimize(files, brand, 'quick-start');

      // Write bundle
      const bundlePath = path.join(quickStartDir, `${brand}-all.css`);
      fs.writeFileSync(bundlePath, bundleContent);

      const sizeKB = (bundleContent.length / 1024).toFixed(2);
      console.log(`  ‚úÖ ${brand}-all.css (${files.length} files, ${sizeKB} KB)`);

      totalBundles++;
      successfulBundles++;
    } catch (error) {
      console.error(`  ‚ùå ${brand}: ${error.message}`);
      totalBundles++;
    }
  }

  return { totalBundles, successfulBundles };
}

/**
 * Build Semantic Bundles (only semantic tokens, no components)
 */
async function buildSemanticBundles() {
  console.log('\nüì¶ Building Semantic Bundles:');

  const semanticDir = path.join(BUNDLES_DIR, 'semantic');
  ensureDir(semanticDir);

  let totalBundles = 0;
  let successfulBundles = 0;

  for (const brand of BRANDS) {
    const brandSemanticDir = path.join(DIST_DIR, 'css', 'brands', brand, 'semantic');

    if (!fs.existsSync(brandSemanticDir)) {
      console.log(`  ‚ö†Ô∏è  ${brand}: No semantic files found`);
      continue;
    }

    try {
      // Find shared primitives first
      const sharedDir = path.join(DIST_DIR, 'css', 'shared');
      const sharedFiles = fs.existsSync(sharedDir)
        ? await glob(`${sharedDir}/*.css`)
        : [];

      // Find all semantic CSS files
      let semanticFiles = await glob(`${brandSemanticDir}/**/*.css`);

      // Exclude individual breakpoint files (we use responsive versions instead)
      semanticFiles = semanticFiles.filter(f => {
        const basename = path.basename(f);
        // Exclude typography-xs/sm/md/lg.css but keep typography-responsive.css
        // Exclude breakpoint-*.css but keep breakpoint-responsive.css
        return !(
          basename.match(/^typography-(xs|sm|md|lg)\.css$/) ||
          basename.match(/^breakpoint-(xs|sm|md|lg)/)
        );
      });

      // Combine shared primitives + semantic files
      const files = [...sharedFiles, ...semanticFiles];

      if (files.length === 0) {
        console.log(`  ‚ö†Ô∏è  ${brand}: No semantic CSS files to bundle`);
        continue;
      }

      // Combine and optimize files
      const bundleContent = await combineAndOptimize(files, brand, 'semantic');

      // Write bundle
      const bundlePath = path.join(semanticDir, `${brand}-semantic.css`);
      fs.writeFileSync(bundlePath, bundleContent);

      const sizeKB = (bundleContent.length / 1024).toFixed(2);
      console.log(`  ‚úÖ ${brand}-semantic.css (${files.length} files, ${sizeKB} KB)`);

      totalBundles++;
      successfulBundles++;
    } catch (error) {
      console.error(`  ‚ùå ${brand}: ${error.message}`);
      totalBundles++;
    }
  }

  return { totalBundles, successfulBundles };
}

/**
 * Build Component Bundles (individual components)
 */
async function buildComponentBundles() {
  console.log('\nüì¶ Building Component Bundles:');

  const componentsDir = path.join(BUNDLES_DIR, 'components');
  ensureDir(componentsDir);

  let totalBundles = 0;
  let successfulBundles = 0;

  for (const brand of BRANDS) {
    const brandComponentsDir = path.join(DIST_DIR, 'css', 'brands', brand, 'components');

    if (!fs.existsSync(brandComponentsDir)) {
      console.log(`  ‚ö†Ô∏è  ${brand}: No components found`);
      continue;
    }

    // Get all component directories
    const componentNames = fs.readdirSync(brandComponentsDir).filter(name => {
      const componentPath = path.join(brandComponentsDir, name);
      return fs.statSync(componentPath).isDirectory();
    });

    console.log(`  üè∑Ô∏è  ${brand}: ${componentNames.length} components`);

    for (const componentName of componentNames) {
      try {
        const componentDir = path.join(brandComponentsDir, componentName);

        // Find all CSS files for this component
        const files = await glob(`${componentDir}/*.css`);

        if (files.length === 0) continue;

        // Combine and optimize files
        const bundleContent = await combineAndOptimize(files, brand, 'component');

        // Write bundle
        const bundlePath = path.join(componentsDir, `${brand}-${componentName.toLowerCase()}.css`);
        fs.writeFileSync(bundlePath, bundleContent);

        totalBundles++;
        successfulBundles++;
      } catch (error) {
        console.error(`     ‚ùå ${componentName}: ${error.message}`);
        totalBundles++;
      }
    }

    console.log(`     ‚úÖ ${successfulBundles}/${totalBundles} component bundles created`);
  }

  return { totalBundles, successfulBundles };
}

// ============================================================================
// MAIN BUILD FUNCTION
// ============================================================================

/**
 * Main build function
 */
async function main() {
  console.log('\nüé® ============================================');
  console.log('   CSS Bundle Builder v2 (with Layered Output)');
  console.log('   ============================================\n');

  const startTime = Date.now();

  // Ensure bundles directory exists
  ensureDir(BUNDLES_DIR);

  const stats = {
    layered: await buildLayeredBundles(),      // NEW: primitives.css, theme.css, tokens.css
    quickStart: await buildQuickStartBundles(), // Legacy: all-in-one
    semantic: await buildSemanticBundles(),     // Legacy: semantic only
    components: await buildComponentBundles()   // Legacy: individual components
  };

  const endTime = Date.now();
  const duration = ((endTime - startTime) / 1000).toFixed(2);

  // Print summary
  console.log('\n‚ú® Bundle Build Complete!\n');
  console.log('üìä Statistics:');
  console.log(`   Layered (NEW): ${stats.layered.successfulBundles}/${stats.layered.totalBundles} bundles`);
  console.log(`   Quick Start: ${stats.quickStart.successfulBundles}/${stats.quickStart.totalBundles} bundles`);
  console.log(`   Semantic: ${stats.semantic.successfulBundles}/${stats.semantic.totalBundles} bundles`);
  console.log(`   Components: ${stats.components.successfulBundles}/${stats.components.totalBundles} bundles`);
  console.log(`   Duration: ${duration}s\n`);

  console.log('üìÅ NEW Layered Output:');
  for (const brand of BRANDS) {
    console.log(`   ${BUNDLES_DIR}/layered/${brand}/`);
    console.log(`     ‚îú‚îÄ‚îÄ primitives.css    (Base values)`);
    console.log(`     ‚îú‚îÄ‚îÄ theme.css         (Color + Effects)`);
    console.log(`     ‚îú‚îÄ‚îÄ tokens.css        (Density + Breakpoints + Typography)`);
    console.log(`     ‚îî‚îÄ‚îÄ components/       (Per-component bundles)`);
  }

  console.log(`\nüìÅ Legacy Output: ${BUNDLES_DIR}`);
  console.log(`‚ú® Features: CSS Nesting, @media Queries, Layered Architecture\n`);
}

// Run if called directly
if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå Bundle build failed:', error);
    process.exit(1);
  });
}

module.exports = { main };

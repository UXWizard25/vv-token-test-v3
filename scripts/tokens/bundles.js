/**
 * Build CSS Bundles with Optimized Structure (Dual-Axis Architecture)
 *
 * Creates a clean, consumption-ready CSS structure:
 *
 * dist/css/
 * â”œâ”€â”€ shared/
 * â”‚   â””â”€â”€ primitives.css          â† All primitives (space, size, color, font)
 * â”‚
 * â”œâ”€â”€ bild/
 * â”‚   â”œâ”€â”€ colors.css              â† Light/Dark colors + effects (data-color-brand)
 * â”‚   â”œâ”€â”€ sizing.css              â† Breakpoints + Density (data-content-brand)
 * â”‚   â””â”€â”€ components/
 * â”‚       â””â”€â”€ button.css          â† All button tokens combined
 * â”‚
 * â”œâ”€â”€ sportbild/                  â† Same structure
 * â”œâ”€â”€ advertorial/                â† Content tokens only (no color tokens!)
 * â”‚
 * â””â”€â”€ bundles/
 *     â”œâ”€â”€ bild.css                â† Full bundle (primitives + theme + tokens + components)
 *     â”œâ”€â”€ sportbild.css
 *     â””â”€â”€ advertorial.css
 *
 * Dual-Axis Architecture:
 * - ColorBrand (data-color-brand): colors, effects - BILD, SportBILD only
 * - ContentBrand (data-content-brand): breakpoints, typography, density - all brands
 * - Theme switching via data-theme="light/dark" (combined with data-color-brand)
 * - Responsive breakpoints with @media queries
 *
 * Usage:
 * <html data-color-brand="bild" data-content-brand="bild" data-theme="light">
 * <article data-content-brand="advertorial"> <!-- Inherits colors from parent -->
 */

const fs = require('fs');
const path = require('path');
const { glob } = require('glob');
const pipelineConfig = require('../../build-config/pipeline.config.js');

const DIST_DIR = path.join(__dirname, '../..', pipelineConfig.paths.tokensDist);
const CSS_DIR = path.join(DIST_DIR, 'css');
const BRANDS = pipelineConfig.allBrands;
const rootPackageJson = require('../../package.json');
const tokensPackageJson = require('../../packages/tokens/package.json');

// ============================================================================
// HEADER GENERATORS
// ============================================================================

/**
 * Get Style Dictionary version from dependencies
 */
function getStyleDictionaryVersion() {
  const sdVersion = rootPackageJson.dependencies?.['style-dictionary']
    || rootPackageJson.devDependencies?.['style-dictionary']
    || '4.x';
  return sdVersion.replace(/^[\^~]/, '');
}

/**
 * Get platform-specific documentation URL
 * @param {string} platform - Platform identifier: 'css' | 'scss' | 'js' | 'ios' | 'android'
 * @returns {string} Documentation URL
 */
function getDocumentationUrl(platform = 'css') {
  const repoUrl = tokensPackageJson.repository?.url?.replace(/^git\+/, '').replace(/\.git$/, '')
    || pipelineConfig.identity.repositoryUrl;
  const baseDocsUrl = `${repoUrl}/blob/main/packages/tokens`;

  const platformDocs = {
    css: `${baseDocsUrl}/docs/css.md`,
    scss: `${baseDocsUrl}/docs/css.md`,
    js: `${baseDocsUrl}/docs/js.md`,
    ios: `${baseDocsUrl}/docs/ios.md`,
    android: `${baseDocsUrl}/docs/android.md`,
    default: `${baseDocsUrl}/README.md`
  };

  return platformDocs[platform] || platformDocs.default;
}

/**
 * Generate CSS file header (CSS bundles only use block comments)
 * @param {string} brand - Brand name (bild, sportbild, advertorial) or null for shared
 * @param {string} bundleType - Bundle type: 'primitives' | 'theme' | 'tokens' | 'component' | 'full'
 * @param {string} customDescription - Custom description override
 * @returns {string} Formatted header string
 */
function generateHeader(brand, bundleType, customDescription = null) {
  const brandName = brand ? brand.charAt(0).toUpperCase() + brand.slice(1) : 'Shared';
  const version = tokensPackageJson.version;
  const sdVersion = getStyleDictionaryVersion();
  const docsUrl = getDocumentationUrl('css');
  const currentYear = new Date().getFullYear();

  const typeDescriptions = {
    'primitives': 'Primitives (Base values: space, size, colors, fonts)',
    'colors': 'Colors (Color tokens + Effects variables for light/dark mode)',
    'sizing': 'Sizing (Responsive breakpoints + Density)',
    'utilities': 'Utilities (Typography + Effect classes)',
    'component': 'Component Bundle (Component-specific tokens)',
    'component-utilities': 'Component Utilities (Typography + Effect classes)',
    'full': 'Full Bundle (Primitives + Colors + Sizing + Components)',
    'full-utilities': 'Full Utilities Bundle (All Typography + Effect classes)',
  };

  const description = customDescription || typeDescriptions[bundleType] || 'CSS Bundle';

  // Build header lines (consistent with other implementations)
  const lines = [
    'Do not edit directly, this file was auto-generated.',
    '',
    `${pipelineConfig.identity.name} Tokens v${version}`,
    `Generated by Style Dictionary v${sdVersion}`,
    '',
    `${brand ? `Brand: ${brandName} | ` : ''}Bundle: ${description}`,
    '',
    `Copyright (c) ${currentYear} ${pipelineConfig.identity.copyright}`,
    'Proprietary and confidential. All rights reserved.',
    '',
    `Documentation: ${docsUrl}`
  ];

  // Format as block comment with trimEnd to avoid trailing whitespace
  return '/**\n' + lines.map(line => ` * ${line}`.trimEnd()).join('\n') + '\n */\n\n';
}

// ============================================================================
// FILE UTILITIES
// ============================================================================

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function readAndStripHeader(filePath) {
  if (!fs.existsSync(filePath)) return '';
  let content = fs.readFileSync(filePath, 'utf8');
  // Remove file header comments
  content = content.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
  return content.trim();
}

function getFileSize(content) {
  return (content.length / 1024).toFixed(2);
}

function removeDir(dir) {
  if (fs.existsSync(dir)) {
    fs.rmSync(dir, { recursive: true, force: true });
    return true;
  }
  return false;
}

// ============================================================================
// CLEANUP LEGACY STRUCTURE
// ============================================================================

function cleanupLegacyStructure() {
  console.log('\nğŸ§¹ Cleaning up legacy/intermediate files...');

  const legacyDirs = [
    // Old bundle subfolders (legacy structure)
    path.join(CSS_DIR, 'bundles', 'components'),
    path.join(CSS_DIR, 'bundles', 'layered'),
    path.join(CSS_DIR, 'bundles', 'quick-start'),
    path.join(CSS_DIR, 'bundles', 'semantic'),
    // Intermediate build output (used as source, not needed in final output)
    path.join(CSS_DIR, 'brands'),
  ];

  const removedDirs = [];
  for (const dir of legacyDirs) {
    if (removeDir(dir)) {
      removedDirs.push(path.basename(dir));
    }
  }

  if (removedDirs.length > 0) {
    console.log(`   âœ… Removed: ${removedDirs.join(', ')}`);
  } else {
    console.log('   âœ… No cleanup needed');
  }
}

// ============================================================================
// BUILD SHARED PRIMITIVES
// ============================================================================

async function buildSharedPrimitives() {
  console.log('\nğŸ“¦ Building Shared Primitives:');

  const sharedDir = path.join(CSS_DIR, 'shared');
  ensureDir(sharedDir);

  // Source from build output
  const sourceSharedDir = path.join(CSS_DIR, 'shared');

  // Check for primitive files in the old structure (brands/bild/... etc) or shared
  let primitiveFiles = [];

  // Try to find primitives from the original build
  const possiblePaths = [
    path.join(DIST_DIR, 'css', 'shared', '*.css'),
  ];

  for (const pattern of possiblePaths) {
    const files = await glob(pattern);
    if (files.length > 0) {
      primitiveFiles = files;
      break;
    }
  }

  if (primitiveFiles.length === 0) {
    console.log('  âš ï¸  No primitive files found');
    return '';
  }

  let content = generateHeader(null, 'primitives');

  // Combine all primitive files
  for (const file of primitiveFiles.sort()) {
    const fileContent = readAndStripHeader(file);
    if (fileContent) {
      const fileName = path.basename(file, '.css');
      content += `/* === ${fileName.toUpperCase()} === */\n\n`;
      content += fileContent + '\n\n';
    }
  }

  const outputPath = path.join(sharedDir, 'primitives.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  console.log(`  âœ… primitives.css (${primitiveFiles.length} sources, ${getFileSize(content)} KB)`);

  return content;
}

// ============================================================================
// BUILD BRAND COLORS (Light/Dark + Effects)
// ============================================================================

async function buildBrandColors(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  ensureDir(brandOutputDir);

  // Source directories
  const colorDir = path.join(brandSourceDir, 'semantic', 'color');
  const effectsDir = path.join(brandSourceDir, 'semantic', 'effects');

  let content = generateHeader(brand, 'colors');

  // Process color files (light first, then dark)
  if (fs.existsSync(colorDir)) {
    const colorFiles = await glob(`${colorDir}/*.css`);
    const lightFiles = colorFiles.filter(f => f.includes('light')).sort();
    const darkFiles = colorFiles.filter(f => f.includes('dark')).sort();

    if (lightFiles.length > 0) {
      content += '/* === LIGHT MODE === */\n\n';
      for (const file of lightFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += fileContent + '\n\n';
        }
      }
    }

    if (darkFiles.length > 0) {
      content += '/* === DARK MODE === */\n\n';
      for (const file of darkFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += fileContent + '\n\n';
        }
      }
    }
  }

  // Process effects
  // First check for mode-agnostic consolidated file (effects.css)
  // Fall back to separate light/dark files if not found
  if (fs.existsSync(effectsDir)) {
    const consolidatedEffects = path.join(effectsDir, 'effects.css');

    if (fs.existsSync(consolidatedEffects)) {
      // Use mode-agnostic consolidated file
      const fileContent = readAndStripHeader(consolidatedEffects);
      if (fileContent) {
        content += '/* === EFFECTS (Mode-agnostic) === */\n\n';
        content += `${fileContent}\n\n`;
      }
    } else {
      // Fall back to separate light/dark files
      const effectFiles = await glob(`${effectsDir}/*.css`);
      const lightEffects = effectFiles.filter(f => f.includes('light')).sort();
      const darkEffects = effectFiles.filter(f => f.includes('dark')).sort();

      if (lightEffects.length > 0 || darkEffects.length > 0) {
        content += '/* === EFFECTS === */\n\n';

        for (const file of lightEffects) {
          const fileContent = readAndStripHeader(file);
          if (fileContent) {
            content += `/* Effects - Light */\n${fileContent}\n\n`;
          }
        }

        for (const file of darkEffects) {
          const fileContent = readAndStripHeader(file);
          if (fileContent) {
            content += `/* Effects - Dark */\n${fileContent}\n\n`;
          }
        }
      }
    }
  }

  const outputPath = path.join(brandOutputDir, 'colors.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// BUILD BRAND SIZING (Breakpoints + Density)
// Note: Typography classes moved to utilities.css
// ============================================================================

async function buildBrandSizing(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  ensureDir(brandOutputDir);

  let content = generateHeader(brand, 'sizing');

  // Note: Component density tokens are now ONLY in component bundles, not here.
  // This avoids duplication between sizing.css and component files.
  // Note: Typography classes moved to utilities.css

  // 1. Responsive breakpoint tokens
  const breakpointResponsive = path.join(brandSourceDir, 'semantic', 'breakpoints', 'breakpoint-responsive.css');
  if (fs.existsSync(breakpointResponsive)) {
    content += '/* === RESPONSIVE BREAKPOINT TOKENS === */\n\n';
    const fileContent = readAndStripHeader(breakpointResponsive);
    if (fileContent) {
      content += fileContent + '\n\n';
    }
  }

  // 2. Semantic Density tokens (Global/StackSpace - referenced by breakpoint tokens)
  const densityDir = path.join(brandSourceDir, 'density');
  if (fs.existsSync(densityDir)) {
    const densityFiles = await glob(`${densityDir}/*.css`);
    if (densityFiles.length > 0) {
      content += '/* === SEMANTIC DENSITY TOKENS === */\n\n';
      for (const file of densityFiles.sort()) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) {
          content += fileContent + '\n\n';
        }
      }
    }
  }

  const outputPath = path.join(brandOutputDir, 'sizing.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// BUILD BRAND COMPONENTS
// Note: Typography and Effect classes moved to component-utilities.css
// ============================================================================

async function buildBrandComponents(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  const componentsOutputDir = path.join(brandOutputDir, 'components');
  ensureDir(componentsOutputDir);

  const componentsSourceDir = path.join(brandSourceDir, 'components');
  if (!fs.existsSync(componentsSourceDir)) {
    return { count: 0, content: '', utilitiesContent: '' };
  }

  const componentDirs = fs.readdirSync(componentsSourceDir).filter(name => {
    const componentPath = path.join(componentsSourceDir, name);
    return fs.statSync(componentPath).isDirectory();
  });

  let allComponentsContent = '';
  let allUtilitiesContent = '';
  let componentCount = 0;
  let utilitiesCount = 0;

  for (const componentName of componentDirs.sort()) {
    const componentDir = path.join(componentsSourceDir, componentName);
    const files = await glob(`${componentDir}/*.css`);

    if (files.length === 0) continue;

    // ========================================================================
    // PART 1: Component Tokens (variables only, no classes)
    // ========================================================================
    let componentContent = generateHeader(brand, 'component', `${componentName} Component Tokens`);

    // Group files by type for better organization
    const colorLightFiles = files.filter(f => f.includes('color-light')).sort();
    const colorDarkFiles = files.filter(f => f.includes('color-dark')).sort();
    const densityFiles = files.filter(f => f.includes('density')).sort();
    const breakpointFiles = files.filter(f => f.includes('breakpoint')).sort();

    // Effects: Only variable files (not -classes.css)
    // Look for consolidated effects.css first, then light/dark variable files
    const effectsConsolidated = files.find(f => f.endsWith('-effects.css') && !f.includes('-classes'));
    const effectsLightVar = files.find(f => f.includes('-effects-light.css') && !f.includes('-classes'));
    const effectsDarkVar = files.find(f => f.includes('-effects-dark.css') && !f.includes('-classes'));
    const effectsVariableFiles = effectsConsolidated
      ? [effectsConsolidated]
      : [effectsLightVar, effectsDarkVar].filter(Boolean);

    // Other files: exclude typography, effects (all), and -classes.css files
    const otherFiles = files.filter(f =>
      !f.includes('color-') &&
      !f.includes('density') &&
      !f.includes('typography') &&
      !f.includes('breakpoint') &&
      !f.includes('effects') &&
      !f.endsWith('-classes.css')
    ).sort();

    // Color tokens (Light)
    if (colorLightFiles.length > 0) {
      componentContent += '/* === COLOR TOKENS (LIGHT MODE) === */\n\n';
      for (const file of colorLightFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Color tokens (Dark)
    if (colorDarkFiles.length > 0) {
      componentContent += '/* === COLOR TOKENS (DARK MODE) === */\n\n';
      for (const file of colorDarkFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Density tokens
    if (densityFiles.length > 0) {
      componentContent += '/* === DENSITY TOKENS === */\n\n';
      for (const file of densityFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Effects variables (NOT classes)
    if (effectsVariableFiles.length > 0) {
      componentContent += '/* === EFFECTS VARIABLES === */\n\n';
      for (const file of effectsVariableFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Breakpoint tokens
    if (breakpointFiles.length > 0) {
      componentContent += '/* === BREAKPOINT TOKENS === */\n\n';
      for (const file of breakpointFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Other tokens
    if (otherFiles.length > 0) {
      componentContent += '/* === OTHER TOKENS === */\n\n';
      for (const file of otherFiles) {
        const fileContent = readAndStripHeader(file);
        if (fileContent) componentContent += fileContent + '\n\n';
      }
    }

    // Write component file
    const outputPath = path.join(componentsOutputDir, `${componentName.toLowerCase()}.css`);
    fs.writeFileSync(outputPath, componentContent.trim() + '\n');

    allComponentsContent += componentContent;
    componentCount++;

    // ========================================================================
    // PART 2: Component Utilities (typography + effect classes only)
    // ========================================================================

    // Typography: prefer responsive file over individual breakpoint files
    const typographyResponsiveFile = files.find(f => f.includes('typography') && f.includes('-responsive'));
    const typographyFiles = typographyResponsiveFile
      ? [typographyResponsiveFile]
      : files.filter(f => f.includes('typography') && !f.endsWith('-classes.css')).sort();

    // Effects classes: look for consolidated -effects-classes.css or light/dark class files
    const effectsClassesConsolidated = files.find(f => f.endsWith('-effects-classes.css'));
    const effectsLightClasses = files.find(f => f.includes('-effects-light-classes.css'));
    const effectsDarkClasses = files.find(f => f.includes('-effects-dark-classes.css'));
    const effectsClassFiles = effectsClassesConsolidated
      ? [effectsClassesConsolidated]
      : [effectsLightClasses, effectsDarkClasses].filter(Boolean);

    // Only create utilities file if there are typography or effect classes
    if (typographyFiles.length > 0 || effectsClassFiles.length > 0) {
      let utilitiesContent = generateHeader(brand, 'component-utilities', `${componentName} Utility Classes`);

      // Typography classes
      if (typographyFiles.length > 0) {
        utilitiesContent += '/* === TYPOGRAPHY CLASSES === */\n\n';
        for (const file of typographyFiles) {
          const fileContent = readAndStripHeader(file);
          if (fileContent) utilitiesContent += fileContent + '\n\n';
        }
      }

      // Effects classes
      if (effectsClassFiles.length > 0) {
        utilitiesContent += '/* === EFFECT CLASSES === */\n\n';
        for (const file of effectsClassFiles) {
          const fileContent = readAndStripHeader(file);
          if (fileContent) utilitiesContent += fileContent + '\n\n';
        }
      }

      // Write component utilities file
      const utilitiesPath = path.join(componentsOutputDir, `${componentName.toLowerCase()}-utilities.css`);
      fs.writeFileSync(utilitiesPath, utilitiesContent.trim() + '\n');

      allUtilitiesContent += utilitiesContent;
      utilitiesCount++;
    }
  }

  return {
    count: componentCount,
    content: allComponentsContent,
    utilitiesCount,
    utilitiesContent: allUtilitiesContent
  };
}

// ============================================================================
// BUILD BRAND UTILITIES (Semantic Typography + Effect Classes)
// ============================================================================

async function buildBrandUtilities(brand) {
  const brandSourceDir = path.join(CSS_DIR, 'brands', brand);
  const brandOutputDir = path.join(CSS_DIR, brand);
  ensureDir(brandOutputDir);

  let content = generateHeader(brand, 'utilities');

  // 1. Typography classes (from typography-responsive.css)
  const typographyResponsive = path.join(brandSourceDir, 'semantic', 'typography', 'typography-responsive.css');
  if (fs.existsSync(typographyResponsive)) {
    content += '/* === TYPOGRAPHY CLASSES === */\n\n';
    const fileContent = readAndStripHeader(typographyResponsive);
    if (fileContent) {
      content += fileContent + '\n\n';
    }
  }

  // 2. Effects classes (from effects-classes.css or effects-light-classes.css + effects-dark-classes.css)
  const effectsDir = path.join(brandSourceDir, 'semantic', 'effects');
  if (fs.existsSync(effectsDir)) {
    // Prefer consolidated mode-agnostic file
    const consolidatedClasses = path.join(effectsDir, 'effects-classes.css');

    if (fs.existsSync(consolidatedClasses)) {
      content += '/* === EFFECT CLASSES (Mode-agnostic) === */\n\n';
      const fileContent = readAndStripHeader(consolidatedClasses);
      if (fileContent) content += fileContent + '\n\n';
    } else {
      // Fallback: Separate light/dark class files
      const lightClasses = path.join(effectsDir, 'effects-light-classes.css');
      const darkClasses = path.join(effectsDir, 'effects-dark-classes.css');

      if (fs.existsSync(lightClasses)) {
        content += '/* === EFFECT CLASSES (Light) === */\n\n';
        const fileContent = readAndStripHeader(lightClasses);
        if (fileContent) content += fileContent + '\n\n';
      }
      if (fs.existsSync(darkClasses)) {
        content += '/* === EFFECT CLASSES (Dark) === */\n\n';
        const fileContent = readAndStripHeader(darkClasses);
        if (fileContent) content += fileContent + '\n\n';
      }
    }
  }

  const outputPath = path.join(brandOutputDir, 'utilities.css');
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// BUILD UTILITIES BUNDLE (Semantic + Component Utilities)
// ============================================================================

async function buildUtilitiesBundle(brand, semanticUtilitiesContent, componentUtilitiesContent) {
  const bundlesDir = path.join(CSS_DIR, 'bundles');
  ensureDir(bundlesDir);

  let content = generateHeader(brand, 'full-utilities');

  // Add semantic utilities (without header)
  if (semanticUtilitiesContent) {
    content += '/* ============================================================\n';
    content += '   SEMANTIC UTILITIES (Typography + Effects Classes)\n';
    content += '   ============================================================ */\n\n';
    const body = semanticUtilitiesContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += body + '\n\n';
  }

  // Add component utilities (without headers)
  if (componentUtilitiesContent) {
    content += '/* ============================================================\n';
    content += '   COMPONENT UTILITIES\n';
    content += '   ============================================================ */\n\n';
    // Strip all headers from component utilities
    const body = componentUtilitiesContent.replace(/\/\*\*[\s\S]*?\*\/\s*/g, '');
    content += body + '\n\n';
  }

  const outputPath = path.join(bundlesDir, `${brand}-utilities.css`);
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// BUILD FULL BRAND BUNDLE
// ============================================================================

async function buildFullBundle(brand, primitivesContent, colorsContent, sizingContent, componentsContent) {
  const bundlesDir = path.join(CSS_DIR, 'bundles');
  ensureDir(bundlesDir);

  let content = generateHeader(brand, 'full');

  // Add primitives (without header)
  if (primitivesContent) {
    content += '/* ============================================================\n';
    content += '   PRIMITIVES\n';
    content += '   ============================================================ */\n\n';
    // Strip the header from primitives content
    const primitivesBody = primitivesContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += primitivesBody + '\n\n';
  }

  // Add colors (without header)
  if (colorsContent) {
    content += '/* ============================================================\n';
    content += '   COLORS (COLOR TOKENS + EFFECTS)\n';
    content += '   ============================================================ */\n\n';
    const colorsBody = colorsContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += colorsBody + '\n\n';
  }

  // Add sizing (without header)
  if (sizingContent) {
    content += '/* ============================================================\n';
    content += '   SIZING (DENSITY + BREAKPOINTS)\n';
    content += '   ============================================================ */\n\n';
    const sizingBody = sizingContent.replace(/^\/\*\*[\s\S]*?\*\/\s*/, '');
    content += sizingBody + '\n\n';
  }

  // Add components (without headers)
  if (componentsContent) {
    content += '/* ============================================================\n';
    content += '   COMPONENTS\n';
    content += '   ============================================================ */\n\n';
    // Strip all headers from components
    const componentsBody = componentsContent.replace(/\/\*\*[\s\S]*?\*\/\s*/g, '');
    content += componentsBody + '\n\n';
  }

  const outputPath = path.join(bundlesDir, `${brand}.css`);
  fs.writeFileSync(outputPath, content.trim() + '\n');

  return content;
}

// ============================================================================
// MAIN BUILD FUNCTION
// ============================================================================

async function buildAllBundles() {
  console.log('\nğŸ¨ ============================================');
  console.log('   CSS Bundle Builder v3 (Optimized Structure)');
  console.log('   ============================================\n');

  const startTime = Date.now();

  // 1. Build shared primitives (once for all brands)
  const primitivesContent = await buildSharedPrimitives();

  // 2. Build per-brand bundles
  console.log('\nğŸ·ï¸  Building Brand Bundles:');

  for (const brand of BRANDS) {
    console.log(`\n  ğŸ“¦ ${brand.toUpperCase()}:`);

    // Colors (Light/Dark + Effects variables)
    const colorsContent = await buildBrandColors(brand);
    console.log(`     âœ… colors.css (${getFileSize(colorsContent)} KB)`);

    // Sizing (Density + Breakpoints) - NO typography classes
    const sizingContent = await buildBrandSizing(brand);
    console.log(`     âœ… sizing.css (${getFileSize(sizingContent)} KB)`);

    // Utilities (Typography + Effect classes)
    const utilitiesContent = await buildBrandUtilities(brand);
    console.log(`     âœ… utilities.css (${getFileSize(utilitiesContent)} KB)`);

    // Components (tokens + utilities)
    const { count: componentCount, content: componentsContent, utilitiesCount, utilitiesContent: componentUtilitiesContent } = await buildBrandComponents(brand);
    console.log(`     âœ… components/ (${componentCount} components, ${utilitiesCount} utility files)`);

    // Full bundle (tokens only, no classes)
    const fullContent = await buildFullBundle(brand, primitivesContent, colorsContent, sizingContent, componentsContent);
    console.log(`     âœ… bundles/${brand}.css (${getFileSize(fullContent)} KB)`);

    // Full utilities bundle (all classes combined)
    const fullUtilitiesContent = await buildUtilitiesBundle(brand, utilitiesContent, componentUtilitiesContent);
    console.log(`     âœ… bundles/${brand}-utilities.css (${getFileSize(fullUtilitiesContent)} KB)`);
  }

  // 3. Cleanup legacy/intermediate directories
  cleanupLegacyStructure();

  const duration = ((Date.now() - startTime) / 1000).toFixed(2);

  console.log('\nâœ¨ Bundle Build Complete!');
  console.log(`\nğŸ“Š Duration: ${duration}s`);

  console.log('\nğŸ“ Output Structure:');
  console.log('   dist/css/');
  console.log('   â”œâ”€â”€ shared/');
  console.log('   â”‚   â””â”€â”€ primitives.css');
  for (const brand of BRANDS) {
    console.log(`   â”œâ”€â”€ ${brand}/`);
    console.log('   â”‚   â”œâ”€â”€ colors.css         (colors + effects variables)');
    console.log('   â”‚   â”œâ”€â”€ sizing.css         (density + breakpoints)');
    console.log('   â”‚   â”œâ”€â”€ utilities.css      (typography + effect classes)');
    console.log('   â”‚   â””â”€â”€ components/');
    console.log('   â”‚       â”œâ”€â”€ {component}.css           (tokens)');
    console.log('   â”‚       â””â”€â”€ {component}-utilities.css (classes)');
  }
  console.log('   â””â”€â”€ bundles/');
  for (const brand of BRANDS) {
    console.log(`       â”œâ”€â”€ ${brand}.css            (full tokens bundle)`);
    console.log(`       â””â”€â”€ ${brand}-utilities.css  (full utilities bundle)`);
  }
}

// Run
buildAllBundles().catch(console.error);

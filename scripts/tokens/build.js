#!/usr/bin/env node

/**
 * Build Script for Style Dictionary Token Pipeline v2
 *
 * This script orchestrates the build process for:
 * - Classic Tokens (variables)
 * - Composite Tokens (typography & effects)
 * - Brand Ã— Breakpoint/ColorMode matrix
 */

const StyleDictionary = require('style-dictionary').default;
const fs = require('fs');
const path = require('path');

// Import custom config
const customConfig = require('../../build-config/tokens/style-dictionary.config.js');

const TOKENS_DIR = path.join(__dirname, '../../packages/tokens/.tokens');
const DIST_DIR = path.join(__dirname, '../../packages/tokens/dist');

// Native platform output directories (separate packages for SPM/Maven distribution)
const IOS_DIST_DIR = path.join(__dirname, '../../packages/tokens-ios/Sources/BildDesignTokens');
const ANDROID_DIST_DIR = path.join(__dirname, '../../packages/tokens-android/src/main/kotlin/com/bild/designsystem');

// Brands and breakpoints
const BRANDS = ['bild', 'sportbild', 'advertorial'];
const COLOR_BRANDS = ['bild', 'sportbild'];  // Brands with their own color tokens
const CONTENT_BRANDS = ['bild', 'sportbild', 'advertorial'];  // All brands (for sizing/typography)
const BREAKPOINTS = ['xs', 'sm', 'md', 'lg'];
const COLOR_MODES = ['light', 'dark'];
const DENSITY_MODES = ['default', 'dense', 'spacious'];

// Platform output toggles - set to false to disable output generation
const COMPOSE_ENABLED = true;
const SWIFTUI_ENABLED = true;       // SwiftUI output in dist/ios/

// Token type toggles - set to false to exclude from all platform outputs
const BOOLEAN_TOKENS_ENABLED = false;

// Figma description comment toggles per platform
// Controls whether token.comment (from Figma descriptions) is output as code comments
// Does NOT affect: file headers, section comments, or structural comments
const SHOW_DESCRIPTIONS = {
  css: false,      // Disabled - cleaner CSS output
  scss: true,      // Enabled for SCSS
  js: true,        // Enabled for JS
  ios: true,       // Enabled for iOS/Swift
  android: true    // Enabled for Android/Kotlin
};

// iOS: Uses 2 size classes (Apple HIG)
// Maps sm (390px) â†’ compact, lg (1024px) â†’ regular
const IOS_BREAKPOINTS = ['sm', 'lg'];
const IOS_SIZE_CLASS_MAPPING = {
  sm: 'compact',
  lg: 'regular'
};

// Android: Uses 3 size classes (Material 3 WindowSizeClass)
// Maps sm (390px) â†’ Compact (<600dp), md (600px) â†’ Medium (600-839dp), lg (1024px) â†’ Expanded (â‰¥840dp)
const ANDROID_BREAKPOINTS = ['sm', 'md', 'lg'];
const ANDROID_SIZE_CLASS_MAPPING = {
  sm: 'compact',
  md: 'medium',
  lg: 'expanded'
};

// Package.json references for dynamic header generation
const tokensPackageJson = require('../../packages/tokens/package.json');
const rootPackageJson = require('../../package.json');

/**
 * Gets the Style Dictionary version from package.json dependencies
 * @returns {string} Version string (e.g., "4.2.0")
 */
function getStyleDictionaryVersion() {
  const sdVersion = rootPackageJson.dependencies?.['style-dictionary']
    || rootPackageJson.devDependencies?.['style-dictionary']
    || '4.x';
  return sdVersion.replace(/^[\^~]/, '');
}

/**
 * Gets the documentation URL for a specific platform
 * @param {string} platform - Platform identifier (css, scss, js, ios, android)
 * @returns {string} Full URL to platform-specific documentation
 */
function getDocumentationUrl(platform) {
  const repoUrl = tokensPackageJson.repository?.url?.replace(/^git\+/, '').replace(/\.git$/, '')
    || 'https://github.com/user/design-system-tokens';
  const baseDocsUrl = `${repoUrl}/blob/main/packages/tokens`;

  const platformDocs = {
    css: `${baseDocsUrl}/docs/css.md`,
    scss: `${baseDocsUrl}/docs/css.md`,
    js: `${baseDocsUrl}/docs/js.md`,
    ios: `${baseDocsUrl}/docs/ios.md`,
    android: `${baseDocsUrl}/docs/android.md`,
    default: `${baseDocsUrl}/README.md`
  };

  return platformDocs[platform] || platformDocs.default;
}

/**
 * Loads the Breakpoint Ã— Density matrix generated by preprocess.js
 * This matrix contains fully resolved values (ID-based resolution)
 *
 * @returns {Object} Matrix with tokens and their Breakpoint Ã— Density values
 */
function loadBreakpointDensityMatrix() {
  const matrixPath = path.join(TOKENS_DIR, 'shared', 'breakpoint-density-matrix.json');

  if (!fs.existsSync(matrixPath)) {
    console.warn(`Breakpoint Ã— Density matrix not found: ${matrixPath}`);
    return {};
  }

  return JSON.parse(fs.readFileSync(matrixPath, 'utf8'));
}

/**
 * Loads the Breakpoint Ã— Density matrix for a specific component.
 * Used to generate component-level Density resolvers with WindowSizeClass Ã— Density.
 *
 * @param {string} brand - Brand name (bild, sportbild, advertorial)
 * @param {string} componentName - Component name (Button, InputField, etc.)
 * @returns {Object} Matrix with token values per breakpoint Ã— density combination
 */
function loadComponentDensityMatrix(brand, componentName) {
  const matrixPath = path.join(TOKENS_DIR, 'brands', brand, 'components', componentName, 'breakpoint-density-matrix.json');

  if (!fs.existsSync(matrixPath)) {
    return null;
  }

  return JSON.parse(fs.readFileSync(matrixPath, 'utf8'));
}

/**
 * Checks if a token has constant values across all breakpoints
 * (i.e., same value for xs, sm, md, lg)
 *
 * @param {Object} tokenValues - The values object from the matrix
 * @returns {boolean} True if constant across breakpoints
 */
function isConstantAcrossBreakpoints(tokenValues) {
  const breakpoints = Object.keys(tokenValues);
  if (breakpoints.length < 2) return true;

  const firstBp = tokenValues[breakpoints[0]];
  return breakpoints.every(bp => {
    const bpValues = tokenValues[bp];
    return bpValues.default === firstBp.default &&
           bpValues.dense === firstBp.dense &&
           bpValues.spacious === firstBp.spacious;
  });
}

/**
 * Generates density-aware spacing code for Android Compose.
 * Uses the Breakpoint Ã— Density matrix with directly resolved values.
 *
 * Consumer API: DesignSystemTheme.stackSpaceRespMd
 * Values are resolved at build-time from the ID-based matrix.
 *
 * @returns {string} Kotlin code with direct values
 */
function generateAndroidDensityResolvers() {
  const matrix = loadBreakpointDensityMatrix();
  const tokenNames = Object.keys(matrix);

  if (tokenNames.length === 0) {
    return '    // No density-referencing tokens found in BreakpointMode';
  }

  // Separate constant and responsive tokens
  const constantTokens = [];
  const responsiveTokens = [];

  for (const [name, tokenData] of Object.entries(matrix)) {
    if (isConstantAcrossBreakpoints(tokenData.values)) {
      constantTokens.push({ name, ...tokenData });
    } else {
      responsiveTokens.push({ name, ...tokenData });
    }
  }

  let output = `    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DENSITY-AWARE SPACING (Auto-generated from Breakpoint Ã— Density Matrix)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //
    // Values resolved at build-time using ID-based cross-collection resolution.
    // WindowSizeClass mapping: Compactâ†’sm, Mediumâ†’md, Expandedâ†’lg
    //
    // Consumer API: DesignSystemTheme.stackSpaceRespMd

`;

  // Generate constant token resolvers (same across breakpoints, varies by density)
  if (constantTokens.length > 0) {
    output += '    // Constant spacing tokens (same value across all breakpoints)\n\n';
    for (const token of constantTokens) {
      const values = token.values.xs; // All breakpoints have same values
      output += `    /** ${token.name} - constant spacing, varies only by density mode */
    val ${token.name}: Dp
        @Composable @ReadOnlyComposable get() = when (density) {
            Density.Dense -> ${values.dense}.dp
            Density.Default -> ${values.default}.dp
            Density.Spacious -> ${values.spacious}.dp
        }

`;
    }
  }

  // Generate responsive token resolvers (varies by breakpoint AND density)
  if (responsiveTokens.length > 0) {
    output += '    // Responsive spacing tokens (resolved by WindowSizeClass Ã— Density)\n\n';
    for (const token of responsiveTokens) {
      const v = token.values;
      // Map WindowSizeClass: Compactâ†’sm, Mediumâ†’md, Expandedâ†’lg
      const sm = v.sm || v.xs;
      const md = v.md || v.sm || v.xs;
      const lg = v.lg || v.md || v.sm || v.xs;

      output += `    /** ${token.name} - responsive spacing, varies by WindowSizeClass and density mode */
    val ${token.name}: Dp
        @Composable @ReadOnlyComposable get() = when (sizeClass) {
            WindowSizeClass.Compact -> when (density) {
                Density.Dense -> ${sm.dense}.dp
                Density.Default -> ${sm.default}.dp
                Density.Spacious -> ${sm.spacious}.dp
            }
            WindowSizeClass.Medium -> when (density) {
                Density.Dense -> ${md.dense}.dp
                Density.Default -> ${md.default}.dp
                Density.Spacious -> ${md.spacious}.dp
            }
            WindowSizeClass.Expanded -> when (density) {
                Density.Dense -> ${lg.dense}.dp
                Density.Default -> ${lg.default}.dp
                Density.Spacious -> ${lg.spacious}.dp
            }
        }

`;
    }
  }

  return output.trimEnd();
}

/**
 * Generates density-aware spacing code for iOS SwiftUI.
 * Uses the Breakpoint Ã— Density matrix with directly resolved values.
 *
 * Consumer API: theme.stackSpaceRespMd
 * Values are resolved at build-time from the ID-based matrix.
 *
 * @returns {string} Swift code with direct values
 */
function generateiOSDensityResolvers() {
  const matrix = loadBreakpointDensityMatrix();
  const tokenNames = Object.keys(matrix);

  if (tokenNames.length === 0) {
    return '    // No density-referencing tokens found in BreakpointMode';
  }

  // Separate constant and responsive tokens
  const constantTokens = [];
  const responsiveTokens = [];

  for (const [name, tokenData] of Object.entries(matrix)) {
    if (isConstantAcrossBreakpoints(tokenData.values)) {
      constantTokens.push({ name, ...tokenData });
    } else {
      responsiveTokens.push({ name, ...tokenData });
    }
  }

  let output = `    // MARK: - Density-Aware Spacing (Auto-generated from Breakpoint Ã— Density Matrix)
    //
    // Values resolved at build-time using ID-based cross-collection resolution.
    // SizeClass mapping: compactâ†’sm, regularâ†’lg
    //
    // Consumer API: theme.stackSpaceRespMd

`;

  // Generate constant token resolvers (same across breakpoints, varies by density)
  if (constantTokens.length > 0) {
    output += '    // Constant spacing tokens (same value across all breakpoints)\n\n';
    for (const token of constantTokens) {
      const values = token.values.xs; // All breakpoints have same values
      output += `    /// ${token.name} - constant spacing, varies only by density mode
    public var ${token.name}: CGFloat {
        switch density {
        case .dense: return ${values.dense}
        case .default: return ${values.default}
        case .spacious: return ${values.spacious}
        }
    }

`;
    }
  }

  // Generate responsive token resolvers (varies by breakpoint AND density)
  if (responsiveTokens.length > 0) {
    output += '    // Responsive spacing tokens (resolved by SizeClass Ã— Density)\n\n';
    for (const token of responsiveTokens) {
      const v = token.values;
      // Map SizeClass: compactâ†’sm, regularâ†’lg
      const sm = v.sm || v.xs;
      const lg = v.lg || v.md || v.sm || v.xs;

      output += `    /// ${token.name} - responsive spacing, varies by SizeClass and density mode
    public var ${token.name}: CGFloat {
        if sizeClass == .compact {
            switch density {
            case .dense: return ${sm.dense}
            case .default: return ${sm.default}
            case .spacious: return ${sm.spacious}
            }
        } else {
            switch density {
            case .dense: return ${lg.dense}
            case .default: return ${lg.default}
            case .spacious: return ${lg.spacious}
            }
        }
    }

`;
    }
  }

  return output.trimEnd();
}

/**
 * Generates a standardized file header for generated token files
 * @param {Object} options - Header options
 * @param {string} options.fileName - Name of the generated file
 * @param {string} options.commentStyle - Comment style ('block', 'line', 'xml')
 * @param {string} options.platform - Target platform (css, js, ios, android)
 * @param {string} [options.brand] - Brand name if applicable
 * @param {string} [options.context] - Additional context about the file
 * @returns {string} Formatted header string
 */
function generateFileHeader({ fileName, commentStyle, platform, brand, context }) {
  const version = tokensPackageJson.version;
  const sdVersion = getStyleDictionaryVersion();
  const docsUrl = getDocumentationUrl(platform);
  const currentYear = new Date().getFullYear();

  const lines = [
    'Do not edit directly, this file was auto-generated.',
    '',
    `BILD Design System Tokens v${version}`,
    `Generated by Style Dictionary v${sdVersion}`,
    ''
  ];

  if (context) {
    // Split context on newlines to ensure each line gets comment prefix
    const contextLines = context.split('\n');
    lines.push(`Context: ${contextLines[0]}`);
    for (let i = 1; i < contextLines.length; i++) {
      lines.push(contextLines[i]);
    }
    lines.push('');
  }

  if (brand) {
    lines.push(`Brand: ${brand}`);
    lines.push('');
  }

  lines.push(`Copyright (c) ${currentYear} Axel Springer Deutschland GmbH`);
  lines.push('Proprietary and confidential. All rights reserved.');
  lines.push('');
  lines.push(`Documentation: ${docsUrl}`);

  if (commentStyle === 'block') {
    return '/**\n' + lines.map(line => ` * ${line}`.trimEnd()).join('\n') + '\n */\n';
  } else if (commentStyle === 'line') {
    return lines.map(line => `// ${line}`.trimEnd()).join('\n') + '\n';
  } else if (commentStyle === 'xml') {
    return '<!--\n' + lines.map(line => `  ${line}`).join('\n') + '\n-->\n';
  }

  return lines.map(line => `// ${line}`.trimEnd()).join('\n') + '\n';
}

// Helper to check if a breakpoint should be built for a native platform
// @param {string} breakpoint - The breakpoint to check (xs, sm, md, lg)
// @param {string} platform - The platform ('ios' or 'android'), defaults to 'ios'
function isNativeBreakpoint(breakpoint, platform = 'ios') {
  const breakpoints = platform === 'android' ? ANDROID_BREAKPOINTS : IOS_BREAKPOINTS;
  return breakpoints.includes(breakpoint);
}

// Helper to get sizeclass name from breakpoint for a native platform
// @param {string} breakpoint - The breakpoint (xs, sm, md, lg)
// @param {string} platform - The platform ('ios' or 'android'), defaults to 'ios'
function getSizeClassName(breakpoint, platform = 'ios') {
  const mapping = platform === 'android' ? ANDROID_SIZE_CLASS_MAPPING : IOS_SIZE_CLASS_MAPPING;
  return mapping[breakpoint] || breakpoint;
}

/**
 * Builds a dual selector for Light DOM and Shadow DOM compatibility.
 * Used in responsive CSS generation to support both contexts.
 *
 * @param {string} attrSelector - The attribute selector, e.g., [data-content-brand="bild"]
 * @param {string} [classSelector] - Optional class selector, e.g., .headline-1
 * @returns {string} Combined selector for both contexts
 */
function buildDualSelector(attrSelector, classSelector = '') {
  if (classSelector) {
    return `${attrSelector} ${classSelector},\n:host(${attrSelector}) ${classSelector}`;
  }
  return `${attrSelector},\n:host(${attrSelector})`;
}

/**
 * Creates platform configuration for standard tokens (Primitives, Brand-specific, etc.)
 * CSS version with data-attributes for runtime theme switching
 *
 * @param {string} buildPath - Base build path
 * @param {string} fileName - Output file name
 * @param {object} cssOptions - CSS-specific options { brand, mode, modeType }
 */
function createStandardPlatformConfig(buildPath, fileName, cssOptions = {}) {
  // Filter to exclude documentation-only tokens and disabled token types
  const tokenFilter = (token) => {
    // Exclude TextLabels tokens - these are documentation-only and cause name collisions
    if (token.path && token.path.includes('TextLabels')) {
      return false;
    }
    // Exclude boolean tokens when disabled (visibility tokens like hideOnMobile, etc.)
    if (!BOOLEAN_TOKENS_ENABLED && token.type === 'boolean') {
      return false;
    }
    return true;
  };

  // Load density-matrix token names for exclusion from native SizingScheme files
  // These tokens are exposed ONLY via DesignSystemTheme density resolvers (Single Entry Point pattern)
  const densityMatrixTokenNames = new Set(Object.keys(loadBreakpointDensityMatrix()));

  // Native platform filter: excludes density-matrix tokens from SizingScheme files
  // This prevents token duplication - density-aware tokens are only in DesignSystemTheme
  const nativeTokenFilter = (token) => {
    // First apply standard token filter
    if (!tokenFilter(token)) {
      return false;
    }

    // For breakpoint mode, exclude tokens that are in the density matrix
    // These tokens are exposed via DesignSystemTheme.stackSpaceRespMd etc.
    if (cssOptions.modeType === 'breakpoint' && densityMatrixTokenNames.size > 0) {
      const tokenName = token.path[token.path.length - 1];
      if (densityMatrixTokenNames.has(tokenName)) {
        return false;
      }
    }

    return true;
  };

  return {
    css: {
      transformGroup: 'custom/css',
      buildPath: `${buildPath}/`,
      files: [{
        destination: `${fileName}.css`,
        // Use alias format for CSS to generate var(--primitive, fallback) references
        format: cssOptions.brand || cssOptions.mode ? 'custom/css/themed-variables-with-alias' : 'custom/css/variables-with-alias',
        filter: tokenFilter,
        options: {
          outputReferences: true,  // Enable var() references to primitives
          showDescriptions: SHOW_DESCRIPTIONS.css,
          ...cssOptions  // brand, mode, modeType for data-attributes
        }
      }]
    },
    scss: {
      transformGroup: 'custom/scss',
      buildPath: `${DIST_DIR}/scss/${buildPath.replace(DIST_DIR + '/css/', '')}/`,
      files: [{
        destination: `${fileName}.scss`,
        format: 'custom/scss/variables',
        filter: tokenFilter,
        options: { outputReferences: false, showDescriptions: SHOW_DESCRIPTIONS.scss }
      }]
    },
    json: {
      transformGroup: 'custom/js',
      buildPath: `${DIST_DIR}/json/${buildPath.replace(DIST_DIR + '/css/', '')}/`,
      files: [{
        destination: `${fileName}.json`,
        format: 'json',
        filter: tokenFilter,
        options: { outputReferences: false }
      }]
    },
    // iOS: SwiftUI format - For breakpoint mode, use sizeclass folder and naming, skip non-native breakpoints
    // Skip ios platform when SWIFTUI_ENABLED since swiftui platform generates the same output correctly
    // Skip density tokens - they are now generated as shared (brand-independent) via buildSharedDensityTokens()
    ...((cssOptions.modeType === 'breakpoint' && !isNativeBreakpoint(cssOptions.mode)) || cssOptions.modeType === 'density' || SWIFTUI_ENABLED ? {} : {
      ios: {
        transformGroup: 'custom/ios-swift',
        buildPath: (() => {
          let iosPath = buildPath.replace(DIST_DIR + '/css/', '');
          // For semantic breakpoint tokens, change folder from 'breakpoints' to 'sizeclass'
          if (cssOptions.modeType === 'breakpoint' && iosPath.includes('/breakpoints')) {
            iosPath = iosPath.replace('/breakpoints', '/sizeclass');
          }
          return `${IOS_DIST_DIR}/${iosPath}/`;
        })(),
        files: [{
          destination: (() => {
            // For breakpoint tokens, use sizeclass naming
            if (cssOptions.modeType === 'breakpoint' && cssOptions.mode) {
              const sizeClass = getSizeClassName(cssOptions.mode);
              const isComponent = buildPath.includes('/components/');
              if (isComponent) {
                // Extract component name from path (e.g., .../components/Button/ -> Button)
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                const componentName = componentMatch ? componentMatch[1] : '';
                return `${componentName}Sizing${sizeClass.charAt(0).toUpperCase() + sizeClass.slice(1)}.swift`;
              }
              return `Sizing${sizeClass.charAt(0).toUpperCase() + sizeClass.slice(1)}.swift`;
            }
            // For color tokens
            if (cssOptions.modeType === 'color' && cssOptions.mode) {
              const mode = cssOptions.mode === 'light' ? 'Light' : 'Dark';
              const isComponent = buildPath.includes('/components/');
              if (isComponent) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                const componentName = componentMatch ? componentMatch[1] : '';
                return `${componentName}Colors${mode}.swift`;
              }
              return `Colors${mode}.swift`;
            }
            // For density tokens
            if (cssOptions.modeType === 'density' && cssOptions.mode) {
              const densityMode = cssOptions.mode.charAt(0).toUpperCase() + cssOptions.mode.slice(1);
              const isComponent = buildPath.includes('/components/');
              if (isComponent) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                const componentName = componentMatch ? componentMatch[1] : '';
                return `${componentName}Density${densityMode}.swift`;
              }
              return `Density${densityMode}.swift`;
            }
            return `${fileName.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('')}.swift`;
          })(),
          format: (() => {
            // Use SwiftUI component tokens format based on token type
            const isComponent = buildPath.includes('/components/');
            if (isComponent) {
              return 'swiftui/component-tokens';
            }
            // Semantic tokens
            if (cssOptions.modeType === 'color') {
              return 'swiftui/color-scheme';
            }
            if (cssOptions.modeType === 'breakpoint') {
              return 'swiftui/sizing-scheme';
            }
            return 'swiftui/component-tokens';
          })(),
          filter: nativeTokenFilter,
          options: {
            outputReferences: false,
            brand: (() => {
              const brandMatch = buildPath.match(/\/brands\/([^/]+)/);
              return brandMatch ? brandMatch[1] : 'bild';
            })(),
            component: (() => {
              const componentMatch = buildPath.match(/\/components\/([^/]+)/);
              return componentMatch ? componentMatch[1] : '';
            })(),
            tokenType: (() => {
              if (cssOptions.modeType === 'color') return 'color';
              if (cssOptions.modeType === 'density') return 'density';
              return 'sizing';
            })(),
            mode: (() => {
              if (cssOptions.modeType === 'color') {
                return cssOptions.mode; // light or dark
              }
              if (cssOptions.modeType === 'breakpoint') {
                return getSizeClassName(cssOptions.mode); // compact or regular
              }
              return cssOptions.mode;
            })(),
            sizeClass: getSizeClassName(cssOptions.mode)
          }
        }]
      }
    }),
    // Compose: For breakpoint mode, use sizeclass folder and naming, skip non-native breakpoints
    // Skip density tokens - they are now generated as shared (brand-independent) via buildSharedDensityTokens()
    // Skip compose for overrides (brand mapping layer) - these are intermediate tokens not needed in final output
    // Android uses 3 size classes: Compact, Medium, Expanded (Material 3 WindowSizeClass)
    ...((cssOptions.modeType === 'breakpoint' && !isNativeBreakpoint(cssOptions.mode, 'android')) || cssOptions.modeType === 'density' || !COMPOSE_ENABLED || cssOptions.skipCompose ? {} : {
      compose: {
        transformGroup: 'custom/compose',
        buildPath: (() => {
          let composePath = buildPath.replace(DIST_DIR + '/css/', '');
          // For semantic breakpoint tokens, change folder from 'breakpoints' to 'sizeclass'
          if (cssOptions.modeType === 'breakpoint' && composePath.includes('/breakpoints')) {
            composePath = composePath.replace('/breakpoints', '/sizeclass');
          }
          // Lowercase component directory names to match Kotlin package conventions
          if (composePath.includes('/components/')) {
            composePath = composePath.replace(/\/components\/([^/]+)/, (match, name) => `/components/${name.toLowerCase()}`);
          }
          return `${ANDROID_DIST_DIR}/${composePath}/`;
        })(),
        files: [{
          destination: (() => {
            // For breakpoint tokens, use sizeclass naming (Android: Compact, Medium, Expanded)
            if (cssOptions.modeType === 'breakpoint' && cssOptions.mode) {
              const sizeClass = getSizeClassName(cssOptions.mode, 'android');
              const isComponent = buildPath.includes('/components/');
              if (isComponent) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                const componentName = componentMatch ? componentMatch[1] : '';
                return `${componentName}Sizing${sizeClass.charAt(0).toUpperCase() + sizeClass.slice(1)}.kt`;
              }
              return `Sizing${sizeClass.charAt(0).toUpperCase() + sizeClass.slice(1)}.kt`;
            }
            // For color mode tokens
            if (cssOptions.modeType === 'theme' && cssOptions.mode) {
              const modeName = cssOptions.mode.charAt(0).toUpperCase() + cssOptions.mode.slice(1);
              const isComponent = buildPath.includes('/components/');
              if (isComponent) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                const componentName = componentMatch ? componentMatch[1] : '';
                return `${componentName}Colors${modeName}.kt`;
              }
              return `Colors${modeName}.kt`;
            }
            // For density tokens
            if (cssOptions.modeType === 'density' && cssOptions.mode) {
              const modeName = cssOptions.mode.charAt(0).toUpperCase() + cssOptions.mode.slice(1);
              const isComponent = buildPath.includes('/components/');
              if (isComponent) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                const componentName = componentMatch ? componentMatch[1] : '';
                return `${componentName}Density${modeName}.kt`;
              }
              return `Density${modeName}.kt`;
            }
            // Default: PascalCase filename
            return `${fileName.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('')}.kt`;
          })(),
          format: (() => {
            // Choose format based on token type
            if (buildPath.includes('/shared/')) {
              return 'compose/primitives';
            }
            // For components, use component-tokens format for all mode types
            if (buildPath.includes('/components/')) {
              return 'compose/component-tokens';
            }
            if (cssOptions.modeType === 'theme') {
              return 'compose/semantic-colors';
            }
            if (cssOptions.modeType === 'breakpoint' || cssOptions.modeType === 'density') {
              return 'compose/spacing';
            }
            return 'compose/primitives';
          })(),
          filter: nativeTokenFilter,
          options: {
            outputReferences: false,
            packageName: (() => {
              const basePkg = 'com.bild.designsystem';
              if (buildPath.includes('/shared/')) {
                return `${basePkg}.shared`;
              }
              if (cssOptions.brand) {
                if (buildPath.includes('/components/')) {
                  // Extract component name from path and add to package (lowercase)
                  const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                  const componentName = componentMatch ? componentMatch[1].toLowerCase() : '';
                  return componentName
                    ? `${basePkg}.brands.${cssOptions.brand}.components.${componentName}`
                    : `${basePkg}.brands.${cssOptions.brand}.components`;
                }
                // For semantic tokens, include the subdirectory in the package name
                // File path must match package declaration in Kotlin
                let subdir = '';
                if (cssOptions.modeType === 'theme') {
                  subdir = '.color';  // color tokens go in semantic/color/
                } else if (cssOptions.modeType === 'breakpoint') {
                  subdir = '.sizeclass';  // breakpoint tokens go in semantic/sizeclass/
                }
                return `${basePkg}.brands.${cssOptions.brand}.semantic${subdir}`;
              }
              return basePkg;
            })(),
            className: (() => {
              if (cssOptions.modeType === 'breakpoint' && cssOptions.mode) {
                const sizeClass = getSizeClassName(cssOptions.mode, 'android');
                return `Sizing${sizeClass.charAt(0).toUpperCase() + sizeClass.slice(1)}`;
              }
              return fileName.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('');
            })(),
            brand: cssOptions.brand || '',
            mode: cssOptions.mode || '',
            modeType: (() => {
              if (cssOptions.modeType === 'breakpoint') return 'sizeclass';
              return cssOptions.modeType || '';
            })(),
            componentName: (() => {
              if (buildPath.includes('/components/')) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                return componentMatch ? componentMatch[1] : '';
              }
              return '';
            })(),
            tokenType: (() => {
              if (cssOptions.modeType === 'theme') return 'color';
              if (cssOptions.modeType === 'breakpoint') return 'sizing';
              if (cssOptions.modeType === 'density') return 'density';
              return '';
            })(),
            // Pass platform info for Android-specific size class naming
            platform: 'android'
          }
        }]
      }
    }),
    // SwiftUI: For breakpoint mode, use sizeclass folder and naming, skip non-native breakpoints
    // Skip swiftui for overrides (brand mapping layer) - these are intermediate tokens not needed in final output
    // Skip swiftui for individual primitives (they're consolidated into DesignTokenPrimitives.swift)
    // Skip density tokens - they are now generated as shared (brand-independent) via buildSharedDensityTokens()
    ...((cssOptions.modeType === 'breakpoint' && !isNativeBreakpoint(cssOptions.mode)) || cssOptions.modeType === 'density' || !SWIFTUI_ENABLED || cssOptions.skipCompose || cssOptions.skipSwiftUI ? {} : {
      swiftui: {
        transformGroup: 'custom/ios-swift',
        buildPath: (() => {
          let swiftuiPath = buildPath.replace(DIST_DIR + '/css/', '');
          // For semantic breakpoint tokens, change folder from 'breakpoints' to 'sizeclass'
          if (cssOptions.modeType === 'breakpoint' && swiftuiPath.includes('/breakpoints')) {
            swiftuiPath = swiftuiPath.replace('/breakpoints', '/sizeclass');
          }
          return `${IOS_DIST_DIR}/${swiftuiPath}/`;
        })(),
        files: [{
          destination: (() => {
            // Extract brand from path for prefixing semantic token files
            const brandMatch = buildPath.match(/\/brands\/([^/]+)/);
            const brand = brandMatch ? brandMatch[1] : '';
            const brandPascal = brand ? brand.charAt(0).toUpperCase() + brand.slice(1) : '';

            // For breakpoint tokens, use sizeclass naming
            if (cssOptions.modeType === 'breakpoint' && cssOptions.mode) {
              const sizeClass = getSizeClassName(cssOptions.mode);
              const isComponent = buildPath.includes('/components/');
              if (isComponent) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                const componentName = componentMatch ? componentMatch[1] : '';
                return `${componentName}Sizing${sizeClass.charAt(0).toUpperCase() + sizeClass.slice(1)}.swift`;
              }
              // Brand-prefix for semantic sizing files
              return `${brandPascal}Sizing${sizeClass.charAt(0).toUpperCase() + sizeClass.slice(1)}.swift`;
            }
            // For color mode tokens
            if (cssOptions.modeType === 'theme' && cssOptions.mode) {
              const modeName = cssOptions.mode.charAt(0).toUpperCase() + cssOptions.mode.slice(1);
              const isComponent = buildPath.includes('/components/');
              if (isComponent) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                const componentName = componentMatch ? componentMatch[1] : '';
                return `${componentName}Colors${modeName}.swift`;
              }
              // Brand-prefix for semantic color files
              return `${brandPascal}Colors${modeName}.swift`;
            }
            // For density tokens
            if (cssOptions.modeType === 'density' && cssOptions.mode) {
              const modeName = cssOptions.mode.charAt(0).toUpperCase() + cssOptions.mode.slice(1);
              const isComponent = buildPath.includes('/components/');
              if (isComponent) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                const componentName = componentMatch ? componentMatch[1] : '';
                return `${componentName}Density${modeName}.swift`;
              }
              // Brand-prefix for semantic density files
              return `${brandPascal}Density${modeName}.swift`;
            }
            // Default: PascalCase filename
            return `${fileName.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('')}.swift`;
          })(),
          format: (() => {
            // Choose format based on token type
            if (buildPath.includes('/shared/')) {
              return 'swiftui/primitives';
            }
            // For components, use component-tokens format for all mode types
            if (buildPath.includes('/components/')) {
              return 'swiftui/component-tokens';
            }
            if (cssOptions.modeType === 'theme') {
              return 'swiftui/color-scheme';
            }
            if (cssOptions.modeType === 'breakpoint') {
              return 'swiftui/sizing-scheme';
            }
            if (cssOptions.modeType === 'density') {
              return 'swiftui/sizing-scheme';  // density uses same sizing scheme format
            }
            return 'swiftui/primitives';
          })(),
          filter: nativeTokenFilter,
          options: {
            outputReferences: false,
            brand: cssOptions.brand || '',
            mode: (() => {
              if (cssOptions.modeType === 'breakpoint') {
                return getSizeClassName(cssOptions.mode);
              }
              return cssOptions.mode || '';
            })(),
            sizeClass: (() => {
              if (cssOptions.modeType === 'breakpoint') {
                return getSizeClassName(cssOptions.mode);
              }
              return '';
            })(),
            modeType: (() => {
              if (cssOptions.modeType === 'breakpoint') return 'sizeclass';
              return cssOptions.modeType || '';
            })(),
            componentName: (() => {
              if (buildPath.includes('/components/')) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                return componentMatch ? componentMatch[1] : '';
              }
              return '';
            })(),
            component: (() => {
              if (buildPath.includes('/components/')) {
                const componentMatch = buildPath.match(/\/components\/([^/]+)/);
                return componentMatch ? componentMatch[1] : '';
              }
              return '';
            })(),
            tokenType: (() => {
              if (cssOptions.modeType === 'theme') return 'color';
              if (cssOptions.modeType === 'breakpoint') return 'sizing';
              if (cssOptions.modeType === 'density') return 'density';
              return '';
            })()
          }
        }]
      }
    })
  };
}

/**
 * Cleans the dist directory
 */
function cleanDist() {
  console.log('ðŸ§¹ Cleaning dist directory...');
  if (fs.existsSync(DIST_DIR)) {
    fs.rmSync(DIST_DIR, { recursive: true });
  }
  fs.mkdirSync(DIST_DIR, { recursive: true });
}

/**
 * Registers custom transforms, transform groups and formats
 */
function registerCustomConfig() {
  // Register transforms
  Object.entries(customConfig.transforms).forEach(([name, transform]) => {
    try {
      StyleDictionary.registerTransform(transform);
    } catch (e) {
      // Already registered
    }
  });

  // Register transform groups
  if (customConfig.transformGroups) {
    Object.entries(customConfig.transformGroups).forEach(([name, transforms]) => {
      try {
        StyleDictionary.registerTransformGroup({
          name: name,
          transforms: transforms
        });
      } catch (e) {
        // Already registered
      }
    });
  }

  // Register formats
  Object.entries(customConfig.formats).forEach(([name, format]) => {
    try {
      StyleDictionary.registerFormat({
        name: name,
        format: format
      });
    } catch (e) {
      // Already registered
    }
  });
}

/**
 * Creates Style Dictionary config for Typography tokens
 */
function createTypographyConfig(brand, breakpoint) {
  const sourceFile = path.join(TOKENS_DIR, 'brands', brand, 'semantic', 'typography', `typography-${breakpoint}.json`);

  if (!fs.existsSync(sourceFile)) {
    return null;
  }

  const brandName = brand.charAt(0).toUpperCase() + brand.slice(1);
  const fileName = `typography-${breakpoint}`;

  return {
    source: [sourceFile],
    platforms: {
      // CSS: Custom format for Typography classes
      css: {
        transforms: ['attribute/cti'],
        buildPath: `${DIST_DIR}/css/brands/${brand}/semantic/typography/`,
        files: [{
          destination: `${fileName}.css`,
          format: 'css/typography-classes',
          options: {
            brand: brandName,
            breakpoint,
            showDescriptions: SHOW_DESCRIPTIONS.css
          }
        }]
      },

      // JSON: Standard JSON
      json: {
        transformGroup: 'js',
        buildPath: `${DIST_DIR}/json/brands/${brand}/semantic/typography/`,
        files: [{ destination: `${fileName}.json`, format: 'json', options: { outputReferences: false } }]
      },

      // SCSS: Custom Typography format
      scss: {
        transforms: ['attribute/cti'],
        buildPath: `${DIST_DIR}/scss/brands/${brand}/semantic/typography/`,
        files: [{
          destination: `${fileName}.scss`,
          format: 'scss/typography',
          options: {
            brand: brandName,
            breakpoint,
            showDescriptions: SHOW_DESCRIPTIONS.scss
          }
        }]
      },

      // iOS: Only compact (sm) and regular (lg) with SwiftUI format
      // Output to semantic/typography/ with brand-prefixed sizeclass in filename
      ...(isNativeBreakpoint(breakpoint, 'ios') ? {
        ios: {
          transformGroup: 'custom/ios-swift',
          buildPath: `${IOS_DIST_DIR}/brands/${brand}/semantic/typography/`,
          files: [{
            destination: `${brandName}TypographySizeclass${getSizeClassName(breakpoint, 'ios').charAt(0).toUpperCase() + getSizeClassName(breakpoint, 'ios').slice(1)}.swift`,
            format: 'swiftui/typography',
            options: {
              brand: brandName,
              breakpoint,
              sizeClass: getSizeClassName(breakpoint, 'ios'),
              showDescriptions: SHOW_DESCRIPTIONS.ios
            }
          }]
        }
      } : {}),

      // Jetpack Compose: Compact (sm), Medium (md), Expanded (lg) with Material 3 WindowSizeClass
      // Output to semantic/typography/ with sizeclass in filename
      ...(COMPOSE_ENABLED && isNativeBreakpoint(breakpoint, 'android') ? {
        compose: {
          transforms: ['attribute/cti', 'name/custom/compose'],
          buildPath: `${ANDROID_DIST_DIR}/brands/${brand}/semantic/typography/`,
          files: [{
            destination: `Typography${getSizeClassName(breakpoint, 'android').charAt(0).toUpperCase() + getSizeClassName(breakpoint, 'android').slice(1)}.kt`,
            format: 'compose/typography-scheme',
            options: {
              packageName: `com.bild.designsystem.brands.${brand}.semantic.typography`,
              brand: brandName,
              breakpoint,
              sizeClass: getSizeClassName(breakpoint, 'android'),
              platform: 'android',
              showDescriptions: SHOW_DESCRIPTIONS.android
            }
          }]
        }
      } : {})
    }
  };
}

/**
 * Creates Style Dictionary config for Effect tokens
 */
function createEffectConfig(brand, colorMode) {
  const sourceFile = path.join(TOKENS_DIR, 'brands', brand, 'semantic', 'effects', `effects-${colorMode}.json`);

  if (!fs.existsSync(sourceFile)) {
    return null;
  }

  const brandName = brand.charAt(0).toUpperCase() + brand.slice(1);
  const fileName = `effects-${colorMode}`;

  return {
    source: [sourceFile],
    platforms: {
      // CSS: Custom format for Effect classes
      css: {
        transforms: ['attribute/cti'],
        buildPath: `${DIST_DIR}/css/brands/${brand}/semantic/effects/`,
        files: [{
          destination: `${fileName}.css`,
          format: 'css/effect-classes',
          options: {
            brand: brandName,
            colorMode,
            showDescriptions: SHOW_DESCRIPTIONS.css
          }
        }]
      },

      // JSON: Standard JSON
      json: {
        transformGroup: 'js',
        buildPath: `${DIST_DIR}/json/brands/${brand}/semantic/effects/`,
        files: [{ destination: `${fileName}.json`, format: 'json', options: { outputReferences: false } }]
      },

      // iOS: SwiftUI Effects format (brand-prefixed)
      ios: {
        transformGroup: 'custom/ios-swift',
        buildPath: `${IOS_DIST_DIR}/brands/${brand}/semantic/effects/`,
        files: [{
          destination: `${brandName}${fileName.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('')}.swift`,
          format: 'swiftui/effects',
          options: {
            brand: brandName,
            colorMode,
            showDescriptions: SHOW_DESCRIPTIONS.ios
          }
        }]
      },

      // SCSS: Custom Effects format
      scss: {
        transforms: ['attribute/cti'],
        buildPath: `${DIST_DIR}/scss/brands/${brand}/semantic/effects/`,
        files: [{
          destination: `${fileName}.scss`,
          format: 'scss/effects',
          options: {
            brand: brandName,
            colorMode,
            showDescriptions: SHOW_DESCRIPTIONS.scss
          }
        }]
      },

      // Compose: Effects format (brand-independent, output to shared/)
      // Shadows only depend on light/dark mode, not on brand
      ...(COMPOSE_ENABLED ? {
        compose: {
          transforms: ['attribute/cti'],
          buildPath: `${ANDROID_DIST_DIR}/shared/`,
          files: [{
            destination: `Effects${colorMode === 'light' ? 'Light' : 'Dark'}.kt`,
            format: 'compose/effects',
            options: {
              colorMode,
              showDescriptions: SHOW_DESCRIPTIONS.android
            }
          }]
        }
      } : {})
    }
  };
}

/**
 * Creates Style Dictionary config for shared (brand-independent) density tokens
 * Similar pattern to Effects - density values are identical across all brands
 *
 * @param {string} densityMode - 'default', 'dense', or 'spacious'
 */
function createSharedDensityConfig(densityMode) {
  // Source: Use bild as reference (values identical across brands)
  const sourceFile = path.join(TOKENS_DIR, 'brands', 'bild', 'density', `density-${densityMode}.json`);

  if (!fs.existsSync(sourceFile)) {
    return null;
  }

  const modePascal = densityMode.charAt(0).toUpperCase() + densityMode.slice(1);

  return {
    source: [sourceFile],
    platforms: {
      // Android: Jetpack Compose (brand-independent, output to shared/)
      ...(COMPOSE_ENABLED ? {
        compose: {
          transformGroup: 'custom/compose',
          buildPath: `${ANDROID_DIST_DIR}/shared/`,
          files: [{
            destination: `Density${modePascal}.kt`,
            format: 'compose/shared-density',
            options: {
              packageName: 'com.bild.designsystem.shared',
              densityMode: modePascal,
              showDescriptions: SHOW_DESCRIPTIONS.android
            }
          }]
        }
      } : {}),

      // iOS: SwiftUI (brand-independent, output to shared/)
      ...(SWIFTUI_ENABLED ? {
        swiftui: {
          transformGroup: 'custom/ios-swift',
          buildPath: `${IOS_DIST_DIR}/shared/`,
          files: [{
            destination: `Density${modePascal}.swift`,
            format: 'swiftui/shared-density',
            options: {
              densityMode: modePascal,
              showDescriptions: SHOW_DESCRIPTIONS.ios
            }
          }]
        }
      } : {})
    }
  };
}

/**
 * Builds shared (brand-independent) density tokens
 * Similar to Effects - density values are identical across all brands
 * Output: dist/android/compose/shared/Density{Mode}.kt
 *         dist/ios/shared/Density{Mode}.swift
 */
async function buildSharedDensityTokens() {
  console.log('\nðŸŽ›ï¸  Building Shared Density Tokens:\n');

  const densityModes = ['default', 'dense', 'spacious'];
  let successful = 0;

  for (const mode of densityModes) {
    const config = createSharedDensityConfig(mode);

    if (!config) {
      console.warn(`     âš ï¸ Density config not found for mode: ${mode}`);
      continue;
    }

    try {
      const sd = new StyleDictionary(config);
      await sd.buildAllPlatforms();
      const modePascal = mode.charAt(0).toUpperCase() + mode.slice(1);
      console.log(`     âœ… Density${modePascal}`);
      successful++;
    } catch (error) {
      console.error(`     âŒ Density ${mode}: ${error.message}`);
    }
  }

  return { total: densityModes.length, successful };
}

/**
 * Builds Shared Primitive Tokens
 * Note: iOS/SwiftUI primitives are built separately via buildConsolidatedSwiftUIPrimitives()
 * to create a single consolidated DesignTokenPrimitives.swift file
 */
async function buildSharedPrimitives() {
  console.log('\nðŸ“¦ Building Shared Primitives:\n');

  const sharedDir = path.join(TOKENS_DIR, 'shared');
  if (!fs.existsSync(sharedDir)) {
    console.log('  âš ï¸  No shared/ directory found');
    return { total: 0, successful: 0 };
  }

  const files = fs.readdirSync(sharedDir).filter(f => f.endsWith('.json'));
  let successful = 0;

  for (const file of files) {
    const baseName = path.basename(file, '.json');
    const sourcePath = path.join(sharedDir, file);

    // Skip SwiftUI for individual primitives - they'll be consolidated later
    const config = {
      source: [sourcePath],
      platforms: createStandardPlatformConfig(`${DIST_DIR}/css/shared`, baseName, { skipSwiftUI: true })
    };

    try {
      const sd = new StyleDictionary(config);
      await sd.buildAllPlatforms();
      console.log(`  âœ… ${baseName}`);
      successful++;
    } catch (error) {
      console.error(`  âŒ ${baseName}: ${error.message}`);
    }
  }

  return { total: files.length, successful };
}

/**
 * Builds consolidated SwiftUI Primitives
 * Creates: dist/ios/shared/DesignTokenPrimitives.swift
 * Combines all primitive JSON files into a single Swift file with nested enums
 */
async function buildConsolidatedSwiftUIPrimitives() {
  if (!SWIFTUI_ENABLED) {
    return { total: 0, successful: 0 };
  }

  console.log('ðŸŽ Building Consolidated SwiftUI Primitives...');

  const sharedDir = path.join(TOKENS_DIR, 'shared');
  if (!fs.existsSync(sharedDir)) {
    console.log('  âš ï¸  No shared/ directory found');
    return { total: 0, successful: 0 };
  }

  // Combine all primitive JSON files
  const files = fs.readdirSync(sharedDir).filter(f => f.endsWith('.json'));
  const sourcePaths = files.map(f => path.join(sharedDir, f));

  const config = {
    source: sourcePaths,
    platforms: {
      swiftui: {
        transformGroup: 'custom/ios-swift',
        buildPath: `${IOS_DIST_DIR}/shared/`,
        files: [{
          destination: 'DesignTokenPrimitives.swift',
          format: 'swiftui/primitives',
          filter: (token) => {
            // Exclude TextLabels tokens
            if (token.path && token.path.includes('TextLabels')) {
              return false;
            }
            return true;
          },
          options: {
            outputReferences: false,
            showDescriptions: SHOW_DESCRIPTIONS.ios
          }
        }]
      }
    }
  };

  try {
    const sd = new StyleDictionary(config);
    await sd.buildAllPlatforms();
    console.log('     âœ… ios/shared/DesignTokenPrimitives.swift');
    return { total: 1, successful: 1 };
  } catch (error) {
    console.error(`  âŒ Consolidated SwiftUI Primitives: ${error.message}`);
    return { total: 1, successful: 0 };
  }
}

/**
 * Builds Brand-specific Token Collections
 */
async function buildBrandSpecificTokens() {
  console.log('\nðŸ·ï¸  Building Brand-specific Tokens:\n');

  let totalBuilds = 0;
  let successfulBuilds = 0;

  for (const brand of BRANDS) {
    console.log(`  ðŸ“¦ ${brand}:`);

    const brandDir = path.join(TOKENS_DIR, 'brands', brand);
    if (!fs.existsSync(brandDir)) continue;

    // Density
    const densityDir = path.join(brandDir, 'density');
    if (fs.existsSync(densityDir)) {
      const files = fs.readdirSync(densityDir).filter(f => f.endsWith('.json'));
      for (const file of files) {
        const fileName = path.basename(file, '.json');
        // Extract density mode from filename (e.g., "density-dense" -> "dense")
        const densityMatch = fileName.match(/density-(\w+)/);
        const densityMode = densityMatch ? densityMatch[1] : null;

        const config = {
          source: [path.join(densityDir, file)],
          platforms: createStandardPlatformConfig(
            `${DIST_DIR}/css/brands/${brand}/density`,
            fileName,
            {
              brand,
              mode: densityMode,
              modeType: 'density'
            }
          )
        };

        try {
          totalBuilds++;
          await new StyleDictionary(config).buildAllPlatforms();
          successfulBuilds++;
        } catch (error) {
          console.error(`     âŒ density/${fileName}: ${error.message}`);
        }
      }
      console.log(`     âœ… density (${files.length} modes)`);
    }

    // Breakpoints
    const breakpointsDir = path.join(brandDir, 'breakpoints');
    if (fs.existsSync(breakpointsDir)) {
      const files = fs.readdirSync(breakpointsDir).filter(f => f.endsWith('.json'));
      for (const file of files) {
        const fileName = path.basename(file, '.json');
        // Extract breakpoint from filename (e.g., "breakpoint-lg" -> "lg")
        const breakpointMatch = fileName.match(/breakpoint-(\w+)/);
        const breakpointMode = breakpointMatch ? breakpointMatch[1] : null;

        const config = {
          source: [path.join(breakpointsDir, file)],
          platforms: createStandardPlatformConfig(
            `${DIST_DIR}/css/brands/${brand}/semantic/breakpoints`,
            fileName,
            {
              brand,
              mode: breakpointMode,
              modeType: 'breakpoint'
            }
          )
        };

        try {
          totalBuilds++;
          await new StyleDictionary(config).buildAllPlatforms();
          successfulBuilds++;
        } catch (error) {
          console.error(`     âŒ breakpoints/${fileName}: ${error.message}`);
        }
      }
      console.log(`     âœ… breakpoints (${files.length} modes)`);
    }

    // Color
    const colorDir = path.join(brandDir, 'color');
    if (fs.existsSync(colorDir)) {
      const files = fs.readdirSync(colorDir).filter(f => f.endsWith('.json'));
      for (const file of files) {
        const fileName = path.basename(file, '.json');
        // Extract color mode from filename (e.g., "colormode-light" -> "light")
        const colorModeMatch = fileName.match(/colormode-(\w+)/);
        const colorMode = colorModeMatch ? colorModeMatch[1] : null;

        const config = {
          source: [path.join(colorDir, file)],
          platforms: createStandardPlatformConfig(
            `${DIST_DIR}/css/brands/${brand}/semantic/color`,
            fileName,
            {
              brand,
              mode: colorMode,
              modeType: 'theme'
            }
          )
        };

        try {
          totalBuilds++;
          await new StyleDictionary(config).buildAllPlatforms();
          successfulBuilds++;
        } catch (error) {
          console.error(`     âŒ color/${fileName}: ${error.message}`);
        }
      }
      console.log(`     âœ… color (${files.length} modes)`);
    }

    // Overrides (Brand Mapping Layer) - DISABLED
    // These intermediate tokens are NOT needed in the output because:
    // 1. Semantic/Component tokens already contain resolved brand-specific values
    // 2. CSS references primitives directly (var(--bildred)), not brand mapping (--core-color-primary)
    // 3. No other tokens reference the brand mapping layer for alias resolution
    // 4. The values are redundant copies of what's already in primitives + semantic tokens
    //
    // If you need to re-enable for debugging/documentation purposes, uncomment below:
    /*
    const overridesDir = path.join(brandDir, 'overrides');
    if (fs.existsSync(overridesDir)) {
      const files = fs.readdirSync(overridesDir).filter(f => f.endsWith('.json'));
      for (const file of files) {
        const fileName = path.basename(file, '.json');
        const config = {
          source: [path.join(overridesDir, file)],
          platforms: createStandardPlatformConfig(`${DIST_DIR}/css/brands/${brand}/overrides`, fileName)
        };

        try {
          totalBuilds++;
          await new StyleDictionary(config).buildAllPlatforms();
          successfulBuilds++;
        } catch (error) {
          console.error(`     âŒ overrides/${fileName}: ${error.message}`);
        }
      }
      console.log(`     âœ… overrides (${files.length} collections)`);
    }
    */
  }

  return { totalBuilds, successfulBuilds };
}

/**
 * Creates platform config for component typography tokens
 */
function createComponentTypographyConfig(sourceFile, brand, componentName, fileName) {
  const brandName = brand.charAt(0).toUpperCase() + brand.slice(1);
  // Extract breakpoint from fileName (e.g., "button-typography-lg" -> "lg")
  const breakpointMatch = fileName.match(/typography-(\w+)$/);
  const breakpoint = breakpointMatch ? breakpointMatch[1] : null;

  return {
    source: [sourceFile],
    platforms: {
      css: {
        transforms: ['attribute/cti'],
        buildPath: `${DIST_DIR}/css/brands/${brand}/components/${componentName}/`,
        files: [{
          destination: `${fileName}.css`,
          format: 'css/typography-classes',
          options: {
            brand: brandName,
            breakpoint: breakpoint || 'default',
            componentName,
            showDescriptions: SHOW_DESCRIPTIONS.css
          }
        }]
      },
      scss: {
        transforms: ['attribute/cti'],
        buildPath: `${DIST_DIR}/scss/brands/${brand}/components/${componentName}/`,
        files: [{
          destination: `${fileName}.scss`,
          format: 'scss/typography',
          options: {
            brand: brandName,
            breakpoint: breakpoint || 'default',
            componentName,
            showDescriptions: SHOW_DESCRIPTIONS.scss
          }
        }]
      },
      json: {
        transformGroup: 'js',
        buildPath: `${DIST_DIR}/json/brands/${brand}/components/${componentName}/`,
        files: [{ destination: `${fileName}.json`, format: 'json', options: { outputReferences: false } }]
      },
      // iOS: Only compact (sm) and regular (lg) with SwiftUI typography format
      ...(breakpoint && isNativeBreakpoint(breakpoint) ? {
        ios: {
          transformGroup: 'custom/ios-swift',
          buildPath: `${IOS_DIST_DIR}/brands/${brand}/components/${componentName}/`,
          files: [{
            destination: `${componentName}TypographySizing${getSizeClassName(breakpoint).charAt(0).toUpperCase() + getSizeClassName(breakpoint).slice(1)}.swift`,
            format: 'swiftui/typography',
            options: {
              brand: brandName,
              breakpoint,
              componentName,
              sizeClass: getSizeClassName(breakpoint),
              showDescriptions: SHOW_DESCRIPTIONS.ios
            }
          }]
        }
      } : {}),
      // Compose: Compact (sm), Medium (md), and Expanded (lg) with Material 3 WindowSizeClass naming
      ...(COMPOSE_ENABLED && breakpoint && isNativeBreakpoint(breakpoint, 'android') ? {
        compose: {
          transforms: ['attribute/cti'],
          buildPath: `${ANDROID_DIST_DIR}/brands/${brand}/components/${componentName.toLowerCase()}/`,
          files: [{
            destination: `${componentName}Typography${getSizeClassName(breakpoint, 'android').charAt(0).toUpperCase() + getSizeClassName(breakpoint, 'android').slice(1)}.kt`,
            format: 'compose/typography',
            options: {
              packageName: `com.bild.designsystem.brands.${brand}.components.${componentName.toLowerCase()}`,
              brand: brand,
              mode: getSizeClassName(breakpoint, 'android'),
              componentName,
              platform: 'android',
              showDescriptions: SHOW_DESCRIPTIONS.android
            }
          }]
        }
      } : {})
    }
  };
}

/**
 * Creates platform config for component effects tokens
 */
function createComponentEffectsConfig(sourceFile, brand, componentName, fileName) {
  const brandName = brand.charAt(0).toUpperCase() + brand.slice(1);
  // Extract colorMode from fileName (e.g., "alert-effects-light" -> "light")
  const colorModeMatch = fileName.match(/effects-(\w+)$/);
  const colorMode = colorModeMatch ? colorModeMatch[1] : null;

  return {
    source: [sourceFile],
    platforms: {
      css: {
        transforms: ['attribute/cti'],
        buildPath: `${DIST_DIR}/css/brands/${brand}/components/${componentName}/`,
        files: [{
          destination: `${fileName}.css`,
          format: 'css/effect-classes',
          options: {
            brand: brandName,
            colorMode: colorMode || 'default',
            componentName,
            showDescriptions: SHOW_DESCRIPTIONS.css
          }
        }]
      },
      scss: {
        transforms: ['attribute/cti'],
        buildPath: `${DIST_DIR}/scss/brands/${brand}/components/${componentName}/`,
        files: [{
          destination: `${fileName}.scss`,
          format: 'scss/effects',
          options: {
            brand: brandName,
            colorMode: colorMode || 'default',
            componentName,
            showDescriptions: SHOW_DESCRIPTIONS.scss
          }
        }]
      },
      json: {
        transformGroup: 'js',
        buildPath: `${DIST_DIR}/json/brands/${brand}/components/${componentName}/`,
        files: [{ destination: `${fileName}.json`, format: 'json', options: { outputReferences: false } }]
      },
      ios: {
        transformGroup: 'custom/ios-swift',
        buildPath: `${IOS_DIST_DIR}/brands/${brand}/components/${componentName}/`,
        files: [{
          destination: `${componentName}Effects${colorMode ? colorMode.charAt(0).toUpperCase() + colorMode.slice(1) : ''}.swift`,
          format: 'swiftui/effects',
          options: {
            brand: brandName,
            colorMode,
            componentName,
            mode: colorMode,
            showDescriptions: SHOW_DESCRIPTIONS.ios
          }
        }]
      },
      // Compose: Component Effects format
      ...(COMPOSE_ENABLED ? {
        compose: {
          transforms: ['attribute/cti'],
          buildPath: `${ANDROID_DIST_DIR}/brands/${brand}/components/${componentName.toLowerCase()}/`,
          files: [{
            destination: `${componentName}Effects${colorMode ? colorMode.charAt(0).toUpperCase() + colorMode.slice(1) : ''}.kt`,
            format: 'compose/component-effects',
            options: {
              brand: brandName,
              colorMode,
              componentName,
              showDescriptions: SHOW_DESCRIPTIONS.android
            }
          }]
        }
      } : {})
    }
  };
}

/**
 * Builds Component Tokens
 * Components are organized in brands/{brand}/components/{Component}/
 */
async function buildComponentTokens() {
  console.log('\nðŸ§© Building Component Tokens:\n');

  let totalBuilds = 0;
  let successfulBuilds = 0;

  for (const brand of BRANDS) {
    console.log(`  ðŸ·ï¸  ${brand}:`);

    const componentsDir = path.join(TOKENS_DIR, 'brands', brand, 'components');
    if (!fs.existsSync(componentsDir)) {
      console.log(`     âš ï¸  No components directory found`);
      continue;
    }

    const componentNames = fs.readdirSync(componentsDir).filter(name => {
      const componentPath = path.join(componentsDir, name);
      // Skip hidden and internal directories (., _)
      if (name.startsWith('.') || name.startsWith('_')) return false;
      return fs.statSync(componentPath).isDirectory();
    });

    for (const componentName of componentNames) {
      const componentDir = path.join(componentsDir, componentName);
      const files = fs.readdirSync(componentDir).filter(f => f.endsWith('.json'));

      let componentSuccessful = 0;

      for (const file of files) {
        const fileName = path.basename(file, '.json');
        const sourcePath = path.join(componentDir, file);

        // Determine config based on file type
        let config;
        if (fileName.includes('typography-')) {
          config = createComponentTypographyConfig(sourcePath, brand, componentName, fileName);
        } else if (fileName.includes('effects-')) {
          config = createComponentEffectsConfig(sourcePath, brand, componentName, fileName);
        } else {
          // Standard token config for color, density, breakpoint tokens
          // Extract mode and modeType from filename
          let cssOptions = { brand };

          // Check for color mode (e.g., "alert-color-light" -> mode: "light", modeType: "theme")
          const colorModeMatch = fileName.match(/color-(\w+)/);
          if (colorModeMatch) {
            cssOptions.mode = colorModeMatch[1];
            cssOptions.modeType = 'theme';
          }

          // Check for density mode (e.g., "button-density-dense" -> mode: "dense", modeType: "density")
          const densityMatch = fileName.match(/density-(\w+)/);
          if (densityMatch) {
            cssOptions.mode = densityMatch[1];
            cssOptions.modeType = 'density';
          }

          // Check for breakpoint mode (e.g., "audioplayer-breakpoint-lg-1024px-regular" -> mode: "lg", modeType: "breakpoint")
          const breakpointMatch = fileName.match(/breakpoint-(\w+)/);
          if (breakpointMatch) {
            cssOptions.mode = breakpointMatch[1];
            cssOptions.modeType = 'breakpoint';
          }

          config = {
            source: [sourcePath],
            platforms: createStandardPlatformConfig(
              `${DIST_DIR}/css/brands/${brand}/components/${componentName}`,
              fileName,
              cssOptions
            )
          };
        }

        try {
          totalBuilds++;
          await new StyleDictionary(config).buildAllPlatforms();
          successfulBuilds++;
          componentSuccessful++;
        } catch (error) {
          console.error(`     âŒ ${componentName}/${fileName}: ${error.message}`);
        }
      }

      if (componentSuccessful > 0) {
        console.log(`     âœ… ${componentName} (${componentSuccessful}/${files.length} files)`);
      }
    }
  }

  return { totalBuilds, successfulBuilds };
}

/**
 * Optimizes Component Color CSS by consolidating mode files
 *
 * When ALL tokens in a component's color files reference the SAME semantic tokens
 * in both light and dark modes, we can consolidate them into a single mode-agnostic file.
 *
 * This optimization:
 * 1. Checks if all tokens are semantic references
 * 2. Checks if semantic token names are identical between light and dark
 * 3. If yes: Creates a single file with [data-color-brand] selector (no data-theme)
 * 4. Deletes the redundant mode-specific files
 *
 * This only affects CSS output - native platforms (iOS/Android) are not modified.
 */
async function optimizeComponentColorCSS() {
  console.log('\nðŸŽ¯ Optimizing Component Color CSS (Token-Level Split):\n');

  let fullyOptimizedCount = 0;
  let partiallyOptimizedCount = 0;
  let skippedCount = 0;

  /**
   * Recursively extracts all tokens with their $alias info from nested structure
   */
  function extractAllTokens(obj, tokens = []) {
    for (const key of Object.keys(obj)) {
      const value = obj[key];
      if (value && typeof value === 'object') {
        // Check if this is a token (has $value and $alias)
        if (value.$value !== undefined && value.$alias) {
          tokens.push({
            name: key,
            alias: value.$alias
          });
        } else {
          // Recurse into nested objects
          extractAllTokens(value, tokens);
        }
      }
    }
    return tokens;
  }

  /**
   * Convert camelCase token name to kebab-case CSS variable name
   */
  function tokenNameToCssVar(tokenName) {
    return '--' + tokenName
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')
      .toLowerCase();
  }

  /**
   * Categorize tokens into optimizable (identical semantic refs) and mode-specific
   */
  function categorizeTokens(lightTokens, darkTokens) {
    const lightMap = new Map(lightTokens.map(t => [t.name, t.alias]));
    const darkMap = new Map(darkTokens.map(t => [t.name, t.alias]));

    const optimizable = [];  // Can be mode-agnostic
    const modeSpecific = []; // Must stay in light/dark files

    for (const [name, lightAlias] of lightMap) {
      const darkAlias = darkMap.get(name);

      // Check if this token can be optimized
      const canOptimize = darkAlias &&
        lightAlias.collectionType === 'semantic' &&
        darkAlias.collectionType === 'semantic' &&
        lightAlias.token === darkAlias.token;

      if (canOptimize) {
        optimizable.push(name);
      } else {
        modeSpecific.push(name);
      }
    }

    return { optimizable, modeSpecific };
  }

  /**
   * Parse CSS file and extract variable declarations
   * Returns: { header, variables: Map<cssVarName, fullLine> }
   */
  function parseCssFile(cssContent) {
    const headerMatch = cssContent.match(/^\/\*\*[\s\S]*?\*\//);
    const header = headerMatch ? headerMatch[0] : '';

    // Extract all CSS variable declarations
    const variables = new Map();
    const varRegex = /(--[a-z0-9-]+):\s*([^;]+);/gi;
    let match;
    while ((match = varRegex.exec(cssContent)) !== null) {
      variables.set(match[1], `  ${match[1]}: ${match[2]};`);
    }

    return { header, variables };
  }

  /**
   * Generate CSS file content from variables
   */
  function generateCssContent(header, selector, variables, context) {
    const updatedHeader = header.replace(
      /Context: theme: \w+/,
      `Context: ${context}`
    );

    let output = updatedHeader + '\n\n';
    output += `${selector} {\n`;
    for (const varLine of variables) {
      output += varLine + '\n';
    }
    output += '}\n';

    return output;
  }

  for (const brand of BRANDS) {
    const componentsDir = path.join(TOKENS_DIR, 'brands', brand, 'components');
    const cssComponentsDir = path.join(DIST_DIR, 'css', 'brands', brand, 'components');

    if (!fs.existsSync(componentsDir)) continue;

    const componentNames = fs.readdirSync(componentsDir).filter(name => {
      // Skip hidden and internal directories (., _)
      if (name.startsWith('.') || name.startsWith('_')) return false;
      return fs.statSync(path.join(componentsDir, name)).isDirectory();
    });

    for (const componentName of componentNames) {
      const componentDir = path.join(componentsDir, componentName);
      const cssDir = path.join(cssComponentsDir, componentName);

      // Find color token files
      const lightTokenFile = path.join(componentDir, `${componentName.toLowerCase()}-color-light.json`);
      const darkTokenFile = path.join(componentDir, `${componentName.toLowerCase()}-color-dark.json`);

      // Both files must exist
      if (!fs.existsSync(lightTokenFile) || !fs.existsSync(darkTokenFile)) {
        continue;
      }

      // Load and parse token files
      let lightData, darkData;
      try {
        lightData = JSON.parse(fs.readFileSync(lightTokenFile, 'utf8'));
        darkData = JSON.parse(fs.readFileSync(darkTokenFile, 'utf8'));
      } catch (e) {
        console.log(`     âš ï¸  ${componentName}: Error reading token files`);
        continue;
      }

      // Extract all tokens
      const lightTokens = extractAllTokens(lightData);
      const darkTokens = extractAllTokens(darkData);

      // Categorize tokens
      const { optimizable, modeSpecific } = categorizeTokens(lightTokens, darkTokens);

      // If no tokens can be optimized, skip
      if (optimizable.length === 0) {
        skippedCount++;
        continue;
      }

      // CSS file paths
      const cssLightFile = path.join(cssDir, `${componentName.toLowerCase()}-color-light.css`);
      const cssDarkFile = path.join(cssDir, `${componentName.toLowerCase()}-color-dark.css`);
      const cssOptimizedFile = path.join(cssDir, `${componentName.toLowerCase()}-color.css`);

      if (!fs.existsSync(cssLightFile) || !fs.existsSync(cssDarkFile)) {
        continue;
      }

      try {
        // Parse CSS files
        const lightCss = parseCssFile(fs.readFileSync(cssLightFile, 'utf8'));
        const darkCss = parseCssFile(fs.readFileSync(cssDarkFile, 'utf8'));

        // Convert token names to CSS variable names
        const optimizableCssVars = new Set(optimizable.map(tokenNameToCssVar));
        const modeSpecificCssVars = new Set(modeSpecific.map(tokenNameToCssVar));

        // Split variables
        const optimizedVars = [];
        const lightOnlyVars = [];
        const darkOnlyVars = [];

        for (const [cssVar, varLine] of lightCss.variables) {
          if (optimizableCssVars.has(cssVar)) {
            // Remove fallback from semantic reference
            const cleanedLine = varLine.replace(/var\((--[a-z-]+),\s*[^)]+\)/gi, 'var($1)');
            optimizedVars.push(cleanedLine);
          } else {
            lightOnlyVars.push(varLine);
          }
        }

        for (const [cssVar, varLine] of darkCss.variables) {
          if (!optimizableCssVars.has(cssVar)) {
            darkOnlyVars.push(varLine);
          }
        }

        // Write output files (Dual-Axis: Color tokens use data-color-brand)
        // Uses dual selectors for Shadow DOM compatibility
        if (optimizedVars.length > 0) {
          const colorSelector = buildDualSelector(`[data-color-brand="${brand}"]`);
          const optimizedContent = generateCssContent(
            lightCss.header,
            colorSelector,
            optimizedVars,
            'Color (Mode-agnostic)'
          );
          fs.writeFileSync(cssOptimizedFile, optimizedContent);
        }

        if (modeSpecific.length === 0) {
          // All tokens optimized - delete original files
          fs.unlinkSync(cssLightFile);
          fs.unlinkSync(cssDarkFile);
          fullyOptimizedCount++;
          console.log(`     âœ… ${brand}/${componentName}: Fully consolidated to mode-agnostic file`);
        } else {
          // Partial optimization - update light/dark files with remaining tokens
          // Uses dual selectors for Shadow DOM compatibility
          if (lightOnlyVars.length > 0) {
            const lightSelector = buildDualSelector(`[data-color-brand="${brand}"][data-theme="light"]`);
            const lightContent = generateCssContent(
              lightCss.header,
              lightSelector,
              lightOnlyVars,
              'theme: light'
            );
            fs.writeFileSync(cssLightFile, lightContent);
          } else {
            fs.unlinkSync(cssLightFile);
          }

          if (darkOnlyVars.length > 0) {
            const darkSelector = buildDualSelector(`[data-color-brand="${brand}"][data-theme="dark"]`);
            const darkContent = generateCssContent(
              darkCss.header,
              darkSelector,
              darkOnlyVars,
              'theme: dark'
            );
            fs.writeFileSync(cssDarkFile, darkContent);
          } else {
            fs.unlinkSync(cssDarkFile);
          }

          partiallyOptimizedCount++;
          console.log(`     ðŸ”€ ${brand}/${componentName}: Split - ${optimizable.length} mode-agnostic, ${modeSpecific.length} mode-specific`);
        }

      } catch (e) {
        console.log(`     âŒ ${componentName}: Error optimizing CSS - ${e.message}`);
      }
    }
  }

  console.log(`\n   ðŸ“Š Summary:`);
  console.log(`      - ${fullyOptimizedCount} components fully optimized (all tokens mode-agnostic)`);
  console.log(`      - ${partiallyOptimizedCount} components partially optimized (token-level split)`);
  console.log(`      - ${skippedCount} components skipped (no semantic refs)`);

  return { fullyOptimizedCount, partiallyOptimizedCount, skippedCount };
}

/**
 * Optimizes Component Effects CSS by consolidating identical light/dark effects
 *
 * Effects (box-shadow) are often identical between light and dark modes.
 * This function compares effects-light.css and effects-dark.css files,
 * and if all effects are identical, consolidates them to a single mode-agnostic file.
 */
async function optimizeComponentEffectsCSS() {
  console.log('\nâœ¨ Optimizing Component Effects CSS:\n');

  let optimizedCount = 0;
  let skippedCount = 0;

  /**
   * Parse effects CSS file and extract class rules
   * Returns: Map<className, ruleContent>
   */
  function parseEffectsCssFile(cssContent) {
    const rules = new Map();

    // Match: [data-color-brand="..."][data-theme="..."] .class-name { ... } (Dual-Axis)
    const ruleRegex = /\[data-color-brand="[^"]+"\]\[data-theme="[^"]+"\]\s+\.([a-z0-9-]+)\s*\{([^}]+)\}/gi;
    let match;

    while ((match = ruleRegex.exec(cssContent)) !== null) {
      const className = match[1];
      const ruleContent = match[2].trim();
      rules.set(className, ruleContent);
    }

    return rules;
  }

  /**
   * Check if all rules are identical between light and dark
   */
  function areEffectsIdentical(lightRules, darkRules) {
    if (lightRules.size !== darkRules.size) {
      return false;
    }

    for (const [className, lightContent] of lightRules) {
      const darkContent = darkRules.get(className);
      if (!darkContent || lightContent !== darkContent) {
        return false;
      }
    }

    return true;
  }

  /**
   * Generate mode-agnostic effects CSS
   * Uses dual selectors for Shadow DOM compatibility
   */
  function generateModeAgnosticCss(header, brand, rules) {
    const updatedHeader = header.replace(
      /Context: Mode: \w+/,
      'Context: Effects (Mode-agnostic)'
    );

    let output = updatedHeader + '\n\n';

    for (const [className, ruleContent] of rules) {
      const dualSelector = buildDualSelector(`[data-color-brand="${brand}"]`, `.${className}`);
      output += `${dualSelector} {\n`;
      output += `  ${ruleContent}\n`;
      output += `}\n\n`;
    }

    return output;
  }

  for (const brand of BRANDS) {
    const cssComponentsDir = path.join(DIST_DIR, 'css', 'brands', brand, 'components');

    if (!fs.existsSync(cssComponentsDir)) continue;

    const componentNames = fs.readdirSync(cssComponentsDir).filter(name => {
      const componentPath = path.join(cssComponentsDir, name);
      return fs.statSync(componentPath).isDirectory();
    });

    for (const componentName of componentNames) {
      const cssDir = path.join(cssComponentsDir, componentName);

      // Find effects CSS files
      const lightFile = path.join(cssDir, `${componentName.toLowerCase()}-effects-light.css`);
      const darkFile = path.join(cssDir, `${componentName.toLowerCase()}-effects-dark.css`);
      const optimizedFile = path.join(cssDir, `${componentName.toLowerCase()}-effects.css`);

      // Both files must exist
      if (!fs.existsSync(lightFile) || !fs.existsSync(darkFile)) {
        continue;
      }

      try {
        // Read CSS files
        const lightCss = fs.readFileSync(lightFile, 'utf8');
        const darkCss = fs.readFileSync(darkFile, 'utf8');

        // Parse rules
        const lightRules = parseEffectsCssFile(lightCss);
        const darkRules = parseEffectsCssFile(darkCss);

        // Check if identical
        if (!areEffectsIdentical(lightRules, darkRules)) {
          skippedCount++;
          continue;
        }

        // Extract header from light file
        const headerMatch = lightCss.match(/^\/\*\*[\s\S]*?\*\//);
        const header = headerMatch ? headerMatch[0] : '';

        // Generate optimized CSS
        const optimizedCss = generateModeAgnosticCss(header, brand, lightRules);

        // Write optimized file
        fs.writeFileSync(optimizedFile, optimizedCss);

        // Delete original files
        fs.unlinkSync(lightFile);
        fs.unlinkSync(darkFile);

        optimizedCount++;
        console.log(`     âœ… ${brand}/${componentName}: Consolidated to mode-agnostic effects`);

      } catch (e) {
        console.log(`     âŒ ${componentName}: Error optimizing effects - ${e.message}`);
      }
    }
  }

  console.log(`\n   ðŸ“Š Summary: ${optimizedCount} components optimized, ${skippedCount} skipped (different effects)`);

  return { optimizedCount, skippedCount };
}

/**
 * Builds Typography Tokens (brand-specific)
 */
async function buildTypographyTokens() {
  console.log('\nâœï¸  Building Typography Tokens:\n');

  let totalBuilds = 0;
  let successfulBuilds = 0;

  for (const brand of BRANDS) {
    console.log(`  ðŸ·ï¸  ${brand}:`);

    for (const breakpoint of BREAKPOINTS) {
      const config = createTypographyConfig(brand, breakpoint);

      if (!config) {
        console.log(`     âš ï¸  No data for ${brand}-${breakpoint}`);
        continue;
      }

      try {
        totalBuilds++;
        const sd = new StyleDictionary(config);
        await sd.buildAllPlatforms();
        successfulBuilds++;

        const platforms = Object.keys(config.platforms).join(', ');
        console.log(`     âœ… ${brand}-${breakpoint} (${platforms})`);
      } catch (error) {
        console.error(`     âŒ Fehler bei ${brand}-${breakpoint}:`);
        console.error(`        ${error.message}`);
      }
    }
  }

  return { totalBuilds, successfulBuilds };
}

/**
 * Builds Effect Tokens
 */
async function buildEffectTokens() {
  console.log('\nðŸŽ¨ Building Effect Tokens:\n');

  let totalBuilds = 0;
  let successfulBuilds = 0;

  for (const brand of BRANDS) {
    console.log(`  ðŸ·ï¸  Brand: ${brand}`);

    for (const colorMode of COLOR_MODES) {
      const config = createEffectConfig(brand, colorMode);

      if (!config) {
        console.log(`     âš ï¸  No data for ${brand}-${colorMode}`);
        continue;
      }

      try {
        totalBuilds++;
        const sd = new StyleDictionary(config);
        await sd.buildAllPlatforms();
        successfulBuilds++;

        console.log(`     âœ… ${brand}-${colorMode}`);
      } catch (error) {
        console.error(`     âŒ Fehler bei ${brand}-${colorMode}:`);
        console.error(`        ${error.message}`);
      }
    }
  }

  return { totalBuilds, successfulBuilds };
}

/**
 * Converts breakpoint-based typography files to responsive CSS with media queries
 */
async function convertToResponsiveCSS() {
  console.log('\nðŸ“± Converting to Responsive CSS with Media Queries:\n');

  const breakpointConfig = {
    xs: null,           // base, no media query
    sm: '390px',
    md: '600px',
    lg: '1024px'
  };

  let totalConversions = 0;
  let successfulConversions = 0;

  // Only process CSS files
  const cssDir = path.join(DIST_DIR, 'css', 'brands');

  for (const brand of BRANDS) {
    const brandDir = path.join(cssDir, brand);
    if (!fs.existsSync(brandDir)) continue;

    console.log(`  ðŸ·ï¸  ${brand}:`);

    // Process semantic typography
    const semanticTypographyDir = path.join(brandDir, 'semantic', 'typography');
    if (fs.existsSync(semanticTypographyDir)) {
      const semanticFiles = fs.readdirSync(semanticTypographyDir)
        .filter(f => f.endsWith('-xs.css'));

      for (const baseFile of semanticFiles) {
        const baseName = baseFile.replace('-xs.css', '');
        totalConversions++;

        try {
          // Typography uses var() references that respond to breakpoints automatically,
          // so skip media queries to avoid redundant class definitions
          const responsiveContent = await generateResponsiveFile(
            semanticTypographyDir,
            baseName,
            brand,
            breakpointConfig,
            { skipMediaQueries: true }
          );

          const outputPath = path.join(semanticTypographyDir, `${baseName}-responsive.css`);
          fs.writeFileSync(outputPath, responsiveContent, 'utf-8');
          successfulConversions++;
          console.log(`     âœ… semantic/${baseName}-responsive.css`);

          // Cleanup: Remove individual breakpoint files (redundant for CSS)
          for (const bp of BREAKPOINTS) {
            const bpFile = path.join(semanticTypographyDir, `${baseName}-${bp}.css`);
            if (fs.existsSync(bpFile)) {
              fs.unlinkSync(bpFile);
            }
          }
        } catch (error) {
          console.error(`     âŒ Error: semantic/${baseName} - ${error.message}`);
        }
      }
    }

    // Process semantic breakpoints
    const semanticBreakpointsDir = path.join(brandDir, 'semantic', 'breakpoints');
    if (fs.existsSync(semanticBreakpointsDir)) {
      const breakpointFiles = fs.readdirSync(semanticBreakpointsDir)
        .filter(f => f.includes('-xs-') && f.endsWith('.css'));

      for (const baseFile of breakpointFiles) {
        totalConversions++;

        try {
          const responsiveContent = await generateResponsiveBreakpointFile(
            semanticBreakpointsDir,
            brand,
            breakpointConfig
          );

          const outputPath = path.join(semanticBreakpointsDir, 'breakpoint-responsive.css');
          fs.writeFileSync(outputPath, responsiveContent, 'utf-8');
          successfulConversions++;
          console.log(`     âœ… semantic/breakpoint-responsive.css`);

          // Cleanup: Remove individual data-attribute breakpoint files (replaced by responsive file)
          const allBpFiles = fs.readdirSync(semanticBreakpointsDir)
            .filter(f => f.endsWith('.css') && f !== 'breakpoint-responsive.css');
          for (const bpFile of allBpFiles) {
            const filePath = path.join(semanticBreakpointsDir, bpFile);
            if (fs.existsSync(filePath)) {
              fs.unlinkSync(filePath);
            }
          }

          break; // Only generate once per brand
        } catch (error) {
          console.error(`     âŒ Error: semantic/breakpoints - ${error.message}`);
          break;
        }
      }
    }

    // Process component typography
    const componentsDir = path.join(brandDir, 'components');
    if (fs.existsSync(componentsDir)) {
      const componentFolders = fs.readdirSync(componentsDir)
        .filter(f => fs.statSync(path.join(componentsDir, f)).isDirectory())
        .filter(f => !f.startsWith('.') && !f.startsWith('_'));

      for (const component of componentFolders) {
        const componentDir = path.join(componentsDir, component);
        const typographyFiles = fs.readdirSync(componentDir)
          .filter(f => f.endsWith('-xs.css') && f.includes('typography'));

        for (const baseFile of typographyFiles) {
          const baseName = baseFile.replace('-xs.css', '');
          totalConversions++;

          try {
            // Typography uses var() references that respond to breakpoints automatically,
            // so skip media queries to avoid redundant class definitions
            const responsiveContent = await generateResponsiveFile(
              componentDir,
              baseName,
              brand,
              breakpointConfig,
              { skipMediaQueries: true }
            );

            const outputPath = path.join(componentDir, `${baseName}-responsive.css`);
            fs.writeFileSync(outputPath, responsiveContent, 'utf-8');
            successfulConversions++;
            console.log(`     âœ… ${component}/${baseName}-responsive.css`);

            // Cleanup: Remove individual breakpoint files (redundant for CSS)
            for (const bp of BREAKPOINTS) {
              const bpFile = path.join(componentDir, `${baseName}-${bp}.css`);
              if (fs.existsSync(bpFile)) {
                fs.unlinkSync(bpFile);
              }
            }
          } catch (error) {
            console.error(`     âŒ Error: ${component}/${baseName} - ${error.message}`);
          }
        }

        // Process component breakpoint tokens (non-typography, non-effects)
        // Convert data-breakpoint selectors to @media queries
        const breakpointFiles = fs.readdirSync(componentDir)
          .filter(f => f.endsWith('.css') && f.includes('-breakpoint-') && !f.includes('responsive'));

        if (breakpointFiles.length > 0) {
          totalConversions++;

          try {
            const responsiveContent = await generateComponentBreakpointResponsive(
              componentDir,
              component.toLowerCase(),
              brand,
              breakpointConfig
            );

            const outputPath = path.join(componentDir, `${component.toLowerCase()}-breakpoint-responsive.css`);
            fs.writeFileSync(outputPath, responsiveContent, 'utf-8');
            successfulConversions++;
            console.log(`     âœ… ${component}/${component.toLowerCase()}-breakpoint-responsive.css`);

            // Cleanup: Remove individual breakpoint files (redundant for CSS)
            for (const bpFile of breakpointFiles) {
              const filePath = path.join(componentDir, bpFile);
              if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
              }
            }
          } catch (error) {
            console.error(`     âŒ Error: ${component}/breakpoints - ${error.message}`);
          }
        }
      }
    }
  }

  return { totalConversions, successfulConversions };
}

/**
 * Generates a responsive CSS file with media queries from breakpoint files
 * For Typography: Only output base styles (XS) since var() references handle responsiveness
 */
async function generateResponsiveFile(dir, baseName, brand, breakpointConfig, options = {}) {
  const { skipMediaQueries = false } = options;
  const breakpointFiles = {};

  // Read all breakpoint files
  for (const bp of BREAKPOINTS) {
    const filePath = path.join(dir, `${baseName}-${bp}.css`);
    if (fs.existsSync(filePath)) {
      breakpointFiles[bp] = fs.readFileSync(filePath, 'utf-8');
    }
  }

  if (Object.keys(breakpointFiles).length === 0) {
    throw new Error('No breakpoint files found');
  }

  // Extract header from first file
  const firstFile = breakpointFiles.xs || breakpointFiles.sm || breakpointFiles.md || breakpointFiles.lg;
  const headerMatch = firstFile.match(/^\/\*\*[\s\S]*?\*\//);
  const header = headerMatch ? headerMatch[0].replace(/Breakpoint: \w+/, 'Responsive (Media Queries)') : '';

  let output = header + '\n\n';

  // Extract CSS classes from each breakpoint
  const breakpointClasses = {};
  for (const [bp, content] of Object.entries(breakpointFiles)) {
    const classes = extractClasses(content, brand, bp);
    breakpointClasses[bp] = classes;
  }

  // Generate responsive CSS with media queries (Dual-Axis: Typography uses ContentBrand)
  // Uses dual selectors for Shadow DOM compatibility (flat, non-nested for browser compatibility)
  const attrSelector = `[data-content-brand="${brand}"]`;

  // Base styles (XS) - use flat dual selectors (no CSS nesting)
  if (breakpointClasses.xs && breakpointClasses.xs.length > 0) {
    for (const cls of breakpointClasses.xs) {
      // Generate dual selector: [attr] .class, :host([attr]) .class
      output += `${attrSelector} .${cls.name},\n:host(${attrSelector}) .${cls.name} {\n`;
      for (const prop of cls.properties) {
        output += `  ${prop}\n`;
      }
      output += `}\n\n`;
    }
  }

  // Media queries for SM, MD, LG - skip if using var() references (Typography)
  if (!skipMediaQueries) {
    for (const bp of ['sm', 'md', 'lg']) {
      if (breakpointClasses[bp] && breakpointClasses[bp].length > 0 && breakpointConfig[bp]) {
        output += `@media (min-width: ${breakpointConfig[bp]}) {\n`;
        for (const cls of breakpointClasses[bp]) {
          output += `  ${attrSelector} .${cls.name},\n  :host(${attrSelector}) .${cls.name} {\n`;
          for (const prop of cls.properties) {
            output += `    ${prop}\n`;
          }
          output += `  }\n\n`;
        }
        output += `}\n\n`;
      }
    }
  }

  return output;
}

/**
 * Generates a responsive breakpoint CSS file with media queries from breakpoint files
 */
async function generateResponsiveBreakpointFile(dir, brand, breakpointConfig) {
  const breakpointFiles = {};

  // Read all breakpoint files
  for (const bp of BREAKPOINTS) {
    const files = fs.readdirSync(dir).filter(f => f.includes(`-${bp}-`) && f.endsWith('.css'));
    if (files.length > 0) {
      const filePath = path.join(dir, files[0]);
      if (fs.existsSync(filePath)) {
        breakpointFiles[bp] = fs.readFileSync(filePath, 'utf-8');
      }
    }
  }

  if (Object.keys(breakpointFiles).length === 0) {
    throw new Error('No breakpoint files found');
  }

  // Extract header from first file
  const firstFile = breakpointFiles.xs || breakpointFiles.sm || breakpointFiles.md || breakpointFiles.lg;
  const headerMatch = firstFile.match(/^\/\*\*[\s\S]*?\*\//);
  let header = headerMatch ? headerMatch[0] : '';
  header = header.replace(/Breakpoint: \w+/, 'Responsive (Media Queries)');
  header = header.replace(/Context: breakpoint: \w+/i, 'Context: Responsive (Media Queries)');

  let output = header + '\n\n';

  // Extract CSS variables from each breakpoint as key-value maps
  const breakpointVarMaps = {};
  for (const [bp, content] of Object.entries(breakpointFiles)) {
    breakpointVarMaps[bp] = parseVariablesToMap(extractRootVariables(content));
  }

  // Get base values (XS)
  const baseVars = breakpointVarMaps.xs || breakpointVarMaps.sm || breakpointVarMaps.md || breakpointVarMaps.lg;

  // Generate responsive CSS with media queries (Dual-Axis: Breakpoints use ContentBrand)
  // Uses dual selectors for Shadow DOM compatibility
  const attrSelector = `[data-content-brand="${brand}"]`;
  const dualSelector = buildDualSelector(attrSelector);

  output += `${dualSelector} {\n`;
  if (baseVars && Object.keys(baseVars).length > 0) {
    for (const [varName, value] of Object.entries(baseVars)) {
      output += `  ${varName}: ${value};\n`;
    }
  }
  output += `}\n\n`;

  // Media queries for SM, MD, LG - only output CHANGED values
  // Use cascade optimization: compare each breakpoint to the previous one
  const breakpointOrder = ['sm', 'md', 'lg'];
  let previousVars = baseVars; // Start with XS as the "previous"

  for (const bp of breakpointOrder) {
    if (breakpointVarMaps[bp] && breakpointConfig[bp]) {
      // Compare against the previous breakpoint (cascade optimization)
      const changedVars = getChangedVariables(baseVars, breakpointVarMaps[bp], previousVars);

      if (Object.keys(changedVars).length > 0) {
        output += `@media (min-width: ${breakpointConfig[bp]}) {\n`;
        output += `  ${dualSelector} {\n`;
        for (const [varName, value] of Object.entries(changedVars)) {
          output += `    ${varName}: ${value};\n`;
        }
        output += `  }\n`;
        output += `}\n\n`;
      }

      // Update previousVars for next iteration (merge current BP values)
      previousVars = { ...previousVars, ...breakpointVarMaps[bp] };
    }
  }

  return output;
}

/**
 * Generates a responsive CSS file with media queries for component breakpoint tokens
 * Converts [data-content-brand][data-breakpoint] selectors to @media queries (Dual-Axis)
 * Only outputs values that change between breakpoints to minimize redundancy
 * Uses dual selectors for Shadow DOM compatibility
 */
async function generateComponentBreakpointResponsive(dir, componentName, brand, breakpointConfig) {
  const breakpointFiles = {};
  const fileMapping = {
    xs: null,
    sm: null,
    md: null,
    lg: null
  };

  // Find breakpoint files by pattern
  const files = fs.readdirSync(dir).filter(f => f.includes('-breakpoint-') && f.endsWith('.css'));

  for (const file of files) {
    if (file.includes('-xs-')) fileMapping.xs = file;
    else if (file.includes('-sm-')) fileMapping.sm = file;
    else if (file.includes('-md-')) fileMapping.md = file;
    else if (file.includes('-lg-')) fileMapping.lg = file;
  }

  // Read all breakpoint files
  for (const [bp, fileName] of Object.entries(fileMapping)) {
    if (fileName) {
      const filePath = path.join(dir, fileName);
      if (fs.existsSync(filePath)) {
        breakpointFiles[bp] = fs.readFileSync(filePath, 'utf-8');
      }
    }
  }

  if (Object.keys(breakpointFiles).length === 0) {
    throw new Error('No breakpoint files found');
  }

  // Extract header from first file
  const firstFile = breakpointFiles.xs || breakpointFiles.sm || breakpointFiles.md || breakpointFiles.lg;
  const headerMatch = firstFile.match(/^\/\*\*[\s\S]*?\*\//);
  let header = headerMatch ? headerMatch[0] : '';
  header = header.replace(/breakpoint: \w+/i, 'Responsive (Media Queries)');
  header = header.replace(/Context: breakpoint: \w+/i, 'Context: Responsive (Media Queries)');

  let output = header + '\n\n';

  // Extract CSS variables from each breakpoint as key-value maps
  const breakpointVarMaps = {};
  for (const [bp, content] of Object.entries(breakpointFiles)) {
    breakpointVarMaps[bp] = parseVariablesToMap(extractRootVariables(content));
  }

  // Get base values (XS)
  const baseVars = breakpointVarMaps.xs || breakpointVarMaps.sm || breakpointVarMaps.md || breakpointVarMaps.lg;

  // Generate responsive CSS with media queries (Dual-Axis: Component breakpoints use ContentBrand)
  // Uses dual selectors for Shadow DOM compatibility
  const attrSelector = `[data-content-brand="${brand}"]`;
  const dualSelector = buildDualSelector(attrSelector);

  // Base styles (XS)
  output += `${dualSelector} {\n`;
  if (baseVars && Object.keys(baseVars).length > 0) {
    for (const [varName, value] of Object.entries(baseVars)) {
      output += `  ${varName}: ${value};\n`;
    }
  }
  output += `}\n\n`;

  // Media queries for SM, MD, LG - only output CHANGED values
  // Use cascade optimization: compare each breakpoint to the previous one
  const breakpointOrder = ['sm', 'md', 'lg'];
  let previousVars = baseVars; // Start with XS as the "previous"

  for (const bp of breakpointOrder) {
    if (breakpointVarMaps[bp] && breakpointConfig[bp]) {
      // Compare against the previous breakpoint (cascade optimization)
      const changedVars = getChangedVariables(baseVars, breakpointVarMaps[bp], previousVars);

      if (Object.keys(changedVars).length > 0) {
        output += `@media (min-width: ${breakpointConfig[bp]}) {\n`;
        output += `  ${dualSelector} {\n`;
        for (const [varName, value] of Object.entries(changedVars)) {
          output += `    ${varName}: ${value};\n`;
        }
        output += `  }\n`;
        output += `}\n\n`;
      }

      // Update previousVars for next iteration (merge current BP values)
      previousVars = { ...previousVars, ...breakpointVarMaps[bp] };
    }
  }

  return output;
}

/**
 * Extracts CSS custom property declarations from data-attribute selector
 * Supports both single selectors and dual selectors (with :host)
 */
function extractRootVariables(content) {
  const variables = [];

  // Match patterns:
  // 1. [data-content-brand="..."][data-breakpoint="..."] { ... }
  // 2. [data-content-brand="..."][data-breakpoint="..."],\n:host(...) { ... } (dual selector)
  // 3. :root { ... }
  // 4. :root,\n:host { ... } (dual selector)
  const selectorMatch = content.match(/(?:\[data-content-brand="[^"]+"\]\[data-breakpoint="[^"]+"\](?:,\s*:host\([^)]+\))?|:root(?:,\s*:host)?)\s*\{([\s\S]*)\}/);
  if (selectorMatch) {
    const selectorContent = selectorMatch[1];

    // Extract all CSS custom properties (--variable-name: value;)
    // This regex handles multi-line values and comments
    const lines = selectorContent.split('\n');
    for (const line of lines) {
      const trimmed = line.trim();
      // Match CSS custom property declaration
      if (trimmed.startsWith('--') && trimmed.includes(':')) {
        // Remove inline comments but keep the declaration
        const cleanLine = trimmed.replace(/\/\*.*?\*\//g, '').trim();
        if (cleanLine && cleanLine.endsWith(';')) {
          variables.push(cleanLine);
        }
      }
    }
  }

  return variables;
}

/**
 * Parses an array of CSS variable declarations into a name-value map
 * @param {string[]} variables - Array of declarations like "--var-name: value;"
 * @returns {Object} - Map of variable names to values
 */
function parseVariablesToMap(variables) {
  const map = {};
  for (const decl of variables) {
    // Parse "--var-name: value;" into name and value
    const colonIndex = decl.indexOf(':');
    if (colonIndex > 0) {
      const name = decl.substring(0, colonIndex).trim();
      // Remove trailing semicolon from value
      let value = decl.substring(colonIndex + 1).trim();
      if (value.endsWith(';')) {
        value = value.slice(0, -1).trim();
      }
      map[name] = value;
    }
  }
  return map;
}

/**
 * Compares two variable maps and returns only the variables that have different values
 * @param {Object} baseVars - Base (XS) variables map
 * @param {Object} compareVars - Variables to compare against base
 * @param {Object} previousBpVars - Variables from the previous breakpoint (for cascade optimization)
 * @returns {Object} - Map of variables that have changed
 */
function getChangedVariables(baseVars, compareVars, previousBpVars = null) {
  const changed = {};
  for (const [name, value] of Object.entries(compareVars)) {
    // If we have a previous breakpoint, only include if different from THAT
    // (cascade optimization: lg inherits from md which inherits from sm)
    if (previousBpVars) {
      // Only add if different from previous breakpoint
      if (previousBpVars[name] !== value) {
        changed[name] = value;
      }
    } else {
      // First comparison (sm vs xs): compare against base
      if (baseVars[name] !== value) {
        changed[name] = value;
      }
    }
  }
  return changed;
}

/**
 * Extracts CSS classes from a file for responsive merging
 * Supports both single selectors and dual selectors (for Shadow DOM compatibility)
 * Comment-agnostic: works regardless of whether SHOW_DESCRIPTIONS is enabled
 */
function extractClasses(content, brand, breakpoint) {
  const classes = [];
  const selector = `[data-content-brand="${brand}"][data-breakpoint="${breakpoint}"]`;
  const escapedSelector = selector.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  // Check if content uses data-attribute selectors (Dual-Axis: Typography uses ContentBrand)
  const hasDataAttributes = content.includes(selector);

  if (hasDataAttributes) {
    // Match dual selector pattern: [selector] .class, :host([selector]) .class { properties }
    // Comment-agnostic: regex does not depend on comments being present
    const classRegex = new RegExp(
      `${escapedSelector}\\s+` +                              // [data-content-brand="..."][data-breakpoint="..."]
      `\\.(\\S+?)` +                                          // .className (capture group 1)
      `(?:,\\s*:host\\(${escapedSelector}\\)\\s+\\.\\S+)?` +  // optional: , :host([...]) .className
      `\\s*\\{([^}]*)\\}`,                                    // { properties } (capture group 2)
      'g'
    );

    let match;
    while ((match = classRegex.exec(content)) !== null) {
      const className = match[1];
      const properties = match[2]
        .split(';')
        .map(p => p.trim())
        .filter(p => p.length > 0)
        .map(p => p + ';');

      classes.push({
        name: className,
        properties
      });
    }
  }

  // Fallback: try plain class selectors (no data attributes)
  if (classes.length === 0) {
    // Match plain .className { properties } - comment-agnostic
    const plainClassRegex = /\.([\w-]+)\s*\{([^}]*)\}/g;
    let match;
    while ((match = plainClassRegex.exec(content)) !== null) {
      const className = match[1];
      const properties = match[2]
        .split(';')
        .map(p => p.trim())
        .filter(p => p.length > 0)
        .map(p => p + ';');

      classes.push({
        name: className,
        properties
      });
    }
  }

  return classes;
}

/**
 * Creates Manifest
 */
function createManifest(stats) {
  console.log('\nðŸ“‹ Creating Manifest...');

  const manifest = {
    generated: new Date().toISOString(),
    version: '2.0.0',
    statistics: {
      sharedPrimitives: stats.sharedPrimitives || { total: 0, successful: 0 },
      brandSpecific: stats.brandSpecific || { totalBuilds: 0, successfulBuilds: 0 },
      componentTokens: stats.componentTokens || { totalBuilds: 0, successfulBuilds: 0 },
      typographyTokens: stats.typographyTokens || { totalBuilds: 0, successfulBuilds: 0 },
      effectTokens: stats.effectTokens || { totalBuilds: 0, successfulBuilds: 0 },
      responsiveCSS: stats.responsiveCSS || { totalConversions: 0, successfulConversions: 0 }
    },
    structure: {
      brands: BRANDS,
      breakpoints: BREAKPOINTS,
      colorModes: COLOR_MODES,
      sizeClasses: {
        ios: Object.values(IOS_SIZE_CLASS_MAPPING),
        android: Object.values(ANDROID_SIZE_CLASS_MAPPING)
      },
      outputPaths: {
        css: {
          shared: 'css/shared/',
          brands: 'css/brands/{brand}/ (with data-attributes)'
        },
        scss: {
          shared: 'scss/shared/',
          brands: 'scss/brands/{brand}/'
        },
        js: {
          shared: 'js/shared/',
          brands: 'js/brands/{brand}/'
        },
        json: {
          shared: 'json/shared/',
          brands: 'json/brands/{brand}/'
        },
        ios: {
          shared: 'ios/shared/',
          brands: 'ios/brands/{brand}/',
          sizeClasses: 'ios/brands/{brand}/sizeclass-{compact|regular}/'
        },
        ...(COMPOSE_ENABLED ? {
          compose: {
            shared: 'android/compose/shared/',
            brands: 'android/compose/brands/{brand}/',
            sizeClasses: 'android/compose/brands/{brand}/semantic/sizeclass/'
          }
        } : {})
      }
    }
  };

  fs.writeFileSync(
    path.join(DIST_DIR, 'manifest.json'),
    JSON.stringify(manifest, null, 2),
    'utf8'
  );

  console.log('  âœ… Manifest created: dist/manifest.json');
}

/**
 * Aggregates individual Compose component files into single files per component
 * Creates: dist/compose/brands/{brand}/components/{Component}/{Component}Tokens.kt
 */
async function aggregateComposeComponents() {
  if (!COMPOSE_ENABLED) {
    return { totalComponents: 0, successfulComponents: 0 };
  }

  console.log('ðŸ“¦ Aggregating Compose component files...');

  let totalComponents = 0;
  let successfulComponents = 0;

  const composeDir = path.join(ANDROID_DIST_DIR, 'brands');

  if (!fs.existsSync(composeDir)) {
    console.log('  âš ï¸  No Compose output found, skipping aggregation');
    return { totalComponents: 0, successfulComponents: 0 };
  }

  for (const brand of BRANDS) {
    const brandComponentsDir = path.join(composeDir, brand, 'components');

    if (!fs.existsSync(brandComponentsDir)) {
      continue;
    }

    const componentDirs = fs.readdirSync(brandComponentsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .filter(dirent => !dirent.name.startsWith('.') && !dirent.name.startsWith('_'))
      .map(dirent => dirent.name);

    for (const componentDirName of componentDirs) {
      totalComponents++;
      const componentDir = path.join(brandComponentsDir, componentDirName);
      // Convert directory name (lowercase) to PascalCase for class names
      const componentName = componentDirName.charAt(0).toUpperCase() + componentDirName.slice(1);
      const ktFiles = fs.readdirSync(componentDir)
        .filter(f => f.endsWith('.kt'))
        .sort();

      if (ktFiles.length === 0) continue;

      try {
        // Parse all individual files and collect tokens
        const tokenGroups = {
          colors: { light: [], dark: [] },
          sizing: { compact: [], medium: [], expanded: [] },
          density: { default: [], dense: [], spacious: [] },
          typography: { compact: [], medium: [], expanded: [] },
          effects: { light: [], dark: [] }
        };

        for (const ktFile of ktFiles) {
          const content = fs.readFileSync(path.join(componentDir, ktFile), 'utf8');
          const tokens = parseKotlinTokens(content);

          // Categorize based on filename (Material 3: Compact, Medium, Expanded)
          const lowerFile = ktFile.toLowerCase();
          if (lowerFile.includes('colorslight')) {
            tokenGroups.colors.light = tokens;
          } else if (lowerFile.includes('colorsdark')) {
            tokenGroups.colors.dark = tokens;
          } else if (lowerFile.includes('sizingcompact')) {
            tokenGroups.sizing.compact = tokens;
          } else if (lowerFile.includes('sizingmedium')) {
            tokenGroups.sizing.medium = tokens;
          } else if (lowerFile.includes('sizingexpanded')) {
            tokenGroups.sizing.expanded = tokens;
          } else if (lowerFile.includes('densitydense')) {
            tokenGroups.density.dense = tokens;
          } else if (lowerFile.includes('densitydefault')) {
            tokenGroups.density.default = tokens;
          } else if (lowerFile.includes('densityspacious')) {
            tokenGroups.density.spacious = tokens;
          } else if (lowerFile.includes('typographycompact')) {
            tokenGroups.typography.compact = tokens;
          } else if (lowerFile.includes('typographymedium')) {
            tokenGroups.typography.medium = tokens;
          } else if (lowerFile.includes('typographyexpanded')) {
            tokenGroups.typography.expanded = tokens;
          } else if (lowerFile.includes('effectslight')) {
            tokenGroups.effects.light = tokens;
          } else if (lowerFile.includes('effectsdark')) {
            tokenGroups.effects.dark = tokens;
          }
        }

        // Generate aggregated file
        const aggregatedContent = generateAggregatedComponentFile(
          brand,
          componentName,
          tokenGroups
        );

        // Write aggregated file
        const outputPath = path.join(componentDir, `${componentName}Tokens.kt`);
        fs.writeFileSync(outputPath, aggregatedContent, 'utf8');

        console.log(`     âœ… ${brand}/${componentName}Tokens.kt`);
        successfulComponents++;

      } catch (error) {
        console.error(`     âŒ ${brand}/${componentName}: ${error.message}`);
      }
    }
  }

  console.log(`  ðŸ“Š Aggregated: ${successfulComponents}/${totalComponents} components\n`);
  return { totalComponents, successfulComponents };
}

/**
 * Parses Kotlin token file and extracts val declarations
 * Handles both single-line values and multi-line composite objects (DesignTextStyle, ShadowStyle)
 */
function parseKotlinTokens(content) {
  const tokens = [];
  const processedNames = new Set();

  // Helper function to extract multi-line patterns with balanced parentheses
  // initialDepth: how many opening parens the pattern ends with (default 1)
  const extractMultiLinePattern = (pattern, prefix, initialDepth = 1) => {
    let match;
    while ((match = pattern.exec(content)) !== null) {
      const name = match[1];
      const startIndex = match.index + match[0].length;

      // Count parentheses to find the matching closing )
      // initialDepth accounts for patterns that end with multiple opening parens
      let depth = initialDepth;
      let endIndex = startIndex;
      while (depth > 0 && endIndex < content.length) {
        if (content[endIndex] === '(') depth++;
        if (content[endIndex] === ')') depth--;
        endIndex++;
      }

      // Extract the inner content and normalize whitespace
      // Also remove spaces before closing parens for clean formatting
      const innerContent = content.substring(startIndex, endIndex - 1)
          .replace(/\s+/g, ' ')
          .replace(/\s+\)/g, ')')
          .trim();
      tokens.push({
        name: name,
        // innerContent already includes intermediate closing parens
        // We just need to wrap with prefix( ... )
        value: `${prefix}(${innerContent})`
      });
      processedNames.add(name);
    }
  };

  // Handle multi-line DesignTextStyle objects
  extractMultiLinePattern(/val\s+(\w+)\s*=\s*DesignTextStyle\(/g, 'DesignTextStyle');

  // Handle multi-line ShadowStyle objects (with listOf)
  // initialDepth = 2 because pattern ends with two opening parens: ShadowStyle(listOf(
  extractMultiLinePattern(/val\s+(\w+)\s*=\s*ShadowStyle\(listOf\(/g, 'ShadowStyle(listOf', 2);

  // Then handle single-line val declarations (excluding already processed patterns)
  const valRegex = /val\s+(\w+)\s*=\s*([^\n]+)/g;
  let match;
  while ((match = valRegex.exec(content)) !== null) {
    const name = match[1];
    if (!processedNames.has(name) &&
        !match[2].includes('DesignTextStyle(') &&
        !match[2].includes('ShadowStyle(')) {
      tokens.push({
        name: name,
        value: match[2].trim()
      });
    }
  }

  return tokens;
}

/**
 * Generates aggregated Kotlin file with nested objects
 */
function generateAggregatedComponentFile(brand, componentName, tokenGroups) {
  const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
  const packageJson = require('../../packages/tokens/package.json');
  const version = packageJson.version;

  // Load component Breakpoint Ã— Density matrix (if available)
  const componentDensityMatrix = loadComponentDensityMatrix(brand, componentName);
  const matrixTokenNames = componentDensityMatrix ? Object.keys(componentDensityMatrix) : [];

  // Filter sizing tokens to exclude those that are in the density matrix
  // (They'll be generated in the Density section with proper Breakpoint Ã— Density resolution)
  const filteredSizing = {
    compact: tokenGroups.sizing.compact.filter(t => !matrixTokenNames.includes(t.name)),
    medium: tokenGroups.sizing.medium.filter(t => !matrixTokenNames.includes(t.name)),
    expanded: tokenGroups.sizing.expanded.filter(t => !matrixTokenNames.includes(t.name))
  };

  // Determine required imports based on token values (Material 3: Compact, Medium, Expanded)
  const allTokens = [
    ...tokenGroups.colors.light,
    ...tokenGroups.colors.dark,
    ...filteredSizing.compact,
    ...filteredSizing.medium,
    ...filteredSizing.expanded,
    ...tokenGroups.density.dense,
    ...tokenGroups.density.default,
    ...tokenGroups.density.spacious,
    ...tokenGroups.typography.compact,
    ...tokenGroups.typography.medium,
    ...tokenGroups.typography.expanded,
    ...(tokenGroups.effects?.light || []),
    ...(tokenGroups.effects?.dark || [])
  ];

  const hasColor = allTokens.some(t => t.value.includes('Color('));
  const hasDp = allTokens.some(t => t.value.includes('.dp'));
  const hasSp = allTokens.some(t => t.value.includes('.sp'));
  const hasFontStyle = allTokens.some(t => t.value.includes('FontStyle.'));
  const hasDensityTokens = tokenGroups.density.dense.length > 0 ||
      tokenGroups.density.default.length > 0 ||
      tokenGroups.density.spacious.length > 0;
  const hasMatrixDensityTokens = matrixTokenNames.length > 0;
  const hasColorTokens = tokenGroups.colors.light.length > 0 || tokenGroups.colors.dark.length > 0;
  const hasSizingTokens = filteredSizing.compact.length > 0 ||
      filteredSizing.medium.length > 0 ||
      filteredSizing.expanded.length > 0;
  const hasTypographyTokens = tokenGroups.typography.compact.length > 0 ||
      tokenGroups.typography.medium.length > 0 ||
      tokenGroups.typography.expanded.length > 0;
  const hasEffectsTokens = (tokenGroups.effects?.light?.length > 0) || (tokenGroups.effects?.dark?.length > 0);

  // Need @Composable and Theme imports for current() accessors
  const needsComposable = hasDensityTokens || hasColorTokens || hasSizingTokens || hasTypographyTokens || hasEffectsTokens;
  // WindowSizeClass needed for both Sizing and Typography (Material 3: Compact/Medium/Expanded)
  const needsWindowSizeClass = hasSizingTokens || hasTypographyTokens;

  const imports = ['import androidx.compose.runtime.Immutable'];
  if (needsComposable) {
    imports.push('import androidx.compose.runtime.Composable');
    imports.push('import com.bild.designsystem.shared.DesignSystemTheme');
  }
  if (hasDensityTokens) {
    imports.push('import com.bild.designsystem.shared.Density');
  }
  if (needsWindowSizeClass) {
    imports.push('import com.bild.designsystem.shared.WindowSizeClass');
  }
  if (hasColor) imports.push('import androidx.compose.ui.graphics.Color');
  if (hasFontStyle) imports.push('import androidx.compose.ui.text.font.FontStyle');
  if (hasDp || hasSp) imports.push('import androidx.compose.ui.unit.Dp');
  if (hasDp) imports.push('import androidx.compose.ui.unit.dp');
  if (hasSp) imports.push('import androidx.compose.ui.unit.sp');
  if (hasSp && needsComposable) imports.push('import androidx.compose.ui.unit.TextUnit');

  // Check if typography uses DesignTextStyle
  const hasDesignTextStyle = allTokens.some(t => t.value.includes('DesignTextStyle('));
  if (hasDesignTextStyle || hasTypographyTokens) {
    imports.push('import androidx.compose.ui.text.font.FontWeight');
    imports.push('import androidx.compose.ui.text.style.TextDecoration');
    imports.push('import com.bild.designsystem.shared.DesignTextStyle');
    imports.push('import com.bild.designsystem.shared.DesignTextCase');
  }

  // Check if effects use ShadowStyle
  if (hasEffectsTokens) {
    imports.push('import com.bild.designsystem.shared.ShadowStyle');
    imports.push('import com.bild.designsystem.shared.DropShadow');
  }

  let output = generateFileHeader({
    fileName: `${componentName}Tokens.kt`,
    commentStyle: 'block',
    platform: 'android',
    brand: brandPascal,
    context: `Component: ${componentName}\nAggregated component tokens with all modes`
  });

  output += `
package com.bild.designsystem.brands.${brand}.components.${componentName.toLowerCase()}

${imports.join('\n')}

/**
 * ${componentName} Design Tokens
 *
 * Usage:
 *   ${componentName}Tokens.Colors.Light.primaryBgIdle
 *   ${componentName}Tokens.Sizing.Compact.height
 *   ${componentName}Tokens.Density.Default.contentGap
 */
object ${componentName}Tokens {
`;

  // Colors section with interface and current() accessor
  if (tokenGroups.colors.light.length > 0 || tokenGroups.colors.dark.length > 0) {
    // Collect all unique token names for interface
    const colorTokenNames = new Map();
    [...tokenGroups.colors.light, ...tokenGroups.colors.dark].forEach(t => {
      if (!colorTokenNames.has(t.name)) {
        colorTokenNames.set(t.name, t.value);
      }
    });

    output += `
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COLORS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Colors {
        /**
         * Returns color tokens for the current theme.
         * Automatically resolves to Light or Dark based on DesignSystemTheme.isDarkTheme
         *
         * Usage:
         *   val bgColor = ${componentName}Tokens.Colors.current().primaryBgIdle
         */
        @Composable
        fun current(): ColorTokens = if (DesignSystemTheme.isDarkTheme) Dark else Light

        /**
         * Interface for color tokens
         */
        interface ColorTokens {
`;
    // Helper to determine if a value is an opacity (0-1 float or 0-100 percentage)
    const isOpacityValue = (value) => {
      const numStr = String(value).trim();
      const num = parseFloat(numStr);
      // Check if it's a simple number (not Color(...) or similar)
      return !isNaN(num) && !numStr.includes('Color') && !numStr.includes('0x');
    };

    // Generate interface properties
    colorTokenNames.forEach((value, name) => {
      const propType = isOpacityValue(value) ? 'Float' : 'Color';
      output += `            val ${name}: ${propType}\n`;
    });
    output += `        }

`;

    // Helper to format opacity value correctly
    const formatColorValue = (value) => {
      if (isOpacityValue(value)) {
        const num = parseFloat(value);
        // Convert percentage (e.g., 80) to decimal (0.8) if > 1
        const normalizedValue = num > 1 ? num / 100 : num;
        return `${normalizedValue}f`;
      }
      return value;
    };

    if (tokenGroups.colors.light.length > 0) {
      output += `        object Light : ColorTokens {\n`;
      tokenGroups.colors.light.forEach(t => {
        output += `            override val ${t.name} = ${formatColorValue(t.value)}\n`;
      });
      output += `        }\n`;
    }
    if (tokenGroups.colors.dark.length > 0) {
      output += `        object Dark : ColorTokens {\n`;
      tokenGroups.colors.dark.forEach(t => {
        output += `            override val ${t.name} = ${formatColorValue(t.value)}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  // Sizing section with interface and current() accessor (Material 3: Compact, Medium, Expanded)
  // NOTE: Tokens that are in the density matrix are excluded - they use WindowSizeClass Ã— Density resolution
  if (filteredSizing.compact.length > 0 || filteredSizing.medium.length > 0 || filteredSizing.expanded.length > 0) {
    // Collect all unique token names for interface
    const sizingTokenNames = new Map();
    [...filteredSizing.compact, ...filteredSizing.medium, ...filteredSizing.expanded].forEach(t => {
      if (!sizingTokenNames.has(t.name)) {
        sizingTokenNames.set(t.name, t.value);
      }
    });

    output += `
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SIZING (Material 3 WindowSizeClass)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Sizing {
        /**
         * Returns sizing tokens for the current window size class.
         * Automatically resolves to Compact, Medium, or Expanded based on DesignSystemTheme.sizeClass
         *
         * Usage:
         *   val fontSize = ${componentName}Tokens.Sizing.current().labelFontSize
         */
        @Composable
        fun current(): SizingTokens = when (DesignSystemTheme.sizeClass) {
            WindowSizeClass.Compact -> Compact
            WindowSizeClass.Medium -> Medium
            WindowSizeClass.Expanded -> Expanded
        }

        /**
         * Interface for sizing tokens
         */
        interface SizingTokens {
`;
    // Generate interface properties
    sizingTokenNames.forEach((value, name) => {
      // Determine type based on value
      let propType = 'Dp';
      if (value.includes('.sp')) propType = 'TextUnit';
      else if (value.includes('Color(')) propType = 'Color';
      else if (value.startsWith('"') || value.startsWith("'")) {
        // String value (e.g., fontFamily)
        propType = 'String';
      } else if (!value.includes('.dp') && !value.includes('.sp')) {
        // Check if it's a pure number (Int)
        const numMatch = value.match(/^(\d+)$/);
        if (numMatch) propType = 'Int';
      }
      output += `            val ${name}: ${propType}\n`;
    });
    output += `        }

`;
    if (filteredSizing.compact.length > 0) {
      output += `        object Compact : SizingTokens {\n`;
      filteredSizing.compact.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    if (filteredSizing.medium.length > 0) {
      output += `        object Medium : SizingTokens {\n`;
      filteredSizing.medium.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    if (filteredSizing.expanded.length > 0) {
      output += `        object Expanded : SizingTokens {\n`;
      filteredSizing.expanded.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  // Density section with WindowSizeClass Ã— Density resolution (if matrix available)
  // Or fallback to density-only resolution (if no matrix)
  if (hasMatrixDensityTokens) {
    // Generate Density section with WindowSizeClass Ã— Density matrix
    // This provides proper responsive density-aware tokens
    const matrixTokens = Object.entries(componentDensityMatrix);

    // Helper to determine Kotlin type from value
    const getKotlinType = (value) => {
      if (typeof value === 'string') {
        if (value.includes('.sp')) return 'TextUnit';
        if (value.includes('.dp')) return 'Dp';
        if (value.includes('Color(')) return 'Color';
        return 'Dp';
      }
      return 'Dp';
    };

    // Helper to format value for Kotlin
    const formatKotlinValue = (value, tokenName) => {
      if (typeof value === 'number') {
        // Check if token name suggests it's a font size or line height
        if (tokenName.toLowerCase().includes('fontsize') || tokenName.toLowerCase().includes('lineheight')) {
          return `${value}.sp`;
        }
        return `${value}.dp`;
      }
      return value;
    };

    // Collect token info for interface
    const tokenInfo = new Map();
    matrixTokens.forEach(([name, data]) => {
      const sampleValue = data.values.sm?.default ?? data.values.xs?.default ?? 0;
      const formattedValue = formatKotlinValue(sampleValue, name);
      tokenInfo.set(name, getKotlinType(formattedValue));
    });

    output += `
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DENSITY (WindowSizeClass Ã— Density Matrix)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Density {
        /**
         * Returns density tokens resolved by WindowSizeClass Ã— DensityMode.
         * Values are pre-resolved from the Breakpoint Ã— Density matrix at build-time.
         *
         * Usage:
         *   val gap = ${componentName}Tokens.Density.current().${matrixTokens[0]?.[0] || 'tokenName'}
         */
        @Composable
        fun current(): DensityTokens {
            val sizeClass = DesignSystemTheme.sizeClass
            val density = DesignSystemTheme.density
            return when (sizeClass) {
                WindowSizeClass.Compact -> when (density) {
                    com.bild.designsystem.shared.Density.Dense -> CompactDense
                    com.bild.designsystem.shared.Density.Default -> CompactDefault
                    com.bild.designsystem.shared.Density.Spacious -> CompactSpacious
                }
                WindowSizeClass.Medium -> when (density) {
                    com.bild.designsystem.shared.Density.Dense -> MediumDense
                    com.bild.designsystem.shared.Density.Default -> MediumDefault
                    com.bild.designsystem.shared.Density.Spacious -> MediumSpacious
                }
                WindowSizeClass.Expanded -> when (density) {
                    com.bild.designsystem.shared.Density.Dense -> ExpandedDense
                    com.bild.designsystem.shared.Density.Default -> ExpandedDefault
                    com.bild.designsystem.shared.Density.Spacious -> ExpandedSpacious
                }
            }
        }

        /**
         * Interface for density tokens (WindowSizeClass Ã— Density resolved)
         */
        interface DensityTokens {
`;
    tokenInfo.forEach((type, name) => {
      output += `            val ${name}: ${type}\n`;
    });
    output += `        }

`;

    // Android WindowSizeClass mapping: Compactâ†’sm, Mediumâ†’md, Expandedâ†’lg
    const androidBreakpointMap = {
      Compact: 'sm',
      Medium: 'md',
      Expanded: 'lg'
    };
    const densityModes = ['Dense', 'Default', 'Spacious'];
    const densityModeKeys = { Dense: 'dense', Default: 'default', Spacious: 'spacious' };

    // Generate 9 objects (3 WindowSizeClasses Ã— 3 DensityModes)
    for (const [sizeClassName, breakpointKey] of Object.entries(androidBreakpointMap)) {
      for (const densityMode of densityModes) {
        const objectName = `${sizeClassName}${densityMode}`;
        const densityKey = densityModeKeys[densityMode];

        output += `        object ${objectName} : DensityTokens {\n`;
        matrixTokens.forEach(([tokenName, tokenData]) => {
          const value = tokenData.values[breakpointKey]?.[densityKey] ?? tokenData.values.xs?.[densityKey] ?? 0;
          const formattedValue = formatKotlinValue(value, tokenName);
          output += `            override val ${tokenName} = ${formattedValue}\n`;
        });
        output += `        }\n`;
      }
    }
    output += `    }\n`;
  } else if (hasDensityTokens) {
    // Fallback: density-only resolution (no WindowSizeClass dimension)
    const densityTokenNames = new Map();
    [...tokenGroups.density.dense, ...tokenGroups.density.default, ...tokenGroups.density.spacious].forEach(t => {
      if (!densityTokenNames.has(t.name)) {
        densityTokenNames.set(t.name, t.value);
      }
    });

    output += `
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DENSITY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Density {
        /**
         * Returns density tokens for the current theme density.
         * Automatically resolves to Dense, Default, or Spacious based on DesignSystemTheme.density
         *
         * Usage:
         *   val gap = ${componentName}Tokens.Density.current().contentGap
         */
        @Composable
        fun current(): DensityTokens = when (DesignSystemTheme.density) {
            com.bild.designsystem.shared.Density.Dense -> Dense
            com.bild.designsystem.shared.Density.Default -> Default
            com.bild.designsystem.shared.Density.Spacious -> Spacious
        }

        /**
         * Interface for density-dependent tokens
         */
        interface DensityTokens {
`;
    // Generate interface properties
    densityTokenNames.forEach((value, name) => {
      // Determine type based on value
      let propType = 'Dp';
      if (value.includes('.sp')) propType = 'TextUnit';
      else if (value.includes('Color(')) propType = 'Color';
      else if (!value.includes('.dp') && !value.includes('.sp') && /^\d+$/.test(value.replace(/[^\d]/g, ''))) {
        // Check if it's a pure number (Int)
        if (!value.includes('.')) propType = 'Int';
      }
      output += `            val ${name}: ${propType}\n`;
    });
    output += `        }

`;
    if (tokenGroups.density.dense.length > 0) {
      output += `        object Dense : DensityTokens {\n`;
      tokenGroups.density.dense.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    if (tokenGroups.density.default.length > 0) {
      output += `        object Default : DensityTokens {\n`;
      tokenGroups.density.default.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    if (tokenGroups.density.spacious.length > 0) {
      output += `        object Spacious : DensityTokens {\n`;
      tokenGroups.density.spacious.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  // Typography section with interface and current() accessor (Material 3: Compact, Medium, Expanded)
  if (tokenGroups.typography.compact.length > 0 || tokenGroups.typography.medium.length > 0 || tokenGroups.typography.expanded.length > 0) {
    // Collect all unique token names for interface
    const typographyTokenNames = new Map();
    [...tokenGroups.typography.compact, ...tokenGroups.typography.medium, ...tokenGroups.typography.expanded].forEach(t => {
      if (!typographyTokenNames.has(t.name)) {
        typographyTokenNames.set(t.name, t.value);
      }
    });

    output += `
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TYPOGRAPHY (Material 3 WindowSizeClass)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Typography {
        /**
         * Returns typography tokens for the current window size class.
         * Automatically resolves to Compact, Medium, or Expanded based on DesignSystemTheme.sizeClass
         *
         * Usage:
         *   val fontFamily = ${componentName}Tokens.Typography.current().labelFontFamily
         */
        @Composable
        fun current(): TypographyTokens = when (DesignSystemTheme.sizeClass) {
            WindowSizeClass.Compact -> Compact
            WindowSizeClass.Medium -> Medium
            WindowSizeClass.Expanded -> Expanded
        }

        /**
         * Interface for typography tokens (DesignTextStyle composite objects)
         */
        interface TypographyTokens {
`;
    // Generate interface properties - check if using DesignTextStyle or individual properties
    typographyTokenNames.forEach((value, name) => {
      // Check if this is a DesignTextStyle composite token
      let propType;
      if (value.includes('DesignTextStyle(')) {
        propType = 'DesignTextStyle';
      } else if (value.includes('.sp')) {
        propType = 'TextUnit';
      } else if (value.includes('.dp')) {
        propType = 'Dp';
      } else if (value.includes('FontStyle.')) {
        propType = 'FontStyle';
      } else if (/^\d+$/.test(value.trim())) {
        propType = 'Int';
      } else if (value.startsWith('"') || value.startsWith("'")) {
        propType = 'String';
      } else {
        propType = 'String';
      }
      output += `            val ${name}: ${propType}\n`;
    });
    output += `        }

`;
    if (tokenGroups.typography.compact.length > 0) {
      output += `        object Compact : TypographyTokens {\n`;
      tokenGroups.typography.compact.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    if (tokenGroups.typography.medium.length > 0) {
      output += `        object Medium : TypographyTokens {\n`;
      tokenGroups.typography.medium.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    if (tokenGroups.typography.expanded.length > 0) {
      output += `        object Expanded : TypographyTokens {\n`;
      tokenGroups.typography.expanded.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  // Effects section with interface and current() accessor
  if (hasEffectsTokens) {
    // Collect all unique token names for interface
    const effectsTokenNames = new Map();
    [...(tokenGroups.effects?.light || []), ...(tokenGroups.effects?.dark || [])].forEach(t => {
      if (!effectsTokenNames.has(t.name)) {
        effectsTokenNames.set(t.name, t.value);
      }
    });

    output += `
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EFFECTS (Shadows)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Effects {
        /**
         * Returns effects tokens for the current theme.
         * Automatically resolves to Light or Dark based on DesignSystemTheme.isDarkTheme
         *
         * Usage:
         *   val shadow = ${componentName}Tokens.Effects.current().menuShadow
         */
        @Composable
        fun current(): EffectsTokens = if (DesignSystemTheme.isDarkTheme) Dark else Light

        /**
         * Interface for effects tokens (ShadowStyle composites)
         */
        interface EffectsTokens {
`;
    // Generate interface properties
    effectsTokenNames.forEach((value, name) => {
      output += `            val ${name}: ShadowStyle\n`;
    });
    output += `        }

`;
    if (tokenGroups.effects?.light?.length > 0) {
      output += `        object Light : EffectsTokens {\n`;
      tokenGroups.effects.light.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    if (tokenGroups.effects?.dark?.length > 0) {
      output += `        object Dark : EffectsTokens {\n`;
      tokenGroups.effects.dark.forEach(t => {
        output += `            override val ${t.name} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  output += `}
`;

  return output;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SwiftUI COMPONENT AGGREGATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Aggregates individual SwiftUI component files into single files per component
 * Creates: dist/ios/brands/{brand}/components/{Component}/{Component}Tokens.swift
 */
async function aggregateSwiftUIComponents() {
  if (!SWIFTUI_ENABLED) {
    return { totalComponents: 0, successfulComponents: 0 };
  }

  console.log('ðŸ“¦ Aggregating SwiftUI component files...');

  let totalComponents = 0;
  let successfulComponents = 0;

  const iosDir = path.join(IOS_DIST_DIR, 'brands');

  if (!fs.existsSync(iosDir)) {
    console.log('  âš ï¸  No iOS output found, skipping aggregation');
    return { totalComponents: 0, successfulComponents: 0 };
  }

  for (const brand of BRANDS) {
    const brandComponentsDir = path.join(iosDir, brand, 'components');

    if (!fs.existsSync(brandComponentsDir)) {
      continue;
    }

    const componentDirs = fs.readdirSync(brandComponentsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .filter(dirent => !dirent.name.startsWith('.') && !dirent.name.startsWith('_'))
      .map(dirent => dirent.name);

    for (const componentName of componentDirs) {
      totalComponents++;
      const componentDir = path.join(brandComponentsDir, componentName);
      // Filter out aggregated token files (now brand-prefixed: BildButtonTokens.swift, SportbildButtonTokens.swift, etc.)
      const swiftFiles = fs.readdirSync(componentDir)
        .filter(f => f.endsWith('.swift') && !f.match(/^[A-Z][a-z]+[A-Z].*Tokens\.swift$/))
        .sort();

      if (swiftFiles.length === 0) continue;

      try {
        // Parse all individual files and collect tokens
        const tokenGroups = {
          colors: { light: [], dark: [] },
          sizing: { compact: [], regular: [] },
          density: { default: [], dense: [], spacious: [] },
          typography: { compact: [], regular: [] },
          effects: { light: [], dark: [] }
        };

        for (const swiftFile of swiftFiles) {
          const content = fs.readFileSync(path.join(componentDir, swiftFile), 'utf8');
          const tokens = parseSwiftTokens(content);

          // Categorize based on filename
          // IMPORTANT: Check typography BEFORE sizing because typography files contain "sizing" in name
          const lowerFile = swiftFile.toLowerCase();
          if (lowerFile.includes('colorslight') || lowerFile.includes('colorlight')) {
            tokenGroups.colors.light = tokens;
          } else if (lowerFile.includes('colorsdark') || lowerFile.includes('colordark')) {
            tokenGroups.colors.dark = tokens;
          } else if (lowerFile.includes('typography')) {
            // Typography files (e.g., ButtonTypographySizingCompact.swift)
            if (lowerFile.includes('compact')) {
              tokenGroups.typography.compact = tokens;
            } else if (lowerFile.includes('regular')) {
              tokenGroups.typography.regular = tokens;
            }
          } else if (lowerFile.includes('sizingcompact')) {
            tokenGroups.sizing.compact = tokens;
          } else if (lowerFile.includes('sizingregular')) {
            tokenGroups.sizing.regular = tokens;
          } else if (lowerFile.includes('densitydense')) {
            tokenGroups.density.dense = tokens;
          } else if (lowerFile.includes('densitydefault')) {
            tokenGroups.density.default = tokens;
          } else if (lowerFile.includes('densityspacious')) {
            tokenGroups.density.spacious = tokens;
          } else if (lowerFile.includes('effectslight') || lowerFile.includes('effectlight')) {
            tokenGroups.effects.light = tokens;
          } else if (lowerFile.includes('effectsdark') || lowerFile.includes('effectdark')) {
            tokenGroups.effects.dark = tokens;
          }
        }

        // Generate aggregated file
        const aggregatedContent = generateAggregatedSwiftComponentFile(
          brand,
          componentName,
          tokenGroups
        );

        // Write aggregated file with brand-prefixed filename
        const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
        const tokenFileName = `${brandPascal}${componentName}Tokens.swift`;
        const outputPath = path.join(componentDir, tokenFileName);
        fs.writeFileSync(outputPath, aggregatedContent, 'utf8');

        console.log(`     âœ… ${brand}/${tokenFileName}`);
        successfulComponents++;

      } catch (error) {
        console.error(`     âŒ ${brand}/${componentName}: ${error.message}`);
      }
    }
  }

  console.log(`  ðŸ“Š Aggregated: ${successfulComponents}/${totalComponents} components\n`);
  return { totalComponents, successfulComponents };
}

/**
 * Parses Swift token file and extracts let declarations
 * Supports both explicit types (let x: Type = value) and implicit types (let x = TextStyle(...))
 */
function parseSwiftTokens(content) {
  const tokens = [];

  // Match: public let tokenName: Type = value (explicit type)
  const explicitTypeRegex = /public\s+let\s+(\w+):\s*(\w+)\s*=\s*(.+)/g;
  let match;

  while ((match = explicitTypeRegex.exec(content)) !== null) {
    tokens.push({
      name: match[1],
      type: match[2],
      value: match[3].trim()
    });
  }

  // Match: public let tokenName = TextStyle(...) (implicit type - for typography)
  // This regex captures multi-line TextStyle declarations
  const textStyleRegex = /public\s+let\s+(\w+)\s*=\s*(TextStyle\s*\([^)]+\))/gs;
  while ((match = textStyleRegex.exec(content)) !== null) {
    tokens.push({
      name: match[1],
      type: 'TextStyle',
      value: match[2].replace(/\s+/g, ' ').trim()
    });
  }

  // Match: public let tokenName = ShadowStyle(shadows: [...]) (implicit type - for effects)
  // This regex captures multi-line ShadowStyle declarations with nested DropShadow arrays
  const shadowStyleRegex = /public\s+let\s+(\w+)\s*=\s*(ShadowStyle\s*\(shadows:\s*\[[\s\S]*?\]\s*\))/g;
  while ((match = shadowStyleRegex.exec(content)) !== null) {
    tokens.push({
      name: match[1],
      type: 'ShadowStyle',
      value: match[2].replace(/\s+/g, ' ').trim()
    });
  }

  return tokens;
}

/**
 * Generates aggregated Swift file with nested enums
 */
function generateAggregatedSwiftComponentFile(brand, componentName, tokenGroups) {
  const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
  const packageJson = require('../../packages/tokens/package.json');
  const version = packageJson.version;

  // Load component Breakpoint Ã— Density matrix (if available)
  const componentDensityMatrix = loadComponentDensityMatrix(brand, componentName);
  const matrixTokenNames = componentDensityMatrix ? Object.keys(componentDensityMatrix) : [];

  // Filter sizing tokens to exclude those that are in the density matrix
  const filteredSizing = {
    compact: tokenGroups.sizing.compact.filter(t => !matrixTokenNames.includes(t.name)),
    regular: tokenGroups.sizing.regular.filter(t => !matrixTokenNames.includes(t.name))
  };

  // Check what token groups exist
  const hasColorTokens = tokenGroups.colors.light.length > 0 || tokenGroups.colors.dark.length > 0;
  const hasSizingTokens = filteredSizing.compact.length > 0 || filteredSizing.regular.length > 0;
  const hasMatrixDensityTokens = matrixTokenNames.length > 0;
  const hasDensityTokens = tokenGroups.density.dense.length > 0 ||
      tokenGroups.density.default.length > 0 ||
      tokenGroups.density.spacious.length > 0;
  const hasTypographyTokens = tokenGroups.typography.compact.length > 0 || tokenGroups.typography.regular.length > 0;
  const hasEffectsTokens = tokenGroups.effects && (tokenGroups.effects.light.length > 0 || tokenGroups.effects.dark.length > 0);

  // Use brand-prefixed names to avoid SPM filename/type collisions
  const tokenClassName = `${brandPascal}${componentName}Tokens`;

  let output = generateFileHeader({
    fileName: `${tokenClassName}.swift`,
    commentStyle: 'line',
    platform: 'ios',
    brand: brandPascal,
    context: `Component: ${componentName}\nAggregated component tokens with all modes`
  });

  output += `
import SwiftUI

/// ${brandPascal} ${componentName} Design Tokens
///
/// Usage:
///   ${tokenClassName}.Colors.light.primaryBgIdle
///   ${tokenClassName}.Sizing.compact.height
///   ${tokenClassName}.Density.current(for: theme.density).contentGap
public enum ${tokenClassName} {
`;

  // Colors section
  if (hasColorTokens) {
    const colorTokenNames = new Map();
    [...tokenGroups.colors.light, ...tokenGroups.colors.dark].forEach(t => {
      if (!colorTokenNames.has(t.name)) {
        colorTokenNames.set(t.name, { type: t.type, value: t.value });
      }
    });

    // Brand-prefixed protocol name
    const colorProtocolName = `${brandPascal}${componentName}ColorTokens`;

    output += `
    // MARK: - Colors

    /// Color tokens protocol
    public protocol ${colorProtocolName}: Sendable {
`;
    colorTokenNames.forEach((info, name) => {
      output += `        var ${name}: ${info.type} { get }\n`;
    });
    output += `    }

    /// Color scheme accessor
    public enum Colors {
        /// Returns color tokens for the specified theme mode
        public static func current(isDark: Bool) -> any ${colorProtocolName} {
            isDark ? Dark.shared : Light.shared
        }

        public static var light: Light { Light.shared }
        public static var dark: Dark { Dark.shared }
`;

    if (tokenGroups.colors.light.length > 0) {
      output += `
        public struct Light: ${colorProtocolName} {
            public static let shared = Light()
            private init() {}
`;
      tokenGroups.colors.light.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }

    if (tokenGroups.colors.dark.length > 0) {
      output += `
        public struct Dark: ${colorProtocolName} {
            public static let shared = Dark()
            private init() {}
`;
      tokenGroups.colors.dark.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  // Sizing section (excluding tokens in density matrix)
  if (hasSizingTokens) {
    const sizingTokenNames = new Map();
    [...filteredSizing.compact, ...filteredSizing.regular].forEach(t => {
      if (!sizingTokenNames.has(t.name)) {
        sizingTokenNames.set(t.name, { type: t.type, value: t.value });
      }
    });

    // Brand-prefixed protocol name
    const sizingProtocolName = `${brandPascal}${componentName}SizingTokens`;

    output += `
    // MARK: - Sizing

    /// Sizing tokens protocol
    public protocol ${sizingProtocolName}: Sendable {
`;
    sizingTokenNames.forEach((info, name) => {
      output += `        var ${name}: ${info.type} { get }\n`;
    });
    output += `    }

    /// Size class accessor
    public enum Sizing {
        /// Returns sizing tokens for the specified size class
        public static func current(for sizeClass: SizeClass) -> any ${sizingProtocolName} {
            sizeClass == .compact ? Compact.shared : Regular.shared
        }

        public static var compact: Compact { Compact.shared }
        public static var regular: Regular { Regular.shared }
`;

    if (filteredSizing.compact.length > 0) {
      output += `
        public struct Compact: ${sizingProtocolName} {
            public static let shared = Compact()
            private init() {}
`;
      filteredSizing.compact.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }

    if (filteredSizing.regular.length > 0) {
      output += `
        public struct Regular: ${sizingProtocolName} {
            public static let shared = Regular()
            private init() {}
`;
      filteredSizing.regular.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  // Density section with SizeClass Ã— Density resolution (if matrix available)
  if (hasMatrixDensityTokens) {
    // Generate Density section with SizeClass Ã— Density matrix
    const matrixTokens = Object.entries(componentDensityMatrix);

    // Helper to determine Swift type from value
    const getSwiftType = (value, tokenName) => {
      if (typeof value === 'number') {
        if (tokenName.toLowerCase().includes('fontsize') || tokenName.toLowerCase().includes('lineheight')) {
          return 'CGFloat';
        }
        return 'CGFloat';
      }
      return 'CGFloat';
    };

    // Collect token info for protocol
    const tokenInfo = new Map();
    matrixTokens.forEach(([name, data]) => {
      const sampleValue = data.values.sm?.default ?? data.values.xs?.default ?? 0;
      tokenInfo.set(name, getSwiftType(sampleValue, name));
    });

    // Brand-prefixed protocol name
    const densityProtocolName = `${brandPascal}${componentName}DensityTokens`;

    output += `
    // MARK: - Density (SizeClass Ã— Density Matrix)

    /// Density tokens protocol (SizeClass Ã— Density resolved)
    public protocol ${densityProtocolName}: Sendable {
`;
    tokenInfo.forEach((type, name) => {
      output += `        var ${name}: ${type} { get }\n`;
    });
    output += `    }

    /// Density accessor with SizeClass Ã— Density resolution
    public enum DensityAccessor {
        /// Returns density tokens resolved by SizeClass Ã— DensityMode
        public static func current(for sizeClass: SizeClass, density: Density) -> any ${densityProtocolName} {
            switch (sizeClass, density) {
            case (.compact, .dense): return CompactDense.shared
            case (.compact, .default): return CompactDefault.shared
            case (.compact, .spacious): return CompactSpacious.shared
            case (.regular, .dense): return RegularDense.shared
            case (.regular, .default): return RegularDefault.shared
            case (.regular, .spacious): return RegularSpacious.shared
            }
        }
`;

    // iOS SizeClass mapping: compactâ†’sm, regularâ†’lg
    const iosSizeClassMap = {
      Compact: 'sm',
      Regular: 'lg'
    };
    const densityModes = ['Dense', 'Default', 'Spacious'];
    const densityModeKeys = { Dense: 'dense', Default: 'default', Spacious: 'spacious' };

    // Generate 6 structs (2 SizeClasses Ã— 3 DensityModes)
    for (const [sizeClassName, breakpointKey] of Object.entries(iosSizeClassMap)) {
      for (const densityMode of densityModes) {
        const structName = `${sizeClassName}${densityMode}`;
        const densityKey = densityModeKeys[densityMode];

        output += `
        public struct ${structName}: ${densityProtocolName} {
            public static let shared = ${structName}()
            private init() {}
`;
        matrixTokens.forEach(([tokenName, tokenData]) => {
          const value = tokenData.values[breakpointKey]?.[densityKey] ?? tokenData.values.xs?.[densityKey] ?? 0;
          output += `            public let ${tokenName}: CGFloat = ${value}\n`;
        });
        output += `        }\n`;
      }
    }
    output += `    }\n`;
  } else if (hasDensityTokens) {
    // Fallback: density-only resolution
    const densityTokenNames = new Map();
    [...tokenGroups.density.dense, ...tokenGroups.density.default, ...tokenGroups.density.spacious].forEach(t => {
      if (!densityTokenNames.has(t.name)) {
        densityTokenNames.set(t.name, { type: t.type, value: t.value });
      }
    });

    // Brand-prefixed protocol name
    const densityFallbackProtocolName = `${brandPascal}${componentName}DensityTokens`;

    output += `
    // MARK: - Density

    /// Density tokens protocol
    public protocol ${densityFallbackProtocolName}: Sendable {
`;
    densityTokenNames.forEach((info, name) => {
      output += `        var ${name}: ${info.type} { get }\n`;
    });
    output += `    }

    /// Density accessor
    public enum DensityMode {
        /// Returns density tokens for the specified density mode
        public static func current(for density: Density) -> any ${densityFallbackProtocolName} {
            switch density {
            case .dense: return Dense.shared
            case .default: return Default.shared
            case .spacious: return Spacious.shared
            }
        }

        public static var dense: Dense { Dense.shared }
        public static var \`default\`: Default { Default.shared }
        public static var spacious: Spacious { Spacious.shared }
`;

    if (tokenGroups.density.dense.length > 0) {
      output += `
        public struct Dense: ${densityFallbackProtocolName} {
            public static let shared = Dense()
            private init() {}
`;
      tokenGroups.density.dense.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }

    if (tokenGroups.density.default.length > 0) {
      output += `
        public struct Default: ${densityFallbackProtocolName} {
            public static let shared = Default()
            private init() {}
`;
      tokenGroups.density.default.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }

    if (tokenGroups.density.spacious.length > 0) {
      output += `
        public struct Spacious: ${densityFallbackProtocolName} {
            public static let shared = Spacious()
            private init() {}
`;
      tokenGroups.density.spacious.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  // Typography section
  if (hasTypographyTokens) {
    const typographyTokenNames = new Map();
    [...tokenGroups.typography.compact, ...tokenGroups.typography.regular].forEach(t => {
      if (!typographyTokenNames.has(t.name)) {
        typographyTokenNames.set(t.name, { type: t.type, value: t.value });
      }
    });

    // Brand-prefixed protocol name
    const typographyProtocolName = `${brandPascal}${componentName}TypographyTokens`;

    output += `
    // MARK: - Typography

    /// Typography tokens protocol
    public protocol ${typographyProtocolName}: Sendable {
`;
    typographyTokenNames.forEach((info, name) => {
      output += `        var ${name}: ${info.type} { get }\n`;
    });
    output += `    }

    /// Typography accessor
    public enum Typography {
        /// Returns typography tokens for the specified size class
        public static func current(for sizeClass: SizeClass) -> any ${typographyProtocolName} {
            sizeClass == .compact ? Compact.shared : Regular.shared
        }

        public static var compact: Compact { Compact.shared }
        public static var regular: Regular { Regular.shared }
`;

    if (tokenGroups.typography.compact.length > 0) {
      output += `
        public struct Compact: ${typographyProtocolName} {
            public static let shared = Compact()
            private init() {}
`;
      tokenGroups.typography.compact.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }

    if (tokenGroups.typography.regular.length > 0) {
      output += `
        public struct Regular: ${typographyProtocolName} {
            public static let shared = Regular()
            private init() {}
`;
      tokenGroups.typography.regular.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  // Effects section
  if (hasEffectsTokens) {
    const effectsTokenNames = new Map();
    [...tokenGroups.effects.light, ...tokenGroups.effects.dark].forEach(t => {
      if (!effectsTokenNames.has(t.name)) {
        effectsTokenNames.set(t.name, { type: t.type, value: t.value });
      }
    });

    // Brand-prefixed protocol name
    const effectsProtocolName = `${brandPascal}${componentName}EffectsTokens`;

    output += `
    // MARK: - Effects

    /// Effects tokens protocol
    public protocol ${effectsProtocolName}: Sendable {
`;
    effectsTokenNames.forEach((info, name) => {
      output += `        var ${name}: ${info.type} { get }\n`;
    });
    output += `    }

    /// Effects accessor
    public enum Effects {
        /// Returns effects tokens for the specified theme mode
        public static func current(isDark: Bool) -> any ${effectsProtocolName} {
            isDark ? Dark.shared : Light.shared
        }

        public static var light: Light { Light.shared }
        public static var dark: Dark { Dark.shared }
`;

    if (tokenGroups.effects.light.length > 0) {
      output += `
        public struct Light: ${effectsProtocolName} {
            public static let shared = Light()
            private init() {}
`;
      tokenGroups.effects.light.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }

    if (tokenGroups.effects.dark.length > 0) {
      output += `
        public struct Dark: ${effectsProtocolName} {
            public static let shared = Dark()
            private init() {}
`;
      tokenGroups.effects.dark.forEach(t => {
        output += `            public let ${t.name}: ${t.type} = ${t.value}\n`;
      });
      output += `        }\n`;
    }
    output += `    }\n`;
  }

  output += `}
`;

  return output;
}

/**
 * Cleans up individual SwiftUI component files after aggregation
 */
async function cleanupSwiftUIIndividualComponentFiles() {
  if (!SWIFTUI_ENABLED) {
    return { cleaned: 0 };
  }

  console.log('ðŸ§¹ Cleaning up individual SwiftUI component files...');

  let cleaned = 0;

  const iosDir = path.join(IOS_DIST_DIR, 'brands');

  if (!fs.existsSync(iosDir)) {
    return { cleaned: 0 };
  }

  for (const brand of BRANDS) {
    const brandComponentsDir = path.join(iosDir, brand, 'components');

    if (!fs.existsSync(brandComponentsDir)) {
      continue;
    }

    const componentDirs = fs.readdirSync(brandComponentsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .filter(dirent => !dirent.name.startsWith('.') && !dirent.name.startsWith('_'))
      .map(dirent => dirent.name);

    for (const componentName of componentDirs) {
      const componentDir = path.join(brandComponentsDir, componentName);
      // Filter out aggregated token files (brand-prefixed: BildButtonTokens.swift, etc.)
      const swiftFiles = fs.readdirSync(componentDir)
        .filter(f => f.endsWith('.swift') && !f.match(/^[A-Z][a-z]+[A-Z].*Tokens\.swift$/));

      // Only delete individual files if aggregated file exists (brand-prefixed)
      const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
      const aggregatedFile = path.join(componentDir, `${brandPascal}${componentName}Tokens.swift`);
      if (fs.existsSync(aggregatedFile)) {
        for (const file of swiftFiles) {
          fs.unlinkSync(path.join(componentDir, file));
          cleaned++;
        }
      }
    }
  }

  console.log(`  ðŸ“Š Cleaned: ${cleaned} individual files\n`);
  return { cleaned };
}

/**
 * Generates Theme Provider files for each brand
 * Creates: dist/compose/brands/{brand}/theme/{Brand}Theme.kt
 */
async function generateComposeThemeProviders() {
  if (!COMPOSE_ENABLED) {
    return { totalThemes: 0, successfulThemes: 0 };
  }

  console.log('ðŸŽ¨ Generating Compose Theme Providers...');

  let totalThemes = 0;
  let successfulThemes = 0;

  const composeDir = path.join(ANDROID_DIST_DIR, 'brands');
  const sharedDir = path.join(ANDROID_DIST_DIR, 'shared');

  if (!fs.existsSync(composeDir)) {
    console.log('  âš ï¸  No Compose output found, skipping theme generation');
    return { totalThemes: 0, successfulThemes: 0 };
  }

  // Generate shared files (brand-independent) - Dual-Axis Architecture
  if (fs.existsSync(sharedDir)) {
    // Density.kt
    const densityContent = generateSharedDensityFile();
    const densityFile = path.join(sharedDir, 'Density.kt');
    fs.writeFileSync(densityFile, densityContent, 'utf8');
    console.log('     âœ… shared/Density.kt');

    // WindowSizeClass.kt
    const windowSizeClassContent = generateSharedWindowSizeClassFile();
    const windowSizeClassFile = path.join(sharedDir, 'WindowSizeClass.kt');
    fs.writeFileSync(windowSizeClassFile, windowSizeClassContent, 'utf8');
    console.log('     âœ… shared/WindowSizeClass.kt');

    // ColorBrand.kt (Dual-Axis: color palette axis)
    const colorBrandContent = generateColorBrandEnumFile();
    const colorBrandFile = path.join(sharedDir, 'ColorBrand.kt');
    fs.writeFileSync(colorBrandFile, colorBrandContent, 'utf8');
    console.log('     âœ… shared/ColorBrand.kt (Dual-Axis: color palette)');

    // ContentBrand.kt (Dual-Axis: content/sizing axis)
    const contentBrandContent = generateContentBrandEnumFile();
    const contentBrandFile = path.join(sharedDir, 'ContentBrand.kt');
    fs.writeFileSync(contentBrandFile, contentBrandContent, 'utf8');
    console.log('     âœ… shared/ContentBrand.kt (Dual-Axis: content/sizing)');

    // DesignColorScheme.kt (unified interface)
    const designColorSchemeContent = generateDesignColorSchemeFile();
    const designColorSchemeFile = path.join(sharedDir, 'DesignColorScheme.kt');
    fs.writeFileSync(designColorSchemeFile, designColorSchemeContent, 'utf8');
    console.log('     âœ… shared/DesignColorScheme.kt (unified interface)');

    // DesignSizingScheme.kt (unified interface)
    const designSizingSchemeContent = generateDesignSizingSchemeFile();
    const designSizingSchemeFile = path.join(sharedDir, 'DesignSizingScheme.kt');
    fs.writeFileSync(designSizingSchemeFile, designSizingSchemeContent, 'utf8');
    console.log('     âœ… shared/DesignSizingScheme.kt (unified interface)');

    // DesignTextStyle.kt (typography composite token)
    const designTextStyleContent = generateSharedDesignTextStyleFile();
    const designTextStyleFile = path.join(sharedDir, 'DesignTextStyle.kt');
    fs.writeFileSync(designTextStyleFile, designTextStyleContent, 'utf8');
    console.log('     âœ… shared/DesignTextStyle.kt (typography composite)');

    // DesignTypographyScheme.kt (unified interface)
    const designTypographySchemeContent = generateSharedDesignTypographySchemeFile();
    const designTypographySchemeFile = path.join(sharedDir, 'DesignTypographyScheme.kt');
    fs.writeFileSync(designTypographySchemeFile, designTypographySchemeContent, 'utf8');
    console.log('     âœ… shared/DesignTypographyScheme.kt (unified interface)');

    // DropShadow.kt (shadow layer data class)
    const dropShadowContent = generateSharedDropShadowFile();
    const dropShadowFile = path.join(sharedDir, 'DropShadow.kt');
    fs.writeFileSync(dropShadowFile, dropShadowContent, 'utf8');
    console.log('     âœ… shared/DropShadow.kt (shadow layer)');

    // ShadowStyle.kt (composite shadow with toModifier)
    const shadowStyleContent = generateSharedShadowStyleFile();
    const shadowStyleFile = path.join(sharedDir, 'ShadowStyle.kt');
    fs.writeFileSync(shadowStyleFile, shadowStyleContent, 'utf8');
    console.log('     âœ… shared/ShadowStyle.kt (composite shadow)');

    // DesignEffectsScheme.kt (unified effects interface)
    const designEffectsSchemeContent = generateSharedDesignEffectsSchemeFile();
    const designEffectsSchemeFile = path.join(sharedDir, 'DesignEffectsScheme.kt');
    fs.writeFileSync(designEffectsSchemeFile, designEffectsSchemeContent, 'utf8');
    console.log('     âœ… shared/DesignEffectsScheme.kt (unified interface)');

    // DesignDensityScheme.kt (unified density interface)
    const designDensitySchemeContent = generateSharedDesignDensitySchemeFile();
    const designDensitySchemeFile = path.join(sharedDir, 'DesignDensityScheme.kt');
    fs.writeFileSync(designDensitySchemeFile, designDensitySchemeContent, 'utf8');
    console.log('     âœ… shared/DesignDensityScheme.kt (unified interface)');

    // Note: Shared Density objects (DensityDefault.kt, etc.) are now generated via
    // buildSharedDensityTokens() using Style Dictionary pipeline

    // DesignSystemTheme.kt (central theme provider with Dual-Axis)
    const designSystemThemeContent = generateDesignSystemThemeFile();
    const designSystemThemeFile = path.join(sharedDir, 'DesignSystemTheme.kt');
    fs.writeFileSync(designSystemThemeFile, designSystemThemeContent, 'utf8');
    console.log('     âœ… shared/DesignSystemTheme.kt (Dual-Axis theme provider)');

    // Remove old Brand.kt if it exists (replaced by ColorBrand + ContentBrand)
    const oldBrandFile = path.join(sharedDir, 'Brand.kt');
    if (fs.existsSync(oldBrandFile)) {
      fs.unlinkSync(oldBrandFile);
      console.log('     ðŸ—‘ï¸  Removed old shared/Brand.kt (replaced by Dual-Axis enums)');
    }

    successfulThemes = 1; // Central theme provider counts as 1
  }

  // Remove old individual brand theme files (Option 3B: single central theme provider)
  for (const brand of BRANDS) {
    const brandDir = path.join(composeDir, brand);
    const themeDir = path.join(brandDir, 'theme');

    if (fs.existsSync(themeDir)) {
      const themeFiles = fs.readdirSync(themeDir).filter(f => f.endsWith('Theme.kt'));
      for (const themeFile of themeFiles) {
        fs.unlinkSync(path.join(themeDir, themeFile));
        console.log(`     ðŸ—‘ï¸  Removed ${brand}/theme/${themeFile} (using central DesignSystemTheme)`);
      }
      // Remove empty theme directory
      if (fs.readdirSync(themeDir).length === 0) {
        fs.rmdirSync(themeDir);
      }
    }
    totalThemes++;
  }

  console.log(`  ðŸ“Š Generated: ${successfulThemes}/${totalThemes} theme providers\n`);
  return { totalThemes, successfulThemes };
}

/**
 * Generates the Theme Provider Kotlin file content
 * @param brand - Brand name (e.g., 'bild', 'sportbild', 'advertorial')
 * @param hasColors - Whether the brand has its own color tokens
 */
function generateThemeProviderFile(brand, hasColors = true) {
  const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
  const packageJson = require('../../packages/tokens/package.json');
  const version = packageJson.version;

  // For brands without colors, we need to use a shared color scheme (BildColorScheme)
  const colorImports = hasColors
    ? `import com.bild.designsystem.brands.${brand}.semantic.${brandPascal}ColorScheme
import com.bild.designsystem.brands.${brand}.semantic.${brandPascal}LightColors
import com.bild.designsystem.brands.${brand}.semantic.${brandPascal}DarkColors`
    : `// ${brandPascal} uses shared color schemes from other brands (e.g., Bild, Sportbild)
// Import the color scheme you want to use:
import com.bild.designsystem.bild.semantic.BildColorScheme
import com.bild.designsystem.bild.semantic.BildLightColors
import com.bild.designsystem.bild.semantic.BildDarkColors`;

  const colorSchemeType = hasColors ? `${brandPascal}ColorScheme` : 'BildColorScheme';
  const defaultLightColors = hasColors ? `${brandPascal}LightColors` : 'BildLightColors';
  const defaultDarkColors = hasColors ? `${brandPascal}DarkColors` : 'BildDarkColors';

  const colorInjectionNote = hasColors ? '' : `
 * Note: ${brandPascal} does not have its own color tokens.
 * Colors can be injected from other brands (Bild or Sportbild).
 * Default: Uses BildLightColors/BildDarkColors
 *`;

  let output = generateFileHeader({
    fileName: `${brandPascal}Theme.kt`,
    commentStyle: 'block',
    platform: 'android',
    brand: brandPascal,
    context: `Theme Provider\nProvides CompositionLocal-based theming for Jetpack Compose`
  });

  output += `
package com.bild.designsystem.brands.${brand}.theme`;

  return output + `

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.ReadOnlyComposable
import androidx.compose.runtime.staticCompositionLocalOf
${colorImports}
import com.bild.designsystem.brands.${brand}.semantic.${brandPascal}SizingScheme
import com.bild.designsystem.brands.${brand}.semantic.${brandPascal}SizingCompact
import com.bild.designsystem.brands.${brand}.semantic.${brandPascal}SizingRegular
import com.bild.designsystem.shared.Density
import com.bild.designsystem.shared.WindowSizeClass

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSITION LOCALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * CompositionLocal for current color scheme (Light/Dark)
 * Uses ${colorSchemeType} interface for type-safe access
 */
internal val Local${brandPascal}Colors = staticCompositionLocalOf<${colorSchemeType}> { ${defaultLightColors} }

/**
 * CompositionLocal for current size class (Compact/Regular)
 */
internal val Local${brandPascal}SizeClass = staticCompositionLocalOf { WindowSizeClass.Compact }

/**
 * CompositionLocal for current density (Dense/Default/Spacious)
 */
internal val Local${brandPascal}Density = staticCompositionLocalOf { Density.Default }

/**
 * CompositionLocal for dark theme state
 */
internal val LocalIsDarkTheme = staticCompositionLocalOf { false }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEME PROVIDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ${brandPascal} Design System Theme Provider
 *
 * Wraps content with CompositionLocals for theming.
 * All child composables can access theme values via [${brandPascal}Theme].
 *${colorInjectionNote}
 * @param darkTheme Whether to use dark color scheme
 * @param lightColors Light color scheme to use (allows color scheme injection)
 * @param darkColors Dark color scheme to use (allows color scheme injection)
 * @param sizeClass Current window size class for responsive sizing
 * @param density UI density for spacing adjustments
 * @param content Composable content to wrap
 *
 * Usage:
 * \`\`\`kotlin
 * ${brandPascal}Theme(
 *     darkTheme = isSystemInDarkTheme(),
 *     sizeClass = calculateWindowSizeClass(),
 *     density = Density.Default
 * ) {
 *     // Your app content
 *     Text(
 *         color = ${brandPascal}Theme.colors.textColorPrimary,
 *         fontSize = ${brandPascal}Theme.sizing.headline1FontSize
 *     )
 * }
 * \`\`\`
 */
@Composable
fun ${brandPascal}Theme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    lightColors: ${colorSchemeType} = ${defaultLightColors},
    darkColors: ${colorSchemeType} = ${defaultDarkColors},
    sizeClass: WindowSizeClass = WindowSizeClass.Compact,
    density: Density = Density.Default,
    content: @Composable () -> Unit
) {
    val colors = if (darkTheme) darkColors else lightColors

    CompositionLocalProvider(
        Local${brandPascal}Colors provides colors,
        Local${brandPascal}SizeClass provides sizeClass,
        Local${brandPascal}Density provides density,
        LocalIsDarkTheme provides darkTheme,
        content = content
    )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEME ACCESSOR OBJECT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Accessor object for ${brandPascal} theme values
 *
 * Provides convenient access to current theme values from any composable.
 * Values are read from CompositionLocals set by [${brandPascal}Theme].
 *
 * Usage:
 * \`\`\`kotlin
 * @Composable
 * fun MyButton() {
 *     Button(
 *         colors = ButtonDefaults.buttonColors(
 *             containerColor = ${brandPascal}Theme.colors.coreColorPrimary
 *         )
 *     ) {
 *         Text(
 *             text = "Click me",
 *             fontSize = ${brandPascal}Theme.sizing.headline1FontSize
 *         )
 *     }
 * }
 * \`\`\`
 */
object ${brandPascal}Theme {

    /**
     * Current color scheme (Light or Dark based on theme)
     * Type-safe access via ${colorSchemeType} interface
     */
    val colors: ${colorSchemeType}
        @Composable
        @ReadOnlyComposable
        get() = Local${brandPascal}Colors.current

    /**
     * Current sizing values based on WindowSizeClass
     */
    val sizing: ${brandPascal}SizingScheme
        @Composable
        @ReadOnlyComposable
        get() = when (Local${brandPascal}SizeClass.current) {
            WindowSizeClass.Compact -> ${brandPascal}SizingCompact
            WindowSizeClass.Regular -> ${brandPascal}SizingRegular
        }

    /**
     * Current window size class
     */
    val sizeClass: WindowSizeClass
        @Composable
        @ReadOnlyComposable
        get() = Local${brandPascal}SizeClass.current

    /**
     * Current UI density
     */
    val density: Density
        @Composable
        @ReadOnlyComposable
        get() = Local${brandPascal}Density.current

    /**
     * Whether dark theme is currently active
     */
    val isDarkTheme: Boolean
        @Composable
        @ReadOnlyComposable
        get() = LocalIsDarkTheme.current
}
`;
}

/**
 * Generates the shared Density enum file
 * Creates: dist/android/compose/shared/Density.kt
 */
function generateSharedDensityFile() {
  let output = generateFileHeader({
    fileName: 'Density.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `Shared Density Enum\nBrand-independent density settings for UI spacing adjustments`
  });

  output += `
package com.bild.designsystem.shared

/**
 * UI density for spacing adjustments`;

  return output + `
 *
 * Density is brand-independent and can be used across all brands.
 * Controls spacing, padding, and other density-related design tokens.
 *
 * Usage:
 * \`\`\`kotlin
 * BildTheme(
 *     density = Density.Default
 * ) {
 *     // Content with default density
 * }
 * \`\`\`
 */
enum class Density {
    /** Dense UI with reduced padding and spacing */
    Dense,
    /** Standard/default spacing */
    Default,
    /** Spacious UI with increased padding and spacing */
    Spacious
}
`;
}

/**
 * Generates the shared WindowSizeClass enum file
 * Creates: dist/android/compose/shared/WindowSizeClass.kt
 * Uses Material 3 WindowSizeClass breakpoints: Compact (<600dp), Medium (600-839dp), Expanded (â‰¥840dp)
 */
function generateSharedWindowSizeClassFile() {
  let output = generateFileHeader({
    fileName: 'WindowSizeClass.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `Shared WindowSizeClass Enum\nMaterial 3 compliant window size classification for responsive layouts`
  });

  output += `
package com.bild.designsystem.shared

/**
 * Window size class for responsive layouts (Material 3 compliant)`;

  return output + `
 *
 * WindowSizeClass is brand-independent and can be used across all brands.
 * Follows Material 3 WindowSizeClass specification:
 * - Compact: width < 600dp - Phones in portrait (maps to sm: 390px breakpoint)
 * - Medium: 600dp â‰¤ width < 840dp - Small tablets, foldables (maps to md: 600px breakpoint)
 * - Expanded: width â‰¥ 840dp - Large tablets, desktops (maps to lg: 1024px breakpoint)
 *
 * Usage:
 * \`\`\`kotlin
 * DesignSystemTheme(
 *     sizeClass = WindowSizeClass.Compact
 * ) {
 *     // Content with compact sizing tokens
 * }
 * \`\`\`
 *
 * Integration with AndroidX WindowSizeClass:
 * \`\`\`kotlin
 * val windowSizeClass = calculateWindowSizeClass(activity)
 * val sizeClass = when (windowSizeClass.widthSizeClass) {
 *     WindowWidthSizeClass.Compact -> WindowSizeClass.Compact
 *     WindowWidthSizeClass.Medium -> WindowSizeClass.Medium
 *     WindowWidthSizeClass.Expanded -> WindowSizeClass.Expanded
 * }
 * \`\`\`
 *
 * @see <a href="https://developer.android.com/develop/ui/compose/layouts/adaptive/use-window-size-classes">Material 3 Window Size Classes</a>
 */
enum class WindowSizeClass {
    /** Phones in portrait mode (width < 600dp, maps to sm: 390px breakpoint) */
    Compact,
    /** Small tablets, foldables in portrait (600dp â‰¤ width < 840dp, maps to md: 600px breakpoint) */
    Medium,
    /** Large tablets, desktops (width â‰¥ 840dp, maps to lg: 1024px breakpoint) */
    Expanded
}
`;
}

/**
 * Generates the ColorBrand enum file (Dual-Axis Architecture)
 * Creates: dist/android/compose/shared/ColorBrand.kt
 * Only brands with their own color tokens (bild, sportbild)
 */
function generateColorBrandEnumFile() {
  const brandEntries = COLOR_BRANDS.map(brand => {
    const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
    return `    /** ${brandPascal} color palette */
    ${brandPascal}`;
  }).join(',\n');

  let output = generateFileHeader({
    fileName: 'ColorBrand.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `ColorBrand Enum (Dual-Axis Architecture)\nDefines the color palette axis - only brands with their own color tokens`
  });

  output += `
package com.bild.designsystem.shared

/**
 * Color brands in the BILD Design System`;

  return output + `
 *
 * Determines which color palette to use. Only brands with their own
 * color tokens are included. Advertorial uses colors from BILD or SportBILD.
 *
 * Usage:
 * \`\`\`kotlin
 * DesignSystemTheme(
 *     colorBrand = ColorBrand.Bild,        // Use BILD colors
 *     contentBrand = ContentBrand.Advertorial,  // Use Advertorial sizing
 *     darkTheme = isSystemInDarkTheme()
 * ) {
 *     // Advertorial content with BILD colors
 * }
 * \`\`\`
 */
enum class ColorBrand {
${brandEntries}
}
`;
}

/**
 * Generates the ContentBrand enum file (Dual-Axis Architecture)
 * Creates: dist/android/compose/shared/ContentBrand.kt
 * All brands including those without own colors (advertorial)
 */
function generateContentBrandEnumFile() {
  const brandEntries = CONTENT_BRANDS.map(brand => {
    const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
    const hasColors = COLOR_BRANDS.includes(brand);
    const note = hasColors ? '' : ' (uses ColorBrand for colors)';
    return `    /** ${brandPascal} content/sizing${note} */
    ${brandPascal}`;
  }).join(',\n');

  let output = generateFileHeader({
    fileName: 'ContentBrand.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `ContentBrand Enum (Dual-Axis Architecture)\nDefines the content axis - sizing, typography, and layout tokens`
  });

  output += `
package com.bild.designsystem.shared

/**
 * Content brands in the BILD Design System`;

  return output + `
 *
 * Determines which sizing, typography, and layout tokens to use.
 * All brands are included, even those without their own color tokens.
 *
 * Note: Advertorial uses ColorBrand for colors but has its own sizing tokens.
 *
 * Usage:
 * \`\`\`kotlin
 * DesignSystemTheme(
 *     colorBrand = ColorBrand.Sportbild,   // Use SportBILD colors
 *     contentBrand = ContentBrand.Advertorial,  // Use Advertorial sizing
 *     darkTheme = isSystemInDarkTheme()
 * ) {
 *     // Advertorial content with SportBILD colors
 * }
 * \`\`\`
 */
enum class ContentBrand {
${brandEntries}
}
`;
}

/**
 * Generates the unified DesignColorScheme interface
 * Creates: dist/android/compose/shared/DesignColorScheme.kt
 * All color brands implement this interface for polymorphic color access
 */
function generateDesignColorSchemeFile() {
  // Read color properties from existing BildColorScheme to ensure consistency
  const bildColorsPath = path.join(ANDROID_DIST_DIR, 'brands', 'bild', 'semantic', 'color', 'ColorsLight.kt');
  let colorProperties = [];

  if (fs.existsSync(bildColorsPath)) {
    const content = fs.readFileSync(bildColorsPath, 'utf8');
    // Extract interface properties (handles both "interface X {" and "interface X : Y {")
    const interfaceMatch = content.match(/interface \w+ColorScheme[^{]*\{([^}]+)\}/s);
    if (interfaceMatch) {
      const propsMatch = interfaceMatch[1].matchAll(/val\s+(\w+):\s*Color/g);
      for (const match of propsMatch) {
        colorProperties.push(match[1]);
      }
    }
  }

  // Fallback to essential properties if file not found
  if (colorProperties.length === 0) {
    colorProperties = [
      'textColorPrimary', 'textColorSecondary', 'textColorMuted', 'textColorAccent',
      'surfaceColorPrimary', 'surfaceColorSecondary', 'surfaceColorTertiary',
      'borderColorLowContrast', 'borderColorMediumContrast', 'borderColorHighContrast',
      'coreColorPrimary', 'coreColorSecondary', 'coreColorTertiary'
    ];
  }

  const propertyDeclarations = colorProperties.map(prop => `    val ${prop}: Color`).join('\n');

  let output = generateFileHeader({
    fileName: 'DesignColorScheme.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `Unified DesignColorScheme Interface (Dual-Axis Architecture)\nAll color brands implement this interface for polymorphic color access`
  });

  output += `
package com.bild.designsystem.shared

import androidx.compose.runtime.Stable
import androidx.compose.ui.graphics.Color

/**
 * Unified color scheme interface for the BILD Design System`;

  return output + `
 *
 * All color brands (BILD, SportBILD) implement this interface,
 * enabling polymorphic color access across brands.
 *
 * This follows the Dual-Axis Architecture:
 * - ColorBrand axis: Determines which color palette (BILD or SportBILD)
 * - ContentBrand axis: Determines sizing/typography (BILD, SportBILD, or Advertorial)
 *
 * Usage:
 * \`\`\`kotlin
 * @Composable
 * fun MyComponent() {
 *     val colors: DesignColorScheme = DesignSystemTheme.colors
 *     Text(
 *         text = "Hello",
 *         color = colors.textColorPrimary
 *     )
 * }
 * \`\`\`
 */
@Stable
interface DesignColorScheme {
${propertyDeclarations}
}
`;
}

/**
 * Generates the unified DesignSizingScheme interface
 * Creates: dist/android/compose/shared/DesignSizingScheme.kt
 */
function generateDesignSizingSchemeFile() {
  // Read sizing properties from existing BildSizingScheme
  const bildSizingPath = path.join(ANDROID_DIST_DIR, 'brands', 'bild', 'semantic', 'sizeclass', 'SizingCompact.kt');
  let sizingProperties = [];

  if (fs.existsSync(bildSizingPath)) {
    const content = fs.readFileSync(bildSizingPath, 'utf8');
    // Extract interface properties (handles both "interface X {" and "interface X : Y {")
    const interfaceMatch = content.match(/interface \w+SizingScheme[^{]*\{([^}]+)\}/s);
    if (interfaceMatch) {
      const propsMatch = interfaceMatch[1].matchAll(/val\s+(\w+):\s*(\w+)/g);
      for (const match of propsMatch) {
        sizingProperties.push({ name: match[1], type: match[2] });
      }
    }
  }

  // Fallback to essential properties
  if (sizingProperties.length === 0) {
    sizingProperties = [
      { name: 'gridSpaceRespBase', type: 'Dp' },
      { name: 'gridSpaceRespSm', type: 'Dp' },
      { name: 'gridSpaceRespLg', type: 'Dp' },
      { name: 'pageInlineSpace', type: 'Dp' },
      { name: 'sectionSpaceBase', type: 'Dp' }
    ];
  }

  const propertyDeclarations = sizingProperties.map(prop => `    val ${prop.name}: ${prop.type}`).join('\n');

  let output = generateFileHeader({
    fileName: 'DesignSizingScheme.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `Unified DesignSizingScheme Interface (Dual-Axis Architecture)\nAll content brands implement this interface for polymorphic sizing access`
  });

  return output + `
package com.bild.designsystem.shared

import androidx.compose.runtime.Stable
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.TextUnit

/**
 * Unified sizing scheme interface for the BILD Design System
 *
 * All content brands (BILD, SportBILD, Advertorial) implement this interface,
 * enabling polymorphic sizing access across brands.
 */
@Stable
interface DesignSizingScheme {
${propertyDeclarations}
}
`;
}

/**
 * Generates the shared DesignTextStyle data class
 * Creates: dist/android/compose/shared/DesignTextStyle.kt
 */
function generateSharedDesignTextStyleFile() {
  let output = generateFileHeader({
    fileName: 'DesignTextStyle.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `DesignTextStyle - Typography composite token\nRepresents a complete text style with all typography properties`
  });

  return output + `
package com.bild.designsystem.shared

import androidx.compose.runtime.Immutable
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.Font
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.unit.TextUnit
import androidx.compose.ui.unit.sp

/**
 * Text case transformation options
 */
enum class DesignTextCase {
    Original,
    Uppercase,
    Lowercase,
    Capitalize
}

/**
 * Design System TextStyle composite token
 *
 * Contains all typography properties for a complete text style.
 * Use [toComposeTextStyle] to convert to Compose's TextStyle with font resolution.
 *
 * Usage:
 * \`\`\`kotlin
 * val style = DesignSystemTheme.typography.headline1
 * Text(
 *     text = "Hello",
 *     style = style.toComposeTextStyle(fontResolver)
 * )
 * \`\`\`
 */
@Immutable
data class DesignTextStyle(
    val fontFamily: String,
    val fontWeight: FontWeight,
    val fontSize: TextUnit,
    val lineHeight: TextUnit,
    val letterSpacing: TextUnit = 0.sp,
    val textCase: DesignTextCase = DesignTextCase.Original,
    val textDecoration: TextDecoration = TextDecoration.None
) {
    /**
     * Converts this DesignTextStyle to Compose's TextStyle
     *
     * @param fontResolver A function that resolves font family name to FontFamily
     *                     Example: { name -> FontFamily(Font(R.font.gotham_xnarrow)) }
     * @return A Compose TextStyle ready for use with Text composable
     */
    fun toComposeTextStyle(fontResolver: (String) -> FontFamily = { FontFamily.Default }): TextStyle {
        return TextStyle(
            fontFamily = fontResolver(fontFamily),
            fontWeight = fontWeight,
            fontSize = fontSize,
            lineHeight = lineHeight,
            letterSpacing = letterSpacing,
            textDecoration = textDecoration
        )
    }

    /**
     * Converts this DesignTextStyle to Compose's TextStyle using default system fonts
     */
    fun toComposeTextStyle(): TextStyle = toComposeTextStyle { FontFamily.Default }
}
`;
}

/**
 * Generates the shared DesignTypographyScheme interface
 * Creates: dist/android/compose/shared/DesignTypographyScheme.kt
 */
function generateSharedDesignTypographySchemeFile() {
  // Read typography properties from existing BildTypographyScheme
  const bildTypographyPath = path.join(ANDROID_DIST_DIR, 'brands', 'bild', 'semantic', 'typography', 'TypographyCompact.kt');
  let typographyProperties = [];

  if (fs.existsSync(bildTypographyPath)) {
    const content = fs.readFileSync(bildTypographyPath, 'utf8');
    // Extract interface properties
    const interfaceMatch = content.match(/interface \w+TypographyScheme[^{]*\{([^}]+)\}/s);
    if (interfaceMatch) {
      const propsMatch = interfaceMatch[1].matchAll(/(?:\/\*\*[^*]*\*\/\s*)?(?:override\s+)?val\s+(\w+):\s*DesignTextStyle/g);
      for (const match of propsMatch) {
        typographyProperties.push(match[1]);
      }
    }
  }

  // Fallback to essential properties
  if (typographyProperties.length === 0) {
    typographyProperties = [
      'display1', 'display2', 'display3',
      'headline1', 'headline2', 'headline3', 'headline4',
      'body', 'bodyBold',
      'label1', 'label2', 'label3'
    ];
  }

  const propertyDeclarations = typographyProperties.map(prop => `    val ${prop}: DesignTextStyle`).join('\n');

  let output = generateFileHeader({
    fileName: 'DesignTypographyScheme.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `Unified DesignTypographyScheme Interface (Dual-Axis Architecture)\nAll content brands implement this interface for polymorphic typography access`
  });

  return output + `
package com.bild.designsystem.shared

import androidx.compose.runtime.Stable

/**
 * Unified typography scheme interface for the BILD Design System
 *
 * All content brands (BILD, SportBILD, Advertorial) implement this interface,
 * enabling polymorphic typography access across brands.
 *
 * Usage:
 * \`\`\`kotlin
 * @Composable
 * fun MyComponent() {
 *     val typography: DesignTypographyScheme = DesignSystemTheme.typography
 *     Text(
 *         text = "Hello",
 *         style = typography.headline1.toComposeTextStyle()
 *     )
 * }
 * \`\`\`
 */
@Stable
interface DesignTypographyScheme {
${propertyDeclarations}
}
`;
}

/**
 * Generates the shared DropShadow data class
 * Creates: dist/android/compose/shared/DropShadow.kt
 */
function generateSharedDropShadowFile() {
  let output = generateFileHeader({
    fileName: 'DropShadow.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `DropShadow - Single shadow layer definition`
  });

  return output + `
package com.bild.designsystem.shared

import androidx.compose.runtime.Immutable
import androidx.compose.ui.graphics.Color

/**
 * Single drop shadow definition
 *
 * Represents one layer of a shadow effect with all properties needed
 * for rendering in Jetpack Compose.
 *
 * @property color Shadow color (including alpha)
 * @property offsetX Horizontal offset in pixels
 * @property offsetY Vertical offset in pixels
 * @property blur Blur radius in pixels
 * @property spread Spread radius in pixels (expansion/contraction)
 */
@Immutable
data class DropShadow(
    val color: Color,
    val offsetX: Float,
    val offsetY: Float,
    val blur: Float,
    val spread: Float = 0f
)
`;
}

/**
 * Generates the shared ShadowStyle composite class
 * Creates: dist/android/compose/shared/ShadowStyle.kt
 */
function generateSharedShadowStyleFile() {
  let output = generateFileHeader({
    fileName: 'ShadowStyle.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `ShadowStyle - Composite shadow token (multiple layers)`
  });

  return output + `
package com.bild.designsystem.shared

import androidx.compose.runtime.Immutable
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Paint
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.unit.dp

/**
 * Composite shadow style containing multiple shadow layers
 *
 * Usage:
 * \`\`\`kotlin
 * Box(
 *     modifier = Modifier
 *         .then(DesignSystemTheme.effects.shadowSoftMd.toModifier())
 *         .background(Color.White)
 * )
 * \`\`\`
 */
@Immutable
data class ShadowStyle(
    val layers: List<DropShadow>
) {
    constructor(vararg shadows: DropShadow) : this(shadows.toList())

    /**
     * Converts this ShadowStyle to a Compose Modifier
     *
     * Applies all shadow layers using drawBehind with native shadow rendering.
     * Note: For best results, apply this modifier before background modifiers.
     *
     * @return A Modifier that renders all shadow layers
     */
    fun toModifier(): Modifier = Modifier.drawBehind {
        layers.forEach { shadow ->
            drawIntoCanvas { canvas ->
                val paint = Paint().apply {
                    color = shadow.color
                    asFrameworkPaint().apply {
                        setShadowLayer(
                            shadow.blur,
                            shadow.offsetX,
                            shadow.offsetY,
                            shadow.color.toArgb()
                        )
                    }
                }
                // Draw a rect slightly larger than the content to show the shadow
                canvas.drawRect(
                    left = -shadow.spread,
                    top = -shadow.spread,
                    right = size.width + shadow.spread,
                    bottom = size.height + shadow.spread,
                    paint = paint
                )
            }
        }
    }
}
`;
}

/**
 * Generates the shared DesignEffectsScheme interface
 * Creates: dist/android/compose/shared/DesignEffectsScheme.kt
 */
function generateSharedDesignEffectsSchemeFile() {
  let output = generateFileHeader({
    fileName: 'DesignEffectsScheme.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `Unified DesignEffectsScheme Interface\nBrand-independent: shadows only depend on light/dark mode`
  });

  return output + `
package com.bild.designsystem.shared

import androidx.compose.runtime.Stable

/**
 * Unified effects scheme interface for the BILD Design System
 *
 * Effects (shadows) are brand-independent and only vary by color mode (light/dark).
 * This interface is implemented by EffectsLight and EffectsDark.
 *
 * Usage:
 * \`\`\`kotlin
 * @Composable
 * fun MyCard() {
 *     val effects = DesignSystemTheme.effects
 *     Box(
 *         modifier = Modifier
 *             .then(effects.shadowSoftMd.toModifier())
 *             .background(Color.White)
 *     )
 * }
 * \`\`\`
 */
@Stable
interface DesignEffectsScheme {
    /** Soft shadow - Small: Subtle surface separation */
    val shadowSoftSm: ShadowStyle
    /** Soft shadow - Medium: Cards, sheets */
    val shadowSoftMd: ShadowStyle
    /** Soft shadow - Large: Elevated cards */
    val shadowSoftLg: ShadowStyle
    /** Soft shadow - Extra Large: Prominent elevation */
    val shadowSoftXl: ShadowStyle
    /** Hard shadow - Small: Subtle focus */
    val shadowHardSm: ShadowStyle
    /** Hard shadow - Medium: Dropdowns, menus */
    val shadowHardMd: ShadowStyle
    /** Hard shadow - Large: Dialogs, modals */
    val shadowHardLg: ShadowStyle
    /** Hard shadow - Extra Large: Overlays */
    val shadowHardXl: ShadowStyle
}
`;
}

/**
 * Generates the shared DesignDensityScheme interface dynamically
 * Creates: dist/android/compose/shared/DesignDensityScheme.kt
 *
 * Reads token names from the source JSON to ensure scalability.
 * New tokens added in Figma will automatically appear in the interface.
 */
function generateSharedDesignDensitySchemeFile() {
  // Read density tokens from source JSON for dynamic interface generation
  const densitySourcePath = path.join(TOKENS_DIR, 'brands', 'bild', 'density', 'density-default.json');
  let interfaceProperties = '';

  if (fs.existsSync(densitySourcePath)) {
    const densityData = JSON.parse(fs.readFileSync(densitySourcePath, 'utf8'));
    const tokens = [];

    // Recursively extract all token names from the JSON structure
    function extractTokens(obj, prefix = '') {
      for (const [key, value] of Object.entries(obj)) {
        if (value && typeof value === 'object') {
          if (value.$type === 'dimension' || value.type === 'float') {
            // This is a token - extract the key name
            tokens.push(key);
          } else {
            // Recurse into nested objects
            extractTokens(value, prefix ? `${prefix}.${key}` : key);
          }
        }
      }
    }

    extractTokens(densityData);

    // Group tokens by type (constant vs responsive)
    const constantTokens = tokens.filter(t => t.includes('Const'));
    const responsiveTokens = tokens.filter(t => !t.includes('Const'));

    // Group responsive tokens by breakpoint
    const breakpoints = ['Xs', 'Sm', 'Md', 'Lg'];
    const respByBreakpoint = {};
    breakpoints.forEach(bp => {
      respByBreakpoint[bp] = responsiveTokens.filter(t => t.startsWith(`density${bp}`));
    });

    // Generate constant properties
    if (constantTokens.length > 0) {
      interfaceProperties += '    // Constant spacing (breakpoint-independent)\n';
      constantTokens.forEach(token => {
        interfaceProperties += `    val ${token}: Dp\n`;
      });
    }

    // Generate responsive properties grouped by breakpoint
    if (responsiveTokens.length > 0) {
      interfaceProperties += '\n    // Responsive spacing (per breakpoint)\n';
      breakpoints.forEach(bp => {
        const bpTokens = respByBreakpoint[bp];
        if (bpTokens.length > 0) {
          interfaceProperties += `    // ${bp.toUpperCase()} breakpoint\n`;
          bpTokens.forEach(token => {
            interfaceProperties += `    val ${token}: Dp\n`;
          });
        }
      });
    }
  } else {
    // Fallback: minimal interface if source not found
    console.warn('Density source JSON not found, using minimal interface');
    interfaceProperties = '    // No density tokens found\n';
  }

  let output = generateFileHeader({
    fileName: 'DesignDensityScheme.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `Unified DesignDensityScheme Interface\nSemantic density tokens for spacing adjustments`
  });

  return output + `
package com.bild.designsystem.shared

import androidx.compose.runtime.Stable
import androidx.compose.ui.unit.Dp

/**
 * Unified density scheme interface for the BILD Design System
 *
 * Internal semantic density tokens (Global/StackSpace) that vary by density mode.
 * This interface is implemented by DensityDefault, DensityDense, DensitySpacious.
 *
 * NOTE: Do not use densitySpacing directly. Use the BreakpointMode resolver properties:
 * \`\`\`kotlin
 * @Composable
 * fun MyLayout() {
 *     // Use BreakpointMode token names - automatically resolve by WindowSizeClass & Density
 *     val spacing = DesignSystemTheme.stackSpaceRespMd  // NOT densitySpacing.density...
 *     Column(
 *         verticalArrangement = Arrangement.spacedBy(spacing)
 *     ) {
 *         // Content
 *     }
 * }
 * \`\`\`
 */
@Stable
interface DesignDensityScheme {
${interfaceProperties}}
`;
}

/**
 * Generates the central DesignSystemTheme file with Dual-Axis Architecture
 * Creates: dist/android/compose/shared/DesignSystemTheme.kt
 */
function generateDesignSystemThemeFile() {
  // Generate color imports for all color brands
  // Files are in semantic/color/ directory so package includes .color
  const colorImports = COLOR_BRANDS.map(brand => {
    const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
    return `import com.bild.designsystem.brands.${brand}.semantic.color.${brandPascal}LightColors
import com.bild.designsystem.brands.${brand}.semantic.color.${brandPascal}DarkColors`;
  }).join('\n');

  // Generate sizing imports for all content brands (Material 3: Compact, Medium, Expanded)
  // Files are in semantic/sizeclass/ directory so package includes .sizeclass
  const sizingImports = CONTENT_BRANDS.map(brand => {
    const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
    return `import com.bild.designsystem.brands.${brand}.semantic.sizeclass.${brandPascal}SizingCompact
import com.bild.designsystem.brands.${brand}.semantic.sizeclass.${brandPascal}SizingMedium
import com.bild.designsystem.brands.${brand}.semantic.sizeclass.${brandPascal}SizingExpanded`;
  }).join('\n');

  // Generate typography imports for all content brands (Material 3: Compact, Medium, Expanded)
  // Files are in semantic/typography/ directory so package includes .typography
  const typographyImports = CONTENT_BRANDS.map(brand => {
    const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
    return `import com.bild.designsystem.brands.${brand}.semantic.typography.${brandPascal}TypographyCompact
import com.bild.designsystem.brands.${brand}.semantic.typography.${brandPascal}TypographyMedium
import com.bild.designsystem.brands.${brand}.semantic.typography.${brandPascal}TypographyExpanded`;
  }).join('\n');

  // Density imports (brand-independent, like Effects)
  const densityImports = `// Density is brand-independent (same values across all brands)
import com.bild.designsystem.shared.DensityDefault
import com.bild.designsystem.shared.DensityDense
import com.bild.designsystem.shared.DensitySpacious`;

  // Generate color selection cases
  const colorCases = COLOR_BRANDS.map(brand => {
    const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
    return `        ColorBrand.${brandPascal} -> if (darkTheme) ${brandPascal}DarkColors else ${brandPascal}LightColors`;
  }).join('\n');

  // Generate sizing selection cases (Material 3: Compact, Medium, Expanded)
  const sizingCases = CONTENT_BRANDS.map(brand => {
    const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
    return `        ContentBrand.${brandPascal} -> when (sizeClass) {
            WindowSizeClass.Compact -> ${brandPascal}SizingCompact
            WindowSizeClass.Medium -> ${brandPascal}SizingMedium
            WindowSizeClass.Expanded -> ${brandPascal}SizingExpanded
        }`;
  }).join('\n');

  // Generate typography selection cases (Material 3: Compact, Medium, Expanded)
  const typographyCases = CONTENT_BRANDS.map(brand => {
    const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
    return `        ContentBrand.${brandPascal} -> when (sizeClass) {
            WindowSizeClass.Compact -> ${brandPascal}TypographyCompact
            WindowSizeClass.Medium -> ${brandPascal}TypographyMedium
            WindowSizeClass.Expanded -> ${brandPascal}TypographyExpanded
        }`;
  }).join('\n');

  // Density spacing is brand-independent (like Effects)
  // Simple when on density mode only, no ContentBrand needed
  const densitySelection = `when (density) {
        Density.Default -> DensityDefault
        Density.Dense -> DensityDense
        Density.Spacious -> DensitySpacious
    }`;

  let output = generateFileHeader({
    fileName: 'DesignSystemTheme.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `Central Design System Theme Provider (Dual-Axis Architecture)\nUnified entry point with separate ColorBrand and ContentBrand axes`
  });

  return output + `
package com.bild.designsystem.shared

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.ReadOnlyComposable
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

// Color imports (ColorBrand axis)
${colorImports}

// Sizing imports (ContentBrand axis)
${sizingImports}

// Typography imports (ContentBrand axis)
${typographyImports}

// Density imports (ContentBrand axis)
${densityImports}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSITION LOCALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * CompositionLocal for current color scheme
 * Type: DesignColorScheme (unified interface)
 */
internal val LocalDesignColors = staticCompositionLocalOf<DesignColorScheme> { BildLightColors }

/**
 * CompositionLocal for current sizing scheme
 * Type: DesignSizingScheme (unified interface)
 */
internal val LocalDesignSizing = staticCompositionLocalOf<DesignSizingScheme> { BildSizingCompact }

/**
 * CompositionLocal for current typography scheme
 * Type: DesignTypographyScheme (unified interface)
 */
internal val LocalDesignTypography = staticCompositionLocalOf<DesignTypographyScheme> { BildTypographyCompact }

/**
 * CompositionLocal for current effects scheme
 * Type: DesignEffectsScheme (unified interface)
 * Note: Effects are brand-independent, only depend on light/dark mode
 */
internal val LocalDesignEffects = staticCompositionLocalOf<DesignEffectsScheme> { EffectsLight }

/**
 * CompositionLocal for current window size class
 */
internal val LocalWindowSizeClass = staticCompositionLocalOf { WindowSizeClass.Compact }

/**
 * CompositionLocal for current density
 */
internal val LocalDensity = staticCompositionLocalOf { Density.Default }

/**
 * CompositionLocal for current density spacing scheme
 * Type: DesignDensityScheme (unified interface)
 */
internal val LocalDesignDensitySpacing = staticCompositionLocalOf<DesignDensityScheme> { DensityDefault }

/**
 * CompositionLocal for dark theme state
 */
internal val LocalIsDarkTheme = staticCompositionLocalOf { false }

/**
 * CompositionLocal for current color brand
 */
internal val LocalColorBrand = staticCompositionLocalOf { ColorBrand.Bild }

/**
 * CompositionLocal for current content brand
 */
internal val LocalContentBrand = staticCompositionLocalOf { ContentBrand.Bild }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEME PROVIDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Central Design System Theme Provider (Dual-Axis Architecture)
 *
 * Provides a unified entry point with two independent brand axes:
 * - ColorBrand: Determines color palette (BILD or SportBILD)
 * - ContentBrand: Determines sizing/typography (BILD, SportBILD, or Advertorial)
 *
 * This enables use cases like "Advertorial content with SportBILD colors".
 *
 * @param colorBrand Color palette to use (BILD or SportBILD)
 * @param contentBrand Content/sizing tokens to use (BILD, SportBILD, or Advertorial)
 * @param darkTheme Whether to use dark color scheme
 * @param sizeClass Window size class for responsive sizing
 * @param density UI density for spacing adjustments
 * @param content Composable content to wrap
 *
 * Usage:
 * \`\`\`kotlin
 * // Standard BILD app
 * DesignSystemTheme(
 *     colorBrand = ColorBrand.Bild,
 *     contentBrand = ContentBrand.Bild
 * ) {
 *     MyApp()
 * }
 *
 * // Advertorial with SportBILD colors
 * DesignSystemTheme(
 *     colorBrand = ColorBrand.Sportbild,
 *     contentBrand = ContentBrand.Advertorial
 * ) {
 *     AdvertorialContent()
 * }
 * \`\`\`
 */
@Composable
fun DesignSystemTheme(
    colorBrand: ColorBrand = ColorBrand.Bild,
    contentBrand: ContentBrand = ContentBrand.Bild,
    darkTheme: Boolean = isSystemInDarkTheme(),
    sizeClass: WindowSizeClass = WindowSizeClass.Compact,
    density: Density = Density.Default,
    content: @Composable () -> Unit
) {
    val colors: DesignColorScheme = when (colorBrand) {
${colorCases}
    }

    val sizing: DesignSizingScheme = when (contentBrand) {
${sizingCases}
    }

    val typography: DesignTypographyScheme = when (contentBrand) {
${typographyCases}
    }

    // Effects are brand-independent, only depend on light/dark mode
    val effects: DesignEffectsScheme = if (darkTheme) EffectsDark else EffectsLight

    // Density spacing is brand-independent (like Effects), only depends on density mode
    val densitySpacing: DesignDensityScheme = ${densitySelection}

    CompositionLocalProvider(
        LocalDesignColors provides colors,
        LocalDesignSizing provides sizing,
        LocalDesignTypography provides typography,
        LocalDesignEffects provides effects,
        LocalDesignDensitySpacing provides densitySpacing,
        LocalWindowSizeClass provides sizeClass,
        LocalDensity provides density,
        LocalIsDarkTheme provides darkTheme,
        LocalColorBrand provides colorBrand,
        LocalContentBrand provides contentBrand,
        content = content
    )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEME ACCESSOR OBJECT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Accessor object for Design System theme values
 *
 * Provides convenient access to current theme values from any composable.
 *
 * Usage:
 * \`\`\`kotlin
 * @Composable
 * fun MyButton() {
 *     Button(
 *         colors = ButtonDefaults.buttonColors(
 *             containerColor = DesignSystemTheme.colors.coreColorPrimary
 *         )
 *     ) {
 *         Text(
 *             text = "Click me",
 *             fontSize = DesignSystemTheme.sizing.headline1FontSize
 *         )
 *     }
 * }
 * \`\`\`
 */
object DesignSystemTheme {

    /**
     * Current color scheme (based on ColorBrand and dark/light mode)
     */
    val colors: DesignColorScheme
        @Composable
        @ReadOnlyComposable
        get() = LocalDesignColors.current

    /**
     * Current sizing scheme (based on ContentBrand and WindowSizeClass)
     */
    val sizing: DesignSizingScheme
        @Composable
        @ReadOnlyComposable
        get() = LocalDesignSizing.current

    /**
     * Current typography scheme (based on ContentBrand and WindowSizeClass)
     * Use .toComposeTextStyle() on individual styles for Text composable
     */
    val typography: DesignTypographyScheme
        @Composable
        @ReadOnlyComposable
        get() = LocalDesignTypography.current

    /**
     * Current effects scheme (shadows, brand-independent)
     * Use .toModifier() on shadow styles to apply them
     */
    val effects: DesignEffectsScheme
        @Composable
        @ReadOnlyComposable
        get() = LocalDesignEffects.current

    /**
     * Internal density spacing scheme - not for direct consumption.
     * Use the resolver properties below (stackSpaceRespMd, stackSpaceConstLg, etc.)
     * which automatically resolve based on WindowSizeClass and DensityMode.
     */
    internal val densitySpacing: DesignDensityScheme
        @Composable
        @ReadOnlyComposable
        get() = LocalDesignDensitySpacing.current

${generateAndroidDensityResolvers()}

    /**
     * Current window size class
     */
    val sizeClass: WindowSizeClass
        @Composable
        @ReadOnlyComposable
        get() = LocalWindowSizeClass.current

    /**
     * Current UI density
     */
    val density: Density
        @Composable
        @ReadOnlyComposable
        get() = LocalDensity.current

    /**
     * Whether dark theme is currently active
     */
    val isDarkTheme: Boolean
        @Composable
        @ReadOnlyComposable
        get() = LocalIsDarkTheme.current

    /**
     * Current color brand
     */
    val colorBrand: ColorBrand
        @Composable
        @ReadOnlyComposable
        get() = LocalColorBrand.current

    /**
     * Current content brand
     */
    val contentBrand: ContentBrand
        @Composable
        @ReadOnlyComposable
        get() = LocalContentBrand.current
}
`;
}

/**
 * Consolidates all primitive files into a single DesignTokenPrimitives.kt file
 * Creates: dist/android/compose/shared/DesignTokenPrimitives.kt
 */
async function consolidateComposePrimitives() {
  if (!COMPOSE_ENABLED) {
    return { total: 0, successful: 0 };
  }

  console.log('ðŸ“¦ Consolidating Compose Primitives...');

  const sharedDir = path.join(ANDROID_DIST_DIR, 'shared');

  if (!fs.existsSync(sharedDir)) {
    console.log('  âš ï¸  No Compose shared directory found');
    return { total: 0, successful: 0 };
  }

  const primitiveFiles = ['Colorprimitive.kt', 'Fontprimitive.kt', 'Sizeprimitive.kt', 'Spaceprimitive.kt'];
  const primitiveData = {
    Colors: [],
    Font: [],
    Size: [],
    Space: []
  };

  // Parse each primitive file
  for (const fileName of primitiveFiles) {
    const filePath = path.join(sharedDir, fileName);
    if (!fs.existsSync(filePath)) continue;

    const content = fs.readFileSync(filePath, 'utf8');
    const category = fileName.replace('primitive.kt', '').replace('Color', 'Colors');

    // Extract val declarations
    const valRegex = /^\s*(internal\s+)?val\s+(\w+)\s*=\s*(.+)$/gm;
    let match;
    while ((match = valRegex.exec(content)) !== null) {
      const name = match[2];
      const value = match[3].trim();
      if (primitiveData[category]) {
        primitiveData[category].push({ name, value });
      }
    }
  }

  // Generate consolidated file
  let output = generateFileHeader({
    fileName: 'DesignTokenPrimitives.kt',
    commentStyle: 'block',
    platform: 'android',
    context: `Consolidated Design Token Primitives\nAll primitive values in a single file for easy imports`
  });

  output += `
package com.bild.designsystem.shared

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

/**
 * Design Token Primitives
 *
 * Usage:
 *   DesignTokenPrimitives.Colors.colorBildRed50
 *   DesignTokenPrimitives.Space.space2x
 *   DesignTokenPrimitives.Size.size4x
 *   DesignTokenPrimitives.Font.fontWeightBold
 */
object DesignTokenPrimitives {

`;

  // Add Colors
  if (primitiveData.Colors.length > 0) {
    output += `    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COLORS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Colors {
`;
    primitiveData.Colors.forEach(t => {
      output += `        val ${t.name} = ${t.value}\n`;
    });
    output += `    }\n\n`;
  }

  // Add Font
  if (primitiveData.Font.length > 0) {
    output += `    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FONT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Font {
`;
    primitiveData.Font.forEach(t => {
      output += `        val ${t.name} = ${t.value}\n`;
    });
    output += `    }\n\n`;
  }

  // Add Size
  if (primitiveData.Size.length > 0) {
    output += `    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SIZE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Size {
`;
    primitiveData.Size.forEach(t => {
      output += `        val ${t.name} = ${t.value}\n`;
    });
    output += `    }\n\n`;
  }

  // Add Space
  if (primitiveData.Space.length > 0) {
    output += `    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SPACE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Space {
`;
    primitiveData.Space.forEach(t => {
      output += `        val ${t.name} = ${t.value}\n`;
    });
    output += `    }\n`;
  }

  output += `}
`;

  // Write consolidated file
  const consolidatedFile = path.join(sharedDir, 'DesignTokenPrimitives.kt');
  fs.writeFileSync(consolidatedFile, output, 'utf8');

  console.log(`     âœ… shared/DesignTokenPrimitives.kt (${primitiveData.Colors.length + primitiveData.Font.length + primitiveData.Size.length + primitiveData.Space.length} tokens)`);
  console.log(`  ðŸ“Š Consolidated 4 primitive files into 1\n`);

  return { total: 1, successful: 1 };
}

/**
 * Aggregates semantic token files into consolidated files per brand
 * Creates: dist/android/compose/brands/{brand}/semantic/{Brand}SemanticTokens.kt
 */
async function aggregateComposeSemantics() {
  if (!COMPOSE_ENABLED) {
    return { totalBrands: 0, successfulBrands: 0 };
  }

  console.log('ðŸ“¦ Aggregating Compose Semantic Tokens...');

  let totalBrands = 0;
  let successfulBrands = 0;

  const composeDir = path.join(ANDROID_DIST_DIR, 'brands');

  if (!fs.existsSync(composeDir)) {
    console.log('  âš ï¸  No Compose brands directory found');
    return { totalBrands: 0, successfulBrands: 0 };
  }

  for (const brand of BRANDS) {
    totalBrands++;
    const brandDir = path.join(composeDir, brand);
    const semanticDir = path.join(brandDir, 'semantic');

    if (!fs.existsSync(semanticDir)) continue;

    try {
      const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
      const packageJson = require('../../packages/tokens/package.json');
      const version = packageJson.version;

      // Collect semantic tokens
      const semanticData = {
        colors: { light: [], dark: [] },
        sizing: { compact: [], medium: [], expanded: [] }
      };

      // Read color files
      const colorDir = path.join(semanticDir, 'color');
      if (fs.existsSync(colorDir)) {
        const colorFiles = fs.readdirSync(colorDir).filter(f => f.endsWith('.kt'));
        for (const fileName of colorFiles) {
          const content = fs.readFileSync(path.join(colorDir, fileName), 'utf8');
          const mode = fileName.toLowerCase().includes('dark') ? 'dark' : 'light';

          // Match both 'val' and 'override val' declarations
          const valRegex = /^\s*(?:override\s+)?val\s+(\w+)\s*=\s*(.+)$/gm;
          let match;
          while ((match = valRegex.exec(content)) !== null) {
            semanticData.colors[mode].push({ name: match[1], value: match[2].trim() });
          }
        }
      }

      // Read sizing files (Android uses Compact/Medium/Expanded)
      const sizingDir = path.join(semanticDir, 'sizeclass');
      if (fs.existsSync(sizingDir)) {
        const sizingFiles = fs.readdirSync(sizingDir).filter(f => f.endsWith('.kt'));
        for (const fileName of sizingFiles) {
          const content = fs.readFileSync(path.join(sizingDir, fileName), 'utf8');
          const fileNameLower = fileName.toLowerCase();
          let mode = 'compact';
          if (fileNameLower.includes('expanded')) mode = 'expanded';
          else if (fileNameLower.includes('medium')) mode = 'medium';
          else if (fileNameLower.includes('compact')) mode = 'compact';

          // Match both 'val' and 'override val' declarations
          const valRegex = /^\s*(?:override\s+)?val\s+(\w+)\s*=\s*(.+)$/gm;
          let match;
          while ((match = valRegex.exec(content)) !== null) {
            semanticData.sizing[mode].push({ name: match[1], value: match[2].trim() });
          }
        }
      }

      // Generate aggregated semantic file
      let output = generateFileHeader({
        fileName: `${brandPascal}SemanticTokens.kt`,
        commentStyle: 'block',
        platform: 'android',
        brand: brandPascal,
        context: `Aggregated Semantic Tokens\nAll semantic tokens in a single file with mode variants`
      });

      output += `
package com.bild.designsystem.brands.${brand}.semantic

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

/**
 * ${brandPascal} Semantic Tokens
 *
 * Usage:
 *   ${brandPascal}SemanticTokens.Colors.Light.textColorPrimary
 *   ${brandPascal}SemanticTokens.Colors.Dark.textColorPrimary
 *   ${brandPascal}SemanticTokens.Sizing.Compact.headline1FontSize
 *   ${brandPascal}SemanticTokens.Sizing.Medium.headline1FontSize
 *   ${brandPascal}SemanticTokens.Sizing.Expanded.headline1FontSize
 */
object ${brandPascal}SemanticTokens {

`;

      // Add Colors section
      if (semanticData.colors.light.length > 0 || semanticData.colors.dark.length > 0) {
        output += `    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COLORS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Colors {
`;
        if (semanticData.colors.light.length > 0) {
          output += `        object Light {\n`;
          semanticData.colors.light.forEach(t => {
            output += `            val ${t.name} = ${t.value}\n`;
          });
          output += `        }\n`;
        }
        if (semanticData.colors.dark.length > 0) {
          output += `        object Dark {\n`;
          semanticData.colors.dark.forEach(t => {
            output += `            val ${t.name} = ${t.value}\n`;
          });
          output += `        }\n`;
        }
        output += `    }\n\n`;
      }

      // Add Sizing section (Android uses Compact/Medium/Expanded)
      if (semanticData.sizing.compact.length > 0 || semanticData.sizing.medium.length > 0 || semanticData.sizing.expanded.length > 0) {
        output += `    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SIZING (WindowSizeClass)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    object Sizing {
`;
        if (semanticData.sizing.compact.length > 0) {
          output += `        object Compact {\n`;
          semanticData.sizing.compact.forEach(t => {
            output += `            val ${t.name} = ${t.value}\n`;
          });
          output += `        }\n`;
        }
        if (semanticData.sizing.medium.length > 0) {
          output += `        object Medium {\n`;
          semanticData.sizing.medium.forEach(t => {
            output += `            val ${t.name} = ${t.value}\n`;
          });
          output += `        }\n`;
        }
        if (semanticData.sizing.expanded.length > 0) {
          output += `        object Expanded {\n`;
          semanticData.sizing.expanded.forEach(t => {
            output += `            val ${t.name} = ${t.value}\n`;
          });
          output += `        }\n`;
        }
        output += `    }\n`;
      }

      output += `}
`;

      // Write aggregated file
      const aggregatedFile = path.join(semanticDir, `${brandPascal}SemanticTokens.kt`);
      fs.writeFileSync(aggregatedFile, output, 'utf8');

      const totalTokens = semanticData.colors.light.length + semanticData.colors.dark.length +
                          semanticData.sizing.compact.length + semanticData.sizing.regular.length;
      console.log(`     âœ… ${brand}/semantic/${brandPascal}SemanticTokens.kt (${totalTokens} tokens)`);
      successfulBrands++;

    } catch (error) {
      console.error(`     âŒ ${brand}: ${error.message}`);
    }
  }

  console.log(`  ðŸ“Š Aggregated: ${successfulBrands}/${totalBrands} brand semantics\n`);
  return { totalBrands, successfulBrands };
}

/**
 * Removes individual Compose files, keeping only aggregated versions
 * This reduces file count and simplifies imports
 */
async function cleanupComposeIndividualFiles() {
  if (!COMPOSE_ENABLED) {
    return { removed: 0 };
  }

  console.log('ðŸ§¹ Cleaning up individual Compose files...');

  let removedCount = 0;

  // Clean up primitive files (keep only DesignTokenPrimitives.kt)
  const sharedDir = path.join(ANDROID_DIST_DIR, 'shared');
  if (fs.existsSync(sharedDir)) {
    const primitiveFiles = ['Colorprimitive.kt', 'Fontprimitive.kt', 'Sizeprimitive.kt', 'Spaceprimitive.kt'];
    for (const fileName of primitiveFiles) {
      const filePath = path.join(sharedDir, fileName);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
        removedCount++;
      }
    }
  }

  // Clean up component individual files (keep only {Component}Tokens.kt)
  const composeDir = path.join(ANDROID_DIST_DIR, 'brands');
  if (fs.existsSync(composeDir)) {
    for (const brand of BRANDS) {
      const componentsDir = path.join(composeDir, brand, 'components');
      if (!fs.existsSync(componentsDir)) continue;

      const componentDirs = fs.readdirSync(componentsDir, { withFileTypes: true })
        .filter(d => d.isDirectory())
        .filter(d => !d.name.startsWith('.') && !d.name.startsWith('_'))
        .map(d => d.name);

      for (const componentDirName of componentDirs) {
        const componentDir = path.join(componentsDir, componentDirName);
        const files = fs.readdirSync(componentDir).filter(f => f.endsWith('.kt'));
        // Convert directory name (lowercase) to PascalCase for aggregated file name
        const componentName = componentDirName.charAt(0).toUpperCase() + componentDirName.slice(1);

        // Keep only {Component}Tokens.kt, remove individual files
        const aggregatedFile = `${componentName}Tokens.kt`;
        for (const fileName of files) {
          if (fileName !== aggregatedFile) {
            fs.unlinkSync(path.join(componentDir, fileName));
            removedCount++;
          }
        }
      }

      // Clean up semantic individual files (keep only {Brand}SemanticTokens.kt and individual mode files for backward compat)
      // Actually, let's keep the individual semantic files for backward compatibility
      // as they're referenced by the Theme Provider
    }
  }

  console.log(`  ðŸ“Š Removed ${removedCount} individual files\n`);
  return { removed: removedCount };
}

/**
 * Removes individual SwiftUI primitive files, keeping only DesignTokenPrimitives.swift
 * This follows SwiftUI best practice of consolidated primitives with nested enums
 */
async function cleanupSwiftUIIndividualPrimitives() {
  if (!SWIFTUI_ENABLED) {
    return { removed: 0 };
  }

  console.log('ðŸ§¹ Cleaning up individual SwiftUI primitive files...');

  let removedCount = 0;

  // Clean up individual primitive files (keep only DesignTokenPrimitives.swift)
  const sharedDir = path.join(IOS_DIST_DIR, 'shared');
  if (fs.existsSync(sharedDir)) {
    const primitiveFiles = ['Colorprimitive.swift', 'Fontprimitive.swift', 'Sizeprimitive.swift', 'Spaceprimitive.swift'];
    for (const fileName of primitiveFiles) {
      const filePath = path.join(sharedDir, fileName);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
        removedCount++;
      }
    }
  }

  console.log(`  ðŸ“Š Removed ${removedCount} individual Swift primitive files\n`);
  return { removed: removedCount };
}

// ============================================================================
// SWIFTUI POST-PROCESSING FUNCTIONS
// ============================================================================

/**
 * Generates SwiftUI Shared Infrastructure files
 * Creates: dist/ios/shared/*.swift (Enums, TextStyle, Shadow, ColorExtension)
 */
async function generateSwiftUISharedFiles() {
  if (!SWIFTUI_ENABLED) {
    return { total: 0, successful: 0 };
  }

  console.log('ðŸŽ Generating SwiftUI Shared Infrastructure...');

  const sharedDir = path.join(IOS_DIST_DIR, 'shared');
  if (!fs.existsSync(sharedDir)) {
    fs.mkdirSync(sharedDir, { recursive: true });
  }

  let successful = 0;

  // Generate Enums.swift (Density, SizeClass, ColorBrand, ContentBrand)
  const enumsContent = generateFileHeader({
    fileName: 'Enums.swift',
    commentStyle: 'line',
    platform: 'ios',
    context: `SwiftUI Enums\nDensity, SizeClass, ColorBrand, ContentBrand`
  }) + `
import Foundation

/// UI density modes for the BILD Design System
public enum Density: String, CaseIterable, Sendable {
    case dense
    case \`default\`
    case spacious
}

/// Size class for responsive layouts
/// Maps to iOS UITraitCollection.horizontalSizeClass
public enum SizeClass: String, CaseIterable, Sendable {
    case compact   // Phones (Portrait), small screens - maps to xs/sm breakpoints
    case regular   // Tablets, Phones (Landscape) - maps to md/lg breakpoints
}

/// Color brands - defines the color palette and effects
/// Only brands with their own color schemes are included
public enum ColorBrand: String, CaseIterable, Sendable {
    case bild
    case sportbild
    // Note: Advertorial uses BILD or SportBILD colors
}

/// Content brands - defines sizing, typography, and layout tokens
/// All brands including those without own color schemes
public enum ContentBrand: String, CaseIterable, Sendable {
    case bild
    case sportbild
    case advertorial
}

/// Legacy: Combined brand enum for backwards compatibility
@available(*, deprecated, message: "Use ColorBrand and ContentBrand for dual-axis theming")
public enum Brand: String, CaseIterable, Sendable {
    case bild
    case sportbild
    case advertorial
}
`;
  fs.writeFileSync(path.join(sharedDir, 'Enums.swift'), enumsContent, 'utf8');
  console.log('     âœ… shared/Enums.swift');
  successful++;

  // Generate Color+Hex.swift
  const colorExtContent = generateFileHeader({
    fileName: 'Color+Hex.swift',
    commentStyle: 'line',
    platform: 'ios',
    context: `SwiftUI Color Extension\nHex color initialization`
  }) + `
import SwiftUI

public extension Color {
    /// Initialize Color from hex value
    /// - Parameters:
    ///   - hex: Hex color value (e.g., 0xDD0000)
    ///   - alpha: Optional alpha value (0.0 - 1.0)
    init(hex: UInt, alpha: Double = 1.0) {
        self.init(
            .sRGB,
            red: Double((hex >> 16) & 0xFF) / 255,
            green: Double((hex >> 8) & 0xFF) / 255,
            blue: Double(hex & 0xFF) / 255,
            opacity: alpha
        )
    }
}
`;
  fs.writeFileSync(path.join(sharedDir, 'Color+Hex.swift'), colorExtContent, 'utf8');
  console.log('     âœ… shared/Color+Hex.swift');
  successful++;

  // Generate TextStyle.swift
  const textStyleContent = generateFileHeader({
    fileName: 'TextStyle.swift',
    commentStyle: 'line',
    platform: 'ios',
    context: `SwiftUI TextStyle\nComposite typography token`
  }) + `
import SwiftUI

/// Composite typography token representing a complete text style
public struct TextStyle: Equatable, Sendable {
    public let fontFamily: String
    public let fontWeight: Font.Weight
    public let fontSize: CGFloat
    public let lineHeight: CGFloat
    public let letterSpacing: CGFloat
    public let textCase: TextCase
    public let textDecoration: TextDecoration

    public init(
        fontFamily: String,
        fontWeight: Font.Weight,
        fontSize: CGFloat,
        lineHeight: CGFloat,
        letterSpacing: CGFloat,
        textCase: TextCase = .original,
        textDecoration: TextDecoration = .none
    ) {
        self.fontFamily = fontFamily
        self.fontWeight = fontWeight
        self.fontSize = fontSize
        self.lineHeight = lineHeight
        self.letterSpacing = letterSpacing
        self.textCase = textCase
        self.textDecoration = textDecoration
    }

    public enum TextCase: String, Sendable {
        case original = "ORIGINAL"
        case upper = "UPPER"
        case lower = "LOWER"
        case capitalize = "CAPITALIZE"

        var swiftUICase: Text.Case? {
            switch self {
            case .original: return nil
            case .upper: return .uppercase
            case .lower: return .lowercase
            case .capitalize: return nil
            }
        }
    }

    public enum TextDecoration: String, Sendable {
        case none = "NONE"
        case underline = "UNDERLINE"
        case strikethrough = "STRIKETHROUGH"
    }

    /// Create a SwiftUI Font from this text style with Dynamic Type support
    public func font(relativeTo textStyle: Font.TextStyle = .body) -> Font {
        Font.custom(fontFamily, size: fontSize, relativeTo: textStyle)
            .weight(fontWeight)
    }

    /// Line spacing value for SwiftUI (lineHeight - fontSize)
    public var lineSpacing: CGFloat {
        max(0, lineHeight - fontSize)
    }
}

/// View modifier for applying TextStyle
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct TextStyleModifier: ViewModifier {
    let style: TextStyle
    let relativeTo: Font.TextStyle

    public init(_ style: TextStyle, relativeTo: Font.TextStyle = .body) {
        self.style = style
        self.relativeTo = relativeTo
    }

    public func body(content: Content) -> some View {
        content
            .font(style.font(relativeTo: relativeTo))
            .tracking(style.letterSpacing)
            .lineSpacing(style.lineSpacing)
            .textCase(style.textCase.swiftUICase)
    }
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public extension View {
    func textStyle(_ style: TextStyle, relativeTo: Font.TextStyle = .body) -> some View {
        modifier(TextStyleModifier(style, relativeTo: relativeTo))
    }
}
`;
  fs.writeFileSync(path.join(sharedDir, 'TextStyle.swift'), textStyleContent, 'utf8');
  console.log('     âœ… shared/TextStyle.swift');
  successful++;

  // Generate ShadowStyle.swift
  const shadowContent = generateFileHeader({
    fileName: 'ShadowStyle.swift',
    commentStyle: 'line',
    platform: 'ios',
    context: `SwiftUI Shadow Styles\nDropShadow and ShadowStyle composites`
  }) + `
import SwiftUI

/// Single drop shadow definition
public struct DropShadow: Equatable, Sendable {
    public let color: Color
    public let offsetX: CGFloat
    public let offsetY: CGFloat
    public let radius: CGFloat
    public let spread: CGFloat

    public init(
        color: Color,
        offsetX: CGFloat,
        offsetY: CGFloat,
        radius: CGFloat,
        spread: CGFloat = 0
    ) {
        self.color = color
        self.offsetX = offsetX
        self.offsetY = offsetY
        self.radius = radius
        self.spread = spread
    }
}

/// Composite shadow token (can contain multiple layers)
public struct ShadowStyle: Equatable, Sendable {
    public let shadows: [DropShadow]

    public init(shadows: [DropShadow]) {
        self.shadows = shadows
    }

    public init(_ shadow: DropShadow) {
        self.shadows = [shadow]
    }
}

/// View modifier for applying ShadowStyle (applies all shadow layers)
public struct ShadowStyleModifier: ViewModifier {
    let style: ShadowStyle

    public init(_ style: ShadowStyle) {
        self.style = style
    }

    public func body(content: Content) -> some View {
        style.shadows.reduce(AnyView(content)) { view, shadow in
            AnyView(view.shadow(
                color: shadow.color,
                radius: shadow.radius,
                x: shadow.offsetX,
                y: shadow.offsetY
            ))
        }
    }
}

public extension View {
    func shadowStyle(_ style: ShadowStyle) -> some View {
        modifier(ShadowStyleModifier(style))
    }
}
`;
  fs.writeFileSync(path.join(sharedDir, 'ShadowStyle.swift'), shadowContent, 'utf8');
  console.log('     âœ… shared/ShadowStyle.swift');
  successful++;

  // Generate DesignSystemTheme.swift with dual-axis architecture
  // Dynamically read color properties from generated iOS files (now brand-prefixed)
  const bildColorsPath = path.join(IOS_DIST_DIR, 'brands', 'bild', 'semantic', 'color', 'BildColorsLight.swift');
  let colorProperties = [];
  if (fs.existsSync(bildColorsPath)) {
    const content = fs.readFileSync(bildColorsPath, 'utf8');
    // Extract all var declarations with Color type from the entire file
    const propsMatch = content.matchAll(/^\s*var\s+(\w+):\s*Color\s*\{\s*get\s*\}/gm);
    for (const match of propsMatch) {
      colorProperties.push(match[1]);
    }
  }
  // Fallback if file not found
  if (colorProperties.length === 0) {
    colorProperties = ['textColorPrimary', 'textColorSecondary', 'surfaceColorPrimary', 'coreColorPrimary'];
  }
  const colorPropertyDeclarations = colorProperties.map(prop => `    var ${prop}: Color { get }`).join('\n');

  // Dynamically read sizing properties with their types (now brand-prefixed)
  // Supported types: CGFloat, String, Bool, Int
  const bildSizingPath = path.join(IOS_DIST_DIR, 'brands', 'bild', 'semantic', 'sizeclass', 'BildSizingCompact.swift');
  let sizingProperties = [];
  if (fs.existsSync(bildSizingPath)) {
    const content = fs.readFileSync(bildSizingPath, 'utf8');
    // Extract all var declarations with their Swift types
    const propsMatch = content.matchAll(/^\s*var\s+(\w+):\s*(CGFloat|String|Bool|Int)\s*\{\s*get\s*\}/gm);
    for (const match of propsMatch) {
      sizingProperties.push({ name: match[1], type: match[2] });
    }
  }
  if (sizingProperties.length === 0) {
    sizingProperties = [
      { name: 'gridSpaceRespBase', type: 'CGFloat' },
      { name: 'gridSpaceRespSm', type: 'CGFloat' },
      { name: 'gridSpaceRespLg', type: 'CGFloat' },
      { name: 'pageInlineSpace', type: 'CGFloat' }
    ];
  }
  const sizingPropertyDeclarations = sizingProperties.map(prop => `    var ${prop.name}: ${prop.type} { get }`).join('\n');

  // Dynamically read effects properties (now brand-prefixed)
  const bildEffectsPath = path.join(IOS_DIST_DIR, 'brands', 'bild', 'semantic', 'effects', 'BildEffectsLight.swift');
  let effectsProperties = [];
  if (fs.existsSync(bildEffectsPath)) {
    const content = fs.readFileSync(bildEffectsPath, 'utf8');
    // Extract all var declarations with ShadowStyle type
    const propsMatch = content.matchAll(/^\s*var\s+(\w+):\s*ShadowStyle\s*\{\s*get\s*\}/gm);
    for (const match of propsMatch) {
      effectsProperties.push(match[1]);
    }
  }
  if (effectsProperties.length === 0) {
    effectsProperties = ['shadowSoftSm', 'shadowSoftMd', 'shadowSoftLg', 'shadowHardSm', 'shadowHardMd', 'shadowHardLg'];
  }
  const effectsPropertyDeclarations = effectsProperties.map(prop => `    var ${prop}: ShadowStyle { get }`).join('\n');

  // Dynamically read typography properties from generated iOS files (now brand-prefixed)
  const bildTypographyPath = path.join(IOS_DIST_DIR, 'brands', 'bild', 'semantic', 'typography', 'BildTypographySizeclassCompact.swift');
  let typographyProperties = [];
  if (fs.existsSync(bildTypographyPath)) {
    const content = fs.readFileSync(bildTypographyPath, 'utf8');
    // Extract all var declarations with TextStyle type from protocol
    const propsMatch = content.matchAll(/^\s*var\s+(\w+):\s*TextStyle\s*\{\s*get\s*\}/gm);
    for (const match of propsMatch) {
      typographyProperties.push(match[1]);
    }
  }
  if (typographyProperties.length === 0) {
    typographyProperties = ['display1', 'headline1', 'body', 'label1'];
  }
  const typographyPropertyDeclarations = typographyProperties.map(prop => `    var ${prop}: TextStyle { get }`).join('\n');

  // Dynamically read density properties from SOURCE JSON (not generated files)
  // This ensures scalability - new tokens in Figma automatically appear in the protocol
  const densitySourcePath = path.join(TOKENS_DIR, 'brands', 'bild', 'density', 'density-default.json');
  let densityProperties = [];

  if (fs.existsSync(densitySourcePath)) {
    const densityData = JSON.parse(fs.readFileSync(densitySourcePath, 'utf8'));

    // Recursively extract all token names from the JSON structure
    function extractDensityTokens(obj) {
      const tokens = [];
      for (const [key, value] of Object.entries(obj)) {
        if (value && typeof value === 'object') {
          if (value.$type === 'dimension' || value.type === 'float') {
            tokens.push(key);
          } else {
            tokens.push(...extractDensityTokens(value));
          }
        }
      }
      return tokens;
    }

    densityProperties = extractDensityTokens(densityData);
  }

  if (densityProperties.length === 0) {
    console.warn('No density tokens found in source JSON for iOS protocol');
  }

  // Apply toCamelCase to match Style Dictionary's naming (e.g., 3Xs â†’ 3xs)
  const densityPropertyDeclarations = densityProperties.map(prop => `    var ${toCamelCase(prop)}: CGFloat { get }`).join('\n');

  const designSystemThemeContent = generateFileHeader({
    fileName: 'DesignSystemTheme.swift',
    commentStyle: 'line',
    platform: 'ios',
    context: `SwiftUI DesignSystemTheme\nDual-Axis Theme Provider with Unified Protocols`
  }) + `
import SwiftUI

// MARK: - Unified Protocols

/// Unified color scheme protocol for all color brands (BILD, SportBILD)
/// Allows interchangeable color schemes across content brands
public protocol DesignColorScheme: Sendable {
${colorPropertyDeclarations}
}

/// Unified sizing scheme protocol for all content brands
public protocol DesignSizingScheme: Sendable {
${sizingPropertyDeclarations}
}

/// Unified effects scheme protocol for all color brands
public protocol DesignEffectsScheme: Sendable {
${effectsPropertyDeclarations}
}

/// Unified typography scheme protocol for all content brands
public protocol DesignTypographyScheme: Sendable {
${typographyPropertyDeclarations}
}

/// Unified density scheme protocol for all content brands
/// Semantic density tokens (Global/StackSpace) that vary by density mode
public protocol DesignDensityScheme: Sendable {
${densityPropertyDeclarations}
}

// MARK: - Dual-Axis Theme Provider

/// Multi-brand theme provider with dual-axis architecture
/// - ColorBrand axis: Defines colors and effects (BILD, SportBILD)
/// - ContentBrand axis: Defines sizing, typography, layout (BILD, SportBILD, Advertorial)
///
/// Example usage:
/// \`\`\`swift
/// // Advertorial content with BILD colors
/// DesignSystemTheme(colorBrand: .bild, contentBrand: .advertorial)
///
/// // Advertorial content with SportBILD colors
/// DesignSystemTheme(colorBrand: .sportbild, contentBrand: .advertorial)
/// \`\`\`
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@Observable
public final class DesignSystemTheme: @unchecked Sendable {

    // MARK: - Shared Instance
    public static let shared = DesignSystemTheme()

    // MARK: - Theme State (Dual-Axis)

    /// Color brand determines the color palette and effects
    public var colorBrand: ColorBrand = .bild

    /// Content brand determines sizing, typography, and layout
    public var contentBrand: ContentBrand = .bild

    /// Dark/Light mode
    public var isDarkTheme: Bool = false

    /// Size class for responsive layouts
    public var sizeClass: SizeClass = .compact

    /// Density mode
    public var density: Density = .default

    private init() {}

    // MARK: - Factory

    public init(
        colorBrand: ColorBrand = .bild,
        contentBrand: ContentBrand = .bild,
        isDarkTheme: Bool = false,
        sizeClass: SizeClass = .compact,
        density: Density = .default
    ) {
        self.colorBrand = colorBrand
        self.contentBrand = contentBrand
        self.isDarkTheme = isDarkTheme
        self.sizeClass = sizeClass
        self.density = density
    }

    // MARK: - Color Access (based on colorBrand)

    /// Current color scheme based on colorBrand and isDarkTheme
    public var colors: any DesignColorScheme {
        switch colorBrand {
        case .bild:
            return isDarkTheme ? BildDarkColors.shared : BildLightColors.shared
        case .sportbild:
            return isDarkTheme ? SportbildDarkColors.shared : SportbildLightColors.shared
        }
    }

    /// Current effects scheme based on colorBrand and isDarkTheme
    public var effects: any DesignEffectsScheme {
        switch colorBrand {
        case .bild:
            return isDarkTheme ? BildEffectsDark.shared : BildEffectsLight.shared
        case .sportbild:
            return isDarkTheme ? SportbildEffectsDark.shared : SportbildEffectsLight.shared
        }
    }

    // MARK: - Sizing Access (based on contentBrand)

    /// Current sizing scheme based on contentBrand and sizeClass
    public var sizing: any DesignSizingScheme {
        switch contentBrand {
        case .bild:
            return sizeClass == .compact ? BildSizingCompact.shared : BildSizingRegular.shared
        case .sportbild:
            return sizeClass == .compact ? SportbildSizingCompact.shared : SportbildSizingRegular.shared
        case .advertorial:
            return sizeClass == .compact ? AdvertorialSizingCompact.shared : AdvertorialSizingRegular.shared
        }
    }

    // MARK: - Typography Access (based on contentBrand)

    /// Current typography scheme based on contentBrand and sizeClass
    public var typography: any DesignTypographyScheme {
        switch contentBrand {
        case .bild:
            return sizeClass == .compact ? BildTypographyCompact.shared : BildTypographyRegular.shared
        case .sportbild:
            return sizeClass == .compact ? SportbildTypographyCompact.shared : SportbildTypographyRegular.shared
        case .advertorial:
            return sizeClass == .compact ? AdvertorialTypographyCompact.shared : AdvertorialTypographyRegular.shared
        }
    }

    // MARK: - Density Spacing Access (internal)

    /// Internal density spacing scheme - not for direct consumption.
    /// Use the resolver properties below (stackSpaceRespMd, stackSpaceConstLg, etc.)
    /// which automatically resolve based on SizeClass and DensityMode.
    internal var densitySpacing: any DesignDensityScheme {
        switch density {
        case .default: return DensityDefault.shared
        case .dense: return DensityDense.shared
        case .spacious: return DensitySpacious.shared
        }
    }

${generateiOSDensityResolvers()}
}

// MARK: - Environment Integration

private struct DesignSystemThemeKey: EnvironmentKey {
    static let defaultValue = DesignSystemTheme.shared
}

public extension EnvironmentValues {
    var designSystemTheme: DesignSystemTheme {
        get { self[DesignSystemThemeKey.self] }
        set { self[DesignSystemThemeKey.self] = newValue }
    }
}

// MARK: - View Modifier

public extension View {
    /// Apply design system theme with dual-axis brand selection
    /// - Parameters:
    ///   - colorBrand: Brand for colors and effects (BILD or SportBILD)
    ///   - contentBrand: Brand for sizing, typography, layout (BILD, SportBILD, or Advertorial)
    ///   - darkTheme: Enable dark mode
    ///   - sizeClass: Size class for responsive layouts
    ///   - density: UI density mode
    func designSystemTheme(
        colorBrand: ColorBrand = .bild,
        contentBrand: ContentBrand = .bild,
        darkTheme: Bool = false,
        sizeClass: SizeClass = .compact,
        density: Density = .default
    ) -> some View {
        let theme = DesignSystemTheme(
            colorBrand: colorBrand,
            contentBrand: contentBrand,
            isDarkTheme: darkTheme,
            sizeClass: sizeClass,
            density: density
        )
        return self.environment(\\.designSystemTheme, theme)
    }
}
`;

  // Note: Shared Density objects (DensityDefault.swift, etc.) are now generated via
  // buildSharedDensityTokens() using Style Dictionary pipeline

  fs.writeFileSync(path.join(sharedDir, 'DesignSystemTheme.swift'), designSystemThemeContent, 'utf8');
  console.log('     âœ… shared/DesignSystemTheme.swift');
  successful++;

  console.log(`  ðŸ“Š Generated ${successful} shared SwiftUI files\n`);
  return { total: 5, successful };  // Updated count: 5 files (density now via Style Dictionary)
}

/**
 * Generates SwiftUI Theme Provider for color brands only (BILD, SportBILD)
 * Content-only brands like Advertorial use the central DesignSystemTheme
 * Creates: dist/ios/brands/{brand}/theme/{Brand}Theme.swift
 */
async function generateSwiftUIThemeProviders() {
  if (!SWIFTUI_ENABLED) {
    return { totalThemes: 0, successfulThemes: 0 };
  }

  console.log('ðŸŽ¨ Generating SwiftUI Theme Providers (color brands only)...');

  let totalThemes = 0;
  let successfulThemes = 0;

  const iosDir = path.join(IOS_DIST_DIR, 'brands');

  if (!fs.existsSync(iosDir)) {
    console.log('  âš ï¸  No iOS output found, skipping theme generation');
    return { totalThemes: 0, successfulThemes: 0 };
  }

  const packageJson = require('../../packages/tokens/package.json');
  const version = packageJson.version;

  // Only generate theme providers for color brands (those with their own color tokens)
  const COLOR_BRANDS = ['bild', 'sportbild'];

  for (const brand of COLOR_BRANDS) {
    totalThemes++;
    const brandDir = path.join(iosDir, brand);

    if (!fs.existsSync(brandDir)) {
      continue;
    }

    try {
      // Create theme directory
      const themeDir = path.join(brandDir, 'theme');
      if (!fs.existsSync(themeDir)) {
        fs.mkdirSync(themeDir, { recursive: true });
      }

      const brandPascal = brand.charAt(0).toUpperCase() + brand.slice(1);
      const brandLower = brand.toLowerCase();

      const themeContent = generateFileHeader({
        fileName: `${brandPascal}Theme.swift`,
        commentStyle: 'line',
        platform: 'ios',
        brand: brandPascal,
        context: `SwiftUI Theme Provider\nConvenience theme provider for ${brandPascal} brand`
      }) + `
import SwiftUI

/// Convenience theme provider for ${brandPascal} brand
/// For multi-brand apps, use DesignSystemTheme with colorBrand and contentBrand axes
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@Observable
public final class ${brandPascal}Theme: @unchecked Sendable {

    // MARK: - Shared Instance
    public static let shared = ${brandPascal}Theme()

    // MARK: - Theme State
    public var isDarkTheme: Bool = false
    public var sizeClass: SizeClass = .compact
    public var density: Density = .default

    // MARK: - Token Access

    /// Current color scheme (Light/Dark)
    public var colors: any ${brandPascal}ColorScheme {
        isDarkTheme ? ${brandPascal}DarkColors.shared : ${brandPascal}LightColors.shared
    }

    /// Current sizing scheme (Compact/Regular)
    public var sizing: any ${brandPascal}SizingScheme {
        sizeClass == .compact ? ${brandPascal}SizingCompact.shared : ${brandPascal}SizingRegular.shared
    }

    /// Current effects scheme (Light/Dark)
    public var effects: any ${brandPascal}EffectsScheme {
        isDarkTheme ? ${brandPascal}EffectsDark.shared : ${brandPascal}EffectsLight.shared
    }

    private init() {}
}

// MARK: - Environment Integration

private struct ${brandPascal}ThemeKey: EnvironmentKey {
    static let defaultValue = ${brandPascal}Theme.shared
}

public extension EnvironmentValues {
    var ${brandLower}Theme: ${brandPascal}Theme {
        get { self[${brandPascal}ThemeKey.self] }
        set { self[${brandPascal}ThemeKey.self] = newValue }
    }
}

// MARK: - View Modifier

public extension View {
    /// Apply ${brandPascal} theme to view hierarchy
    func ${brandLower}Theme(
        darkTheme: Bool? = nil,
        sizeClass: SizeClass? = nil,
        density: Density? = nil
    ) -> some View {
        let theme = ${brandPascal}Theme.shared
        if let darkTheme { theme.isDarkTheme = darkTheme }
        if let sizeClass { theme.sizeClass = sizeClass }
        if let density { theme.density = density }
        return self.environment(\\.${brandLower}Theme, theme)
    }
}
`;

      const themeFile = path.join(themeDir, `${brandPascal}Theme.swift`);
      fs.writeFileSync(themeFile, themeContent, 'utf8');

      console.log(`     âœ… ${brand}/theme/${brandPascal}Theme.swift`);
      successfulThemes++;

    } catch (error) {
      console.error(`     âŒ ${brand}: ${error.message}`);
    }
  }

  console.log(`  ðŸ“Š Generated: ${successfulThemes}/${totalThemes} theme providers\n`);
  return { totalThemes, successfulThemes };
}

// ============================================================================
// OPTIMIZED JS OUTPUT
// ============================================================================

// Generate JS file header dynamically
function getJsFileHeader(context = '') {
  return generateFileHeader({
    fileName: 'index.js',
    commentStyle: 'block',
    platform: 'js',
    context: context || 'JavaScript Token Module'
  }) + '\n';
}

/**
 * Convert string to camelCase
 * - Handles consecutive uppercase letters (e.g., shadowSoftSM â†’ shadowSoftSm)
 * - Keeps letters after digits lowercase (e.g., space-1-x â†’ space1x, not space1X)
 * - Works with any input format: camelCase, kebab-case, snake_case
 */
function toCamelCase(str) {
  return str
    // Split on lowercase-to-uppercase transitions (e.g., softSM â†’ soft-S-M)
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    // Lowercase everything
    .toLowerCase()
    // Keep letters after digits lowercase (remove separator without capitalizing)
    .replace(/(\d)[-_\s]+([a-z])/g, '$1$2')
    // Capitalize letters after remaining separators
    .replace(/[-_\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ''))
    // Ensure first character is lowercase
    .replace(/^(.)/, (c) => c.toLowerCase());
}

// shortenTokenName removed - we now use last segment only (matching Style Dictionary behavior)

/**
 * Convert string to PascalCase
 */
function toPascalCase(str) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

/**
 * Format value for JS output
 */
function formatJsValue(value) {
  if (value === null || value === undefined) return 'null';
  if (typeof value === 'string') return JSON.stringify(value);
  if (typeof value === 'number' || typeof value === 'boolean') return String(value);
  return JSON.stringify(value, null, 2);
}

/**
 * Read and parse a JSON token file
 */
function readTokenFile(filePath) {
  if (!fs.existsSync(filePath)) return null;
  try {
    return JSON.parse(fs.readFileSync(filePath, 'utf8'));
  } catch (e) {
    return null;
  }
}

/**
 * Extract flat tokens from nested structure
 * Uses ONLY the last segment as token name (matching Style Dictionary behavior)
 * This ensures consistent naming across all platforms (CSS, JS, iOS, Android)
 *
 * Type-aware formatting based on $type:
 * - dimension, fontSize, lineHeight, letterSpacing â†’ "24px" (string with unit)
 * - color, fontWeight, fontFamily, string, boolean, opacity, number â†’ unchanged
 */
function flattenTokens(obj) {
  const tokens = {};

  // Types that should have 'px' suffix added (per W3C DTCG spec & industry best practice)
  const DIMENSION_TYPES = ['dimension', 'fontSize', 'lineHeight', 'letterSpacing'];

  const extract = (node, path = []) => {
    for (const [key, value] of Object.entries(node)) {
      if (value && typeof value === 'object') {
        if ('$value' in value) {
          // Use only the last key as token name (matching name/custom/js transform)
          const tokenName = toCamelCase(key);
          const rawValue = value.$value !== undefined ? value.$value : value.value;
          const tokenType = value.$type;

          // Type-aware formatting: dimension types get 'px' suffix
          if (DIMENSION_TYPES.includes(tokenType) && typeof rawValue === 'number') {
            tokens[tokenName] = `${rawValue}px`;
          } else {
            tokens[tokenName] = rawValue;
          }
        } else if (!Array.isArray(value)) {
          extract(value, [...path, key]);
        }
      }
    }
  };
  extract(obj);
  return tokens;
}

/**
 * Write file with directory creation
 */
function writeJsFile(filePath, content) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(filePath, content, 'utf8');
}

/**
 * Minify JavaScript content
 * Simple minification: remove comments, compact JSON, reduce whitespace
 */
function minifyJs(content) {
  let min = content;

  // Remove block comments (but not in strings)
  min = min.replace(/\/\*[\s\S]*?\*\//g, '');

  // Remove single-line comments (but not in strings)
  min = min.replace(/^[ \t]*\/\/.*$/gm, '');

  // Compact JSON objects (remove pretty-printing)
  min = min.replace(/= \{[\s\S]*?\};/g, (match) => {
    try {
      // Extract the object part
      const objStr = match.slice(2, -1).trim();
      const obj = eval('(' + objStr + ')');
      return '= ' + JSON.stringify(obj) + ';';
    } catch {
      return match; // If parsing fails, keep original
    }
  });

  // Remove empty lines
  min = min.replace(/^\s*[\r\n]/gm, '');

  // Remove trailing whitespace
  min = min.replace(/[ \t]+$/gm, '');

  return min;
}

/**
 * Build optimized JS output structure
 * Replaces flat 918-file structure with grouped ~60 files
 */
async function buildOptimizedJSOutput() {
  console.log('\nðŸš€ Building Optimized JS Output...\n');

  const jsDistDir = path.join(DIST_DIR, 'js');

  // Clear existing JS output
  if (fs.existsSync(jsDistDir)) {
    fs.rmSync(jsDistDir, { recursive: true });
  }
  fs.mkdirSync(jsDistDir, { recursive: true });

  // Build primitives
  console.log('  ðŸ“¦ Building primitives...');
  const primitiveFiles = ['colorprimitive', 'spaceprimitive', 'sizeprimitive', 'fontprimitive'];
  const primitives = { colors: {}, spacing: {}, sizing: {}, fonts: {} };

  primitiveFiles.forEach(file => {
    const data = readTokenFile(path.join(TOKENS_DIR, 'shared', `${file}.json`));
    if (!data) return;
    const flat = flattenTokens(data);
    Object.entries(flat).forEach(([name, value]) => {
      if (file === 'colorprimitive') primitives.colors[name] = value;
      else if (file === 'spaceprimitive') primitives.spacing[name] = value;
      else if (file === 'sizeprimitive') primitives.sizing[name] = value;
      else if (file === 'fontprimitive') primitives.fonts[name] = value;
    });
  });

  let primitivesOutput = getJsFileHeader();
  primitivesOutput += `export const primitives = ${JSON.stringify(primitives, null, 2)};\n\n`;
  primitivesOutput += `export const { colors, spacing, sizing, fonts } = primitives;\n\n`;
  primitivesOutput += `// Flat exports for tree-shaking\n`;
  Object.values(primitives).forEach(category => {
    Object.entries(category).forEach(([name, value]) => {
      primitivesOutput += `export const ${name} = ${formatJsValue(value)};\n`;
    });
  });
  writeJsFile(path.join(jsDistDir, 'primitives', 'index.js'), primitivesOutput);

  // Build each brand
  for (const brand of BRANDS) {
    console.log(`  ðŸ·ï¸  Building ${brand}...`);
    const hasColors = COLOR_BRANDS.includes(brand);

    // Build colors (light/dark grouped)
    if (hasColors) {
      const colors = {};
      COLOR_MODES.forEach(mode => {
        const data = readTokenFile(path.join(TOKENS_DIR, 'brands', brand, 'color', `colormode-${mode}.json`));
        if (data) colors[mode] = flattenTokens(data);
      });

      let output = getJsFileHeader() + `// Brand: ${brand}\n\n`;
      output += `export const colors = ${JSON.stringify(colors, null, 2)};\n\n`;
      output += `export const light = colors.light;\nexport const dark = colors.dark;\n\n`;
      output += `// Flat exports (light mode) for tree-shaking\n`;
      if (colors.light) {
        Object.entries(colors.light).forEach(([name, value]) => {
          output += `export const ${name} = ${formatJsValue(value)};\n`;
        });
      }
      writeJsFile(path.join(jsDistDir, 'brands', brand, 'colors.js'), output);
    }

    // Build spacing (breakpoints grouped)
    const spacing = {};
    BREAKPOINTS.forEach(bp => {
      const bpDir = path.join(TOKENS_DIR, 'brands', brand, 'breakpoints');
      if (!fs.existsSync(bpDir)) return;
      const files = fs.readdirSync(bpDir).filter(f => f.startsWith(`breakpoint-${bp}`));
      if (files.length === 0) return;
      const data = readTokenFile(path.join(bpDir, files[0]));
      if (data) spacing[bp] = flattenTokens(data);
    });

    let spacingOutput = getJsFileHeader() + `// Brand: ${brand}\n\n`;
    spacingOutput += `export const spacing = ${JSON.stringify(spacing, null, 2)};\n\n`;
    BREAKPOINTS.forEach(bp => { spacingOutput += `export const ${bp} = spacing.${bp};\n`; });
    spacingOutput += `\n// Flat exports (xs) for tree-shaking\n`;
    if (spacing.xs) {
      Object.entries(spacing.xs).forEach(([name, value]) => {
        spacingOutput += `export const ${name} = ${formatJsValue(value)};\n`;
      });
    }
    writeJsFile(path.join(jsDistDir, 'brands', brand, 'spacing.js'), spacingOutput);

    // Build typography
    const typography = {};
    BREAKPOINTS.forEach(bp => {
      const data = readTokenFile(path.join(TOKENS_DIR, 'brands', brand, 'semantic', 'typography', `typography-${bp}.json`));
      if (!data) return;
      typography[bp] = {};
      const extractTypo = (obj) => {
        for (const [key, value] of Object.entries(obj)) {
          if (value && typeof value === 'object') {
            if ('$value' in value && value.$type === 'typography') {
              const name = toCamelCase(key); // Use only last segment
              const s = value.$value;
              typography[bp][name] = {
                fontFamily: s.fontFamily, fontWeight: s.fontWeight || 400,
                fontSize: typeof s.fontSize === 'number' ? `${s.fontSize}px` : s.fontSize,
                lineHeight: typeof s.lineHeight === 'number' ? `${s.lineHeight}px` : String(s.lineHeight)
              };
              if (s.letterSpacing != null) typography[bp][name].letterSpacing = typeof s.letterSpacing === 'number' ? `${s.letterSpacing}px` : String(s.letterSpacing);
            } else if (!Array.isArray(value)) extractTypo(value);
          }
        }
      };
      extractTypo(data);
    });

    let typoOutput = getJsFileHeader() + `// Brand: ${brand}\n\n`;
    typoOutput += `export const typography = ${JSON.stringify(typography, null, 2)};\n\n`;
    BREAKPOINTS.forEach(bp => { typoOutput += `export const ${bp} = typography.${bp};\n`; });
    if (typography.xs) {
      typoOutput += `\n// Individual style exports\n`;
      Object.entries(typography.xs).forEach(([name]) => {
        typoOutput += `export const ${name} = typography.xs.${name};\n`;
      });
    }
    writeJsFile(path.join(jsDistDir, 'brands', brand, 'typography.js'), typoOutput);

    // Build effects
    if (hasColors) {
      const effects = {};
      COLOR_MODES.forEach(mode => {
        const data = readTokenFile(path.join(TOKENS_DIR, 'brands', brand, 'semantic', 'effects', `effects-${mode}.json`));
        if (!data) return;
        effects[mode] = {};
        const extractFx = (obj) => {
          for (const [key, value] of Object.entries(obj)) {
            if (value && typeof value === 'object') {
              if ('$value' in value && value.$type === 'shadow' && Array.isArray(value.$value)) {
                const name = toCamelCase(key); // Use only last segment
                effects[mode][name] = value.$value.map(l => ({
                  offsetX: l.offsetX || 0, offsetY: l.offsetY || 0,
                  radius: l.radius || 0, spread: l.spread || 0, color: l.color || 'rgba(0,0,0,0)'
                }));
              } else if (!Array.isArray(value)) extractFx(value);
            }
          }
        };
        extractFx(data);
      });

      let fxOutput = getJsFileHeader() + `// Brand: ${brand}\n\n`;
      fxOutput += `export const effects = ${JSON.stringify(effects, null, 2)};\n\n`;
      fxOutput += `export const light = effects.light;\nexport const dark = effects.dark;\n\n`;
      fxOutput += `// Flat exports (light mode) for tree-shaking\n`;
      if (effects.light) {
        Object.entries(effects.light).forEach(([name, value]) => {
          fxOutput += `export const ${name} = ${JSON.stringify(value)};\n`;
        });
      }
      writeJsFile(path.join(jsDistDir, 'brands', brand, 'effects.js'), fxOutput);
    }

    // Build density
    const density = {};
    DENSITY_MODES.forEach(mode => {
      const data = readTokenFile(path.join(TOKENS_DIR, 'brands', brand, 'density', `density-${mode}.json`));
      if (data) density[mode] = flattenTokens(data);
    });

    let densityOutput = getJsFileHeader() + `// Brand: ${brand}\n\n`;
    densityOutput += `export const density = ${JSON.stringify(density, null, 2)};\n\n`;
    DENSITY_MODES.forEach(m => { densityOutput += `export const ${m === 'default' ? 'defaultDensity' : m} = density.${m};\n`; });
    densityOutput += `\n// Flat exports (default density) for tree-shaking\n`;
    if (density.default) {
      Object.entries(density.default).forEach(([name, value]) => {
        densityOutput += `export const ${name} = ${formatJsValue(value)};\n`;
      });
    }
    writeJsFile(path.join(jsDistDir, 'brands', brand, 'density.js'), densityOutput);

    // Build components
    const componentsDir = path.join(TOKENS_DIR, 'brands', brand, 'components');
    if (fs.existsSync(componentsDir)) {
      const componentNames = fs.readdirSync(componentsDir)
        .filter(f => fs.statSync(path.join(componentsDir, f)).isDirectory())
        .filter(f => !f.startsWith('.') && !f.startsWith('_'));

      const builtComponents = [];
      for (const comp of componentNames) {
        const compDir = path.join(componentsDir, comp);
        const files = fs.readdirSync(compDir).filter(f => f.endsWith('.json'));
        if (files.length === 0) continue;

        const component = { colors: {}, sizing: {}, density: {}, typography: {}, effects: {} };
        files.forEach(file => {
          const data = readTokenFile(path.join(compDir, file));
          if (!data) return;
          const tokens = flattenTokens(data);
          if (file.includes('-color-')) {
            component.colors[file.includes('-light') ? 'light' : 'dark'] = tokens;
          } else if (file.includes('-breakpoint-')) {
            const bp = BREAKPOINTS.find(b => file.includes(`-${b}-`) || file.includes(`-${b}.`));
            if (bp) component.sizing[bp] = tokens;
          } else if (file.includes('-density-')) {
            const dm = DENSITY_MODES.find(d => file.includes(`-${d}`));
            if (dm) component.density[dm] = tokens;
          } else if (file.includes('-typography-')) {
            const bp = BREAKPOINTS.find(b => file.includes(`-${b}`));
            if (bp) {
              const typoTokens = {};
              const extractT = (obj) => {
                for (const [k, v] of Object.entries(obj)) {
                  if (v && typeof v === 'object') {
                    if ('$value' in v && v.$type === 'typography') {
                      const s = v.$value;
                      typoTokens[toCamelCase(k)] = {
                        fontFamily: s.fontFamily, fontWeight: s.fontWeight,
                        fontSize: typeof s.fontSize === 'number' ? `${s.fontSize}px` : s.fontSize,
                        lineHeight: typeof s.lineHeight === 'number' ? `${s.lineHeight}px` : String(s.lineHeight)
                      };
                    } else if (!Array.isArray(v)) extractT(v);
                  }
                }
              };
              extractT(data);
              component.typography[bp] = typoTokens;
            }
          } else if (file.includes('-effects-')) {
            const mode = file.includes('-light') ? 'light' : 'dark';
            const fxTokens = {};
            const extractE = (obj) => {
              for (const [k, v] of Object.entries(obj)) {
                if (v && typeof v === 'object') {
                  if ('$value' in v && v.$type === 'shadow' && Array.isArray(v.$value)) {
                    fxTokens[toCamelCase(k)] = v.$value.map(l => ({
                      offsetX: l.offsetX || 0, offsetY: l.offsetY || 0,
                      radius: l.radius || 0, spread: l.spread || 0, color: l.color
                    }));
                  } else if (!Array.isArray(v)) extractE(v);
                }
              }
            };
            extractE(data);
            component.effects[mode] = fxTokens;
          }
        });

        // Remove empty
        Object.keys(component).forEach(k => { if (Object.keys(component[k]).length === 0) delete component[k]; });
        if (Object.keys(component).length === 0) continue;

        let compOutput = getJsFileHeader() + `// Component: ${comp}\n// Brand: ${brand}\n\n`;
        compOutput += `export const ${comp} = ${JSON.stringify(component, null, 2)};\n\n`;
        compOutput += `export const get${comp}Tokens = (colorMode = 'light', breakpoint = 'md', density = 'default') => ({\n`;
        compOutput += `  ...${comp}.colors?.[colorMode],\n  ...${comp}.sizing?.[breakpoint],\n`;
        compOutput += `  ...${comp}.density?.[density],\n  ...${comp}.typography?.[breakpoint],\n`;
        compOutput += `  ...${comp}.effects?.[colorMode]\n});\n\n`;

        // Add flat exports for tree-shaking (light colors, xs sizing, default density)
        compOutput += `// Flat exports for tree-shaking\n`;
        if (component.colors?.light) {
          Object.entries(component.colors.light).forEach(([name, value]) => {
            compOutput += `export const ${name} = ${formatJsValue(value)};\n`;
          });
        }
        if (component.sizing?.xs) {
          Object.entries(component.sizing.xs).forEach(([name, value]) => {
            compOutput += `export const ${name} = ${formatJsValue(value)};\n`;
          });
        }
        if (component.density?.default) {
          Object.entries(component.density.default).forEach(([name, value]) => {
            compOutput += `export const ${name} = ${formatJsValue(value)};\n`;
          });
        }
        compOutput += `\nexport default ${comp};\n`;
        writeJsFile(path.join(jsDistDir, 'brands', brand, 'components', `${comp}.js`), compOutput);
        builtComponents.push(comp);
      }

      // Components index
      if (builtComponents.length > 0) {
        let compIdx = getJsFileHeader() + `// Components for ${brand}\n\n`;
        builtComponents.forEach(c => { compIdx += `export { ${c}, get${c}Tokens } from './${c}.js';\n`; });
        writeJsFile(path.join(jsDistDir, 'brands', brand, 'components', 'index.js'), compIdx);
      }
    }

    // Brand index
    let brandIdx = getJsFileHeader() + `// ${brand.toUpperCase()} Brand\n\n`;
    if (hasColors) brandIdx += `export * from './colors.js';\nexport { colors } from './colors.js';\n`;
    brandIdx += `export * from './spacing.js';\nexport { spacing } from './spacing.js';\n`;
    brandIdx += `export * from './typography.js';\nexport { typography } from './typography.js';\n`;
    if (hasColors) brandIdx += `export * from './effects.js';\nexport { effects } from './effects.js';\n`;
    brandIdx += `export * from './density.js';\nexport { density } from './density.js';\n`;
    brandIdx += `export * as components from './components/index.js';\n`;
    writeJsFile(path.join(jsDistDir, 'brands', brand, 'index.js'), brandIdx);
  }

  // Brands index
  let brandsIdx = getJsFileHeader() + `// Brand exports\n\n`;
  BRANDS.forEach(b => { brandsIdx += `export * as ${b} from './${b}/index.js';\n`; });
  writeJsFile(path.join(jsDistDir, 'brands', 'index.js'), brandsIdx);

  // Root index
  let rootIdx = getJsFileHeader() + `// BILD Design System Tokens\n\n`;
  rootIdx += `export * as primitives from './primitives/index.js';\n`;
  rootIdx += `export * as brands from './brands/index.js';\n\n`;
  BRANDS.forEach(b => { rootIdx += `export * as ${b} from './brands/${b}/index.js';\n`; });
  writeJsFile(path.join(jsDistDir, 'index.js'), rootIdx);

  // ========================================
  // TYPESCRIPT DEFINITIONS
  // ========================================
  console.log('\n  ðŸ“ Generating TypeScript definitions...');

  // Type definitions header
  const TS_HEADER = `/**
 * TypeScript definitions for BILD Design System Tokens
 * Auto-generated - Do not edit directly
 */

`;

  // Helper interfaces
  const baseTypes = TS_HEADER + `// Base type definitions

export interface TypographyStyle {
  fontFamily: string | null;
  fontWeight: number;
  fontSize: string;
  lineHeight: string;
  letterSpacing?: string;
  fontStyle?: string;
  textTransform?: string;
  textDecoration?: string;
}

export interface ShadowLayer {
  offsetX: number;
  offsetY: number;
  radius: number;
  spread: number;
  color: string;
}

export type ColorValue = string;
export type SpacingValue = string;
export type SizeValue = string;

`;

  // Generate primitives types
  let primitivesTypes = TS_HEADER + `import type { ColorValue, SpacingValue, SizeValue } from '../types';\n\n`;
  primitivesTypes += `export interface Primitives {\n`;
  primitivesTypes += `  colors: Record<string, ColorValue>;\n`;
  primitivesTypes += `  spacing: Record<string, SpacingValue>;\n`;
  primitivesTypes += `  sizing: Record<string, SizeValue>;\n`;
  primitivesTypes += `  fonts: Record<string, string | number>;\n`;
  primitivesTypes += `}\n\n`;
  primitivesTypes += `export declare const primitives: Primitives;\n`;
  primitivesTypes += `export declare const colors: Primitives['colors'];\n`;
  primitivesTypes += `export declare const spacing: Primitives['spacing'];\n`;
  primitivesTypes += `export declare const sizing: Primitives['sizing'];\n`;
  primitivesTypes += `export declare const fonts: Primitives['fonts'];\n\n`;
  // Add flat exports
  Object.values(primitives).forEach(category => {
    Object.keys(category).forEach(name => {
      primitivesTypes += `export declare const ${name}: string;\n`;
    });
  });

  writeJsFile(path.join(jsDistDir, 'types.d.ts'), baseTypes);
  writeJsFile(path.join(jsDistDir, 'primitives', 'index.d.ts'), primitivesTypes);

  // Generate brand types
  for (const brand of BRANDS) {
    const hasColors = COLOR_BRANDS.includes(brand);

    // Colors types
    if (hasColors) {
      const colorData = {};
      COLOR_MODES.forEach(mode => {
        const data = readTokenFile(path.join(TOKENS_DIR, 'brands', brand, 'color', `colormode-${mode}.json`));
        if (data) colorData[mode] = flattenTokens(data);
      });

      let colorsTypes = TS_HEADER + `import type { ColorValue } from '../../types';\n\n`;
      colorsTypes += `export interface ColorTokens {\n`;
      colorsTypes += `  light: Record<string, ColorValue>;\n`;
      colorsTypes += `  dark: Record<string, ColorValue>;\n`;
      colorsTypes += `}\n\n`;
      colorsTypes += `export declare const colors: ColorTokens;\n`;
      colorsTypes += `export declare const light: ColorTokens['light'];\n`;
      colorsTypes += `export declare const dark: ColorTokens['dark'];\n\n`;
      colorsTypes += `// Flat exports (light mode)\n`;
      if (colorData.light) {
        Object.keys(colorData.light).forEach(name => {
          colorsTypes += `export declare const ${name}: ColorValue;\n`;
        });
      }
      writeJsFile(path.join(jsDistDir, 'brands', brand, 'colors.d.ts'), colorsTypes);
    }

    // Spacing types
    const spacingData = {};
    BREAKPOINTS.forEach(bp => {
      const bpDir = path.join(TOKENS_DIR, 'brands', brand, 'breakpoints');
      if (fs.existsSync(bpDir)) {
        const files = fs.readdirSync(bpDir).filter(f => f.startsWith(`breakpoint-${bp}`));
        if (files.length > 0) {
          const data = readTokenFile(path.join(bpDir, files[0]));
          if (data) spacingData[bp] = flattenTokens(data);
        }
      }
    });

    let spacingTypes = TS_HEADER + `import type { SpacingValue } from '../../types';\n\n`;
    spacingTypes += `export interface SpacingTokens {\n`;
    BREAKPOINTS.forEach(bp => { spacingTypes += `  ${bp}: Record<string, SpacingValue>;\n`; });
    spacingTypes += `}\n\n`;
    spacingTypes += `export declare const spacing: SpacingTokens;\n`;
    BREAKPOINTS.forEach(bp => { spacingTypes += `export declare const ${bp}: SpacingTokens['${bp}'];\n`; });
    spacingTypes += `\n// Flat exports (xs breakpoint)\n`;
    if (spacingData.xs) {
      Object.keys(spacingData.xs).forEach(name => {
        spacingTypes += `export declare const ${name}: SpacingValue;\n`;
      });
    }
    writeJsFile(path.join(jsDistDir, 'brands', brand, 'spacing.d.ts'), spacingTypes);

    // Typography types
    const typoData = {};
    BREAKPOINTS.forEach(bp => {
      const data = readTokenFile(path.join(TOKENS_DIR, 'brands', brand, 'semantic', 'typography', `typography-${bp}.json`));
      if (data) {
        typoData[bp] = {};
        const extractT = (obj) => {
          for (const [key, value] of Object.entries(obj)) {
            if (value && typeof value === 'object') {
              if ('$value' in value && value.$type === 'typography') {
                typoData[bp][toCamelCase(key)] = true;
              } else if (!Array.isArray(value)) extractT(value);
            }
          }
        };
        extractT(data);
      }
    });

    let typoTypes = TS_HEADER + `import type { TypographyStyle } from '../../types';\n\n`;
    typoTypes += `export interface TypographyTokens {\n`;
    BREAKPOINTS.forEach(bp => { typoTypes += `  ${bp}: Record<string, TypographyStyle>;\n`; });
    typoTypes += `}\n\n`;
    typoTypes += `export declare const typography: TypographyTokens;\n`;
    BREAKPOINTS.forEach(bp => { typoTypes += `export declare const ${bp}: TypographyTokens['${bp}'];\n`; });
    typoTypes += `\n// Flat exports (xs breakpoint)\n`;
    if (typoData.xs) {
      Object.keys(typoData.xs).forEach(name => {
        typoTypes += `export declare const ${name}: TypographyStyle;\n`;
      });
    }
    writeJsFile(path.join(jsDistDir, 'brands', brand, 'typography.d.ts'), typoTypes);

    // Effects types
    if (hasColors) {
      const fxData = {};
      COLOR_MODES.forEach(mode => {
        const data = readTokenFile(path.join(TOKENS_DIR, 'brands', brand, 'semantic', 'effects', `effects-${mode}.json`));
        if (data) {
          fxData[mode] = {};
          const extractFx = (obj) => {
            for (const [key, value] of Object.entries(obj)) {
              if (value && typeof value === 'object') {
                if ('$value' in value && value.$type === 'shadow') {
                  fxData[mode][toCamelCase(key)] = true;
                } else if (!Array.isArray(value)) extractFx(value);
              }
            }
          };
          extractFx(data);
        }
      });

      let fxTypes = TS_HEADER + `import type { ShadowLayer } from '../../types';\n\n`;
      fxTypes += `export interface EffectsTokens {\n`;
      fxTypes += `  light: Record<string, ShadowLayer[]>;\n`;
      fxTypes += `  dark: Record<string, ShadowLayer[]>;\n`;
      fxTypes += `}\n\n`;
      fxTypes += `export declare const effects: EffectsTokens;\n`;
      fxTypes += `export declare const light: EffectsTokens['light'];\n`;
      fxTypes += `export declare const dark: EffectsTokens['dark'];\n\n`;
      fxTypes += `// Flat exports (light mode)\n`;
      if (fxData.light) {
        Object.keys(fxData.light).forEach(name => {
          fxTypes += `export declare const ${name}: ShadowLayer[];\n`;
        });
      }
      writeJsFile(path.join(jsDistDir, 'brands', brand, 'effects.d.ts'), fxTypes);
    }

    // Density types
    const densityData = {};
    DENSITY_MODES.forEach(mode => {
      const data = readTokenFile(path.join(TOKENS_DIR, 'brands', brand, 'density', `density-${mode}.json`));
      if (data) densityData[mode] = flattenTokens(data);
    });

    let densityTypes = TS_HEADER + `import type { SizeValue } from '../../types';\n\n`;
    densityTypes += `export interface DensityTokens {\n`;
    DENSITY_MODES.forEach(m => { densityTypes += `  ${m}: Record<string, SizeValue>;\n`; });
    densityTypes += `}\n\n`;
    densityTypes += `export declare const density: DensityTokens;\n`;
    DENSITY_MODES.forEach(m => { densityTypes += `export declare const ${m === 'default' ? 'defaultDensity' : m}: DensityTokens['${m}'];\n`; });
    densityTypes += `\n// Flat exports (default density)\n`;
    if (densityData.default) {
      Object.keys(densityData.default).forEach(name => {
        densityTypes += `export declare const ${name}: SizeValue;\n`;
      });
    }
    writeJsFile(path.join(jsDistDir, 'brands', brand, 'density.d.ts'), densityTypes);

    // Component types
    const componentsDir = path.join(TOKENS_DIR, 'brands', brand, 'components');
    if (fs.existsSync(componentsDir)) {
      const componentNames = fs.readdirSync(componentsDir)
        .filter(f => fs.statSync(path.join(componentsDir, f)).isDirectory())
        .filter(f => !f.startsWith('.') && !f.startsWith('_'));

      for (const comp of componentNames) {
        // Read component tokens for flat export declarations
        const compDir = path.join(componentsDir, comp);
        const compFiles = fs.readdirSync(compDir).filter(f => f.endsWith('.json'));
        const flatTokenNames = new Set();

        compFiles.forEach(file => {
          const data = readTokenFile(path.join(compDir, file));
          if (!data) return;
          if (file.includes('-color-') && file.includes('-light')) {
            Object.keys(flattenTokens(data)).forEach(n => flatTokenNames.add(n));
          } else if (file.includes('-breakpoint-') && file.includes('-xs')) {
            Object.keys(flattenTokens(data)).forEach(n => flatTokenNames.add(n));
          } else if (file.includes('-density-') && file.includes('-default')) {
            Object.keys(flattenTokens(data)).forEach(n => flatTokenNames.add(n));
          }
        });

        let compTypes = TS_HEADER + `import type { ColorValue, SpacingValue, TypographyStyle, ShadowLayer } from '../../../types';\n\n`;
        compTypes += `export interface ${comp}Tokens {\n`;
        compTypes += `  colors?: { light?: Record<string, ColorValue>; dark?: Record<string, ColorValue>; };\n`;
        compTypes += `  sizing?: { xs?: Record<string, SpacingValue>; sm?: Record<string, SpacingValue>; md?: Record<string, SpacingValue>; lg?: Record<string, SpacingValue>; };\n`;
        compTypes += `  density?: { default?: Record<string, SpacingValue>; dense?: Record<string, SpacingValue>; spacious?: Record<string, SpacingValue>; };\n`;
        compTypes += `  typography?: { xs?: Record<string, TypographyStyle>; sm?: Record<string, TypographyStyle>; md?: Record<string, TypographyStyle>; lg?: Record<string, TypographyStyle>; };\n`;
        compTypes += `  effects?: { light?: Record<string, ShadowLayer[]>; dark?: Record<string, ShadowLayer[]>; };\n`;
        compTypes += `}\n\n`;
        compTypes += `export declare const ${comp}: ${comp}Tokens;\n`;
        compTypes += `export declare function get${comp}Tokens(colorMode?: 'light' | 'dark', breakpoint?: 'xs' | 'sm' | 'md' | 'lg', density?: 'default' | 'dense' | 'spacious'): Record<string, any>;\n\n`;
        compTypes += `// Flat exports\n`;
        flatTokenNames.forEach(name => {
          compTypes += `export declare const ${name}: string | number;\n`;
        });
        compTypes += `\nexport default ${comp};\n`;
        writeJsFile(path.join(jsDistDir, 'brands', brand, 'components', `${comp}.d.ts`), compTypes);
      }

      // Components index types
      if (componentNames.length > 0) {
        let compIdxTypes = TS_HEADER;
        componentNames.forEach(c => {
          compIdxTypes += `export { ${c}, get${c}Tokens } from './${c}';\n`;
        });
        writeJsFile(path.join(jsDistDir, 'brands', brand, 'components', 'index.d.ts'), compIdxTypes);
      }
    }

    // Brand index types
    let brandIdxTypes = TS_HEADER;
    if (hasColors) brandIdxTypes += `export * from './colors';\nexport { colors } from './colors';\n`;
    brandIdxTypes += `export * from './spacing';\nexport { spacing } from './spacing';\n`;
    brandIdxTypes += `export * from './typography';\nexport { typography } from './typography';\n`;
    if (hasColors) brandIdxTypes += `export * from './effects';\nexport { effects } from './effects';\n`;
    brandIdxTypes += `export * from './density';\nexport { density } from './density';\n`;
    brandIdxTypes += `export * as components from './components';\n`;
    writeJsFile(path.join(jsDistDir, 'brands', brand, 'index.d.ts'), brandIdxTypes);
  }

  // Brands index types
  let brandsIdxTypes = TS_HEADER;
  BRANDS.forEach(b => { brandsIdxTypes += `export * as ${b} from './${b}';\n`; });
  writeJsFile(path.join(jsDistDir, 'brands', 'index.d.ts'), brandsIdxTypes);

  // Root index types
  let rootIdxTypes = TS_HEADER;
  rootIdxTypes += `export * as primitives from './primitives';\n`;
  rootIdxTypes += `export * as brands from './brands';\n`;
  rootIdxTypes += `export * as themes from './themes';\n\n`;
  BRANDS.forEach(b => { rootIdxTypes += `export * as ${b} from './brands/${b}';\n`; });
  rootIdxTypes += `\n// Re-export types\n`;
  rootIdxTypes += `export type { TypographyStyle, ShadowLayer, ColorValue, SpacingValue, SizeValue } from './types';\n`;
  rootIdxTypes += `export type { Theme, ThemeConfig } from './themes';\n`;
  writeJsFile(path.join(jsDistDir, 'index.d.ts'), rootIdxTypes);

  // ========================================
  // THEME PROVIDER & UTILITIES
  // ========================================
  console.log('\n  ðŸŽ¨ Generating themes...');

  const themesDir = path.join(jsDistDir, 'themes');

  // ========================================
  // Build token data lookup for createTheme
  // ========================================

  // Helper to extract typography from token data (uses last segment only)
  const extractTypography = (data) => {
    const result = {};
    if (!data) return result;
    const extract = (obj) => {
      for (const [key, value] of Object.entries(obj)) {
        if (value && typeof value === 'object') {
          if ('$value' in value && value.$type === 'typography') {
            // Use only the last key as token name (matching Style Dictionary)
            const name = toCamelCase(key);
            const s = value.$value;
            result[name] = {
              fontFamily: s.fontFamily,
              fontWeight: s.fontWeight || 400,
              fontSize: typeof s.fontSize === 'number' ? `${s.fontSize}px` : s.fontSize,
              lineHeight: typeof s.lineHeight === 'number' ? `${s.lineHeight}px` : String(s.lineHeight)
            };
          } else if (!Array.isArray(value)) {
            extract(value);
          }
        }
      }
    };
    extract(data);
    return result;
  };

  // Helper to extract effects from token data (uses last segment only)
  const extractEffects = (data) => {
    const result = {};
    if (!data) return result;
    const extract = (obj) => {
      for (const [key, value] of Object.entries(obj)) {
        if (value && typeof value === 'object') {
          if ('$value' in value && value.$type === 'shadow' && Array.isArray(value.$value)) {
            // Use only the last key as token name (matching Style Dictionary)
            const name = toCamelCase(key);
            result[name] = value.$value.map(l => ({
              offsetX: l.offsetX || 0,
              offsetY: l.offsetY || 0,
              radius: l.radius || 0,
              spread: l.spread || 0,
              color: l.color || 'rgba(0,0,0,0)'
            }));
          } else if (!Array.isArray(value)) {
            extract(value);
          }
        }
      }
    };
    extract(data);
    return result;
  };

  // Build complete token lookup
  const tokenLookup = {
    colors: {},    // [colorBrand][colorMode]
    spacing: {},   // [brand][breakpoint]
    typography: {},// [brand][breakpoint]
    effects: {},   // [colorBrand][colorMode]
    density: {}    // [brand][densityMode]
  };

  // Load colors and effects for color brands (bild, sportbild)
  for (const colorBrand of COLOR_BRANDS) {
    tokenLookup.colors[colorBrand] = {};
    tokenLookup.effects[colorBrand] = {};

    for (const colorMode of COLOR_MODES) {
      const colorsData = readTokenFile(path.join(TOKENS_DIR, 'brands', colorBrand, 'color', `colormode-${colorMode}.json`));
      tokenLookup.colors[colorBrand][colorMode] = colorsData ? flattenTokens(colorsData) : {};

      const effectsData = readTokenFile(path.join(TOKENS_DIR, 'brands', colorBrand, 'semantic', 'effects', `effects-${colorMode}.json`));
      tokenLookup.effects[colorBrand][colorMode] = extractEffects(effectsData);
    }
  }

  // Load spacing, typography, density for all brands
  for (const brand of BRANDS) {
    tokenLookup.spacing[brand] = {};
    tokenLookup.typography[brand] = {};
    tokenLookup.density[brand] = {};

    const breakpointsDir = path.join(TOKENS_DIR, 'brands', brand, 'breakpoints');
    if (fs.existsSync(breakpointsDir)) {
      for (const bp of BREAKPOINTS) {
        const bpFile = fs.readdirSync(breakpointsDir).find(f => f.includes(`-${bp}-`) || f.includes(`-${bp}.`));
        if (bpFile) {
          const spacingData = readTokenFile(path.join(breakpointsDir, bpFile));
          tokenLookup.spacing[brand][bp] = spacingData ? flattenTokens(spacingData) : {};
        }
      }
    }

    const typoDir = path.join(TOKENS_DIR, 'brands', brand, 'semantic', 'typography');
    if (fs.existsSync(typoDir)) {
      for (const bp of BREAKPOINTS) {
        const typoData = readTokenFile(path.join(typoDir, `typography-${bp}.json`));
        tokenLookup.typography[brand][bp] = extractTypography(typoData);
      }
    }

    const densityDir = path.join(TOKENS_DIR, 'brands', brand, 'density');
    if (fs.existsSync(densityDir)) {
      for (const dm of DENSITY_MODES) {
        const densityData = readTokenFile(path.join(densityDir, `density-${dm}.json`));
        tokenLookup.density[brand][dm] = densityData ? flattenTokens(densityData) : {};
      }
    }
  }

  // createTheme utility with embedded token data
  let createThemeJs = getJsFileHeader() + `// Theme factory for BILD Design System
// Supports multi-brand, multi-mode token combinations

// Embedded token data for all brand/mode combinations
const tokenData = ${JSON.stringify(tokenLookup, null, 2)};

/**
 * Create a theme by combining tokens from different modes
 * @param {Object} config - Theme configuration
 * @param {string} config.brand - Brand name ('bild', 'sportbild', 'advertorial')
 * @param {string} config.colorBrand - Color brand for Advertorial ('bild' or 'sportbild')
 * @param {string} config.colorMode - Color mode ('light' or 'dark')
 * @param {string} config.breakpoint - Breakpoint ('xs', 'sm', 'md', 'lg')
 * @param {string} config.density - Density mode ('default', 'dense', 'spacious')
 * @returns {Object} Combined theme object with all tokens
 */
export function createTheme(config = {}) {
  const {
    brand = 'bild',
    colorBrand,
    colorMode = 'light',
    breakpoint = 'md',
    density = 'default'
  } = config;

  // Determine color source (for Advertorial dual-axis support)
  // Advertorial uses BILD or SportBILD colors, defaulting to BILD
  const effectiveColorBrand = colorBrand || (brand === 'advertorial' ? 'bild' : brand);

  // Validate inputs
  if (!['bild', 'sportbild', 'advertorial'].includes(brand)) {
    throw new Error(\`Invalid brand: \${brand}. Must be one of: bild, sportbild, advertorial\`);
  }
  if (!['bild', 'sportbild'].includes(effectiveColorBrand)) {
    throw new Error(\`Invalid colorBrand: \${effectiveColorBrand}. Must be one of: bild, sportbild\`);
  }
  if (!['light', 'dark'].includes(colorMode)) {
    throw new Error(\`Invalid colorMode: \${colorMode}. Must be one of: light, dark\`);
  }
  if (!['xs', 'sm', 'md', 'lg'].includes(breakpoint)) {
    throw new Error(\`Invalid breakpoint: \${breakpoint}. Must be one of: xs, sm, md, lg\`);
  }
  if (!['default', 'dense', 'spacious'].includes(density)) {
    throw new Error(\`Invalid density: \${density}. Must be one of: default, dense, spacious\`);
  }

  return {
    __meta: {
      brand,
      colorBrand: effectiveColorBrand,
      colorMode,
      breakpoint,
      density
    },
    colors: tokenData.colors[effectiveColorBrand]?.[colorMode] || {},
    spacing: tokenData.spacing[brand]?.[breakpoint] || {},
    typography: tokenData.typography[brand]?.[breakpoint] || {},
    effects: tokenData.effects[effectiveColorBrand]?.[colorMode] || {},
    density: tokenData.density[brand]?.[density] || {}
  };
}

/**
 * Available brands
 */
export const availableBrands = ['bild', 'sportbild', 'advertorial'];

/**
 * Available color brands (brands with own colors)
 */
export const colorBrands = ['bild', 'sportbild'];

/**
 * Available color modes
 */
export const colorModes = ['light', 'dark'];

/**
 * Available breakpoints
 */
export const breakpoints = ['xs', 'sm', 'md', 'lg'];

/**
 * Available density modes
 */
export const densityModes = ['default', 'dense', 'spacious'];

/**
 * Get token data for a specific combination (lower-level API)
 */
export function getTokens(type, key1, key2) {
  return tokenData[type]?.[key1]?.[key2] || {};
}
`;
  writeJsFile(path.join(themesDir, 'createTheme.js'), createThemeJs);

  // Generate preset themes for each color brand Ã— color mode
  const presetThemes = [];
  for (const colorBrand of COLOR_BRANDS) {
    for (const colorMode of COLOR_MODES) {
      const themeName = `${colorBrand}${colorMode.charAt(0).toUpperCase() + colorMode.slice(1)}`;
      const fileName = `${colorBrand}-${colorMode}`;

      // Read actual token data
      const colorsData = readTokenFile(path.join(TOKENS_DIR, 'brands', colorBrand, 'color', `colormode-${colorMode}.json`));
      const spacingData = readTokenFile(path.join(TOKENS_DIR, 'brands', colorBrand, 'breakpoints',
        fs.readdirSync(path.join(TOKENS_DIR, 'brands', colorBrand, 'breakpoints')).find(f => f.startsWith('breakpoint-md')) || 'breakpoint-md-600px.json'));
      const typographyData = readTokenFile(path.join(TOKENS_DIR, 'brands', colorBrand, 'semantic', 'typography', 'typography-md.json'));
      const effectsData = readTokenFile(path.join(TOKENS_DIR, 'brands', colorBrand, 'semantic', 'effects', `effects-${colorMode}.json`));
      const densityData = readTokenFile(path.join(TOKENS_DIR, 'brands', colorBrand, 'density', 'density-default.json'));

      const colors = colorsData ? flattenTokens(colorsData) : {};
      const spacing = spacingData ? flattenTokens(spacingData) : {};
      const density = densityData ? flattenTokens(densityData) : {};

      // Extract typography (uses last segment only)
      const typography = {};
      if (typographyData) {
        const extractTypo = (obj) => {
          for (const [key, value] of Object.entries(obj)) {
            if (value && typeof value === 'object') {
              if ('$value' in value && value.$type === 'typography') {
                const name = toCamelCase(key);
                const s = value.$value;
                typography[name] = {
                  fontFamily: s.fontFamily, fontWeight: s.fontWeight || 400,
                  fontSize: typeof s.fontSize === 'number' ? `${s.fontSize}px` : s.fontSize,
                  lineHeight: typeof s.lineHeight === 'number' ? `${s.lineHeight}px` : String(s.lineHeight)
                };
              } else if (!Array.isArray(value)) extractTypo(value);
            }
          }
        };
        extractTypo(typographyData);
      }

      // Extract effects (uses last segment only)
      const effects = {};
      if (effectsData) {
        const extractFx = (obj) => {
          for (const [key, value] of Object.entries(obj)) {
            if (value && typeof value === 'object') {
              if ('$value' in value && value.$type === 'shadow' && Array.isArray(value.$value)) {
                const name = toCamelCase(key);
                effects[name] = value.$value.map(l => ({
                  offsetX: l.offsetX || 0, offsetY: l.offsetY || 0,
                  radius: l.radius || 0, spread: l.spread || 0, color: l.color || 'rgba(0,0,0,0)'
                }));
              } else if (!Array.isArray(value)) extractFx(value);
            }
          }
        };
        extractFx(effectsData);
      }

      let themeJs = getJsFileHeader() + `// Pre-built theme: ${colorBrand} ${colorMode}
// Default breakpoint: md, Default density: default

export const ${themeName} = {
  __meta: {
    brand: '${colorBrand}',
    colorBrand: '${colorBrand}',
    colorMode: '${colorMode}',
    breakpoint: 'md',
    density: 'default'
  },
  colors: ${JSON.stringify(colors, null, 2)},
  spacing: ${JSON.stringify(spacing, null, 2)},
  typography: ${JSON.stringify(typography, null, 2)},
  effects: ${JSON.stringify(effects, null, 2)},
  density: ${JSON.stringify(density, null, 2)}
};

export default ${themeName};
`;
      writeJsFile(path.join(themesDir, `${fileName}.js`), themeJs);
      presetThemes.push({ name: themeName, file: fileName });

      // TypeScript definition
      let themeDts = TS_HEADER + `import type { Theme } from './index';\n\n`;
      themeDts += `export declare const ${themeName}: Theme;\n`;
      themeDts += `export default ${themeName};\n`;
      writeJsFile(path.join(themesDir, `${fileName}.d.ts`), themeDts);
    }
  }

  // Generate Advertorial themes (dual-axis: uses BILD or SportBILD colors)
  for (const colorBrand of COLOR_BRANDS) {
    for (const colorMode of COLOR_MODES) {
      const themeName = `advertorialIn${colorBrand.charAt(0).toUpperCase() + colorBrand.slice(1)}${colorMode.charAt(0).toUpperCase() + colorMode.slice(1)}`;
      const fileName = `advertorial-in-${colorBrand}-${colorMode}`;

      // Colors and effects from colorBrand, sizing/typography from advertorial
      const colorsData = readTokenFile(path.join(TOKENS_DIR, 'brands', colorBrand, 'color', `colormode-${colorMode}.json`));
      const effectsData = readTokenFile(path.join(TOKENS_DIR, 'brands', colorBrand, 'semantic', 'effects', `effects-${colorMode}.json`));

      const advSpacingDir = path.join(TOKENS_DIR, 'brands', 'advertorial', 'breakpoints');
      const spacingData = fs.existsSync(advSpacingDir) ?
        readTokenFile(path.join(advSpacingDir, fs.readdirSync(advSpacingDir).find(f => f.startsWith('breakpoint-md')) || '')) : null;
      const advTypoData = readTokenFile(path.join(TOKENS_DIR, 'brands', 'advertorial', 'semantic', 'typography', 'typography-md.json'));
      const advDensityData = readTokenFile(path.join(TOKENS_DIR, 'brands', 'advertorial', 'density', 'density-default.json'));

      const colors = colorsData ? flattenTokens(colorsData) : {};
      const spacing = spacingData ? flattenTokens(spacingData) : {};
      const density = advDensityData ? flattenTokens(advDensityData) : {};

      // Extract typography from advertorial (uses last segment only)
      const typography = {};
      if (advTypoData) {
        const extractTypo = (obj) => {
          for (const [key, value] of Object.entries(obj)) {
            if (value && typeof value === 'object') {
              if ('$value' in value && value.$type === 'typography') {
                const name = toCamelCase(key);
                const s = value.$value;
                typography[name] = {
                  fontFamily: s.fontFamily, fontWeight: s.fontWeight || 400,
                  fontSize: typeof s.fontSize === 'number' ? `${s.fontSize}px` : s.fontSize,
                  lineHeight: typeof s.lineHeight === 'number' ? `${s.lineHeight}px` : String(s.lineHeight)
                };
              } else if (!Array.isArray(value)) extractTypo(value);
            }
          }
        };
        extractTypo(advTypoData);
      }

      // Extract effects from colorBrand (uses last segment only)
      const effects = {};
      if (effectsData) {
        const extractFx = (obj) => {
          for (const [key, value] of Object.entries(obj)) {
            if (value && typeof value === 'object') {
              if ('$value' in value && value.$type === 'shadow' && Array.isArray(value.$value)) {
                const name = toCamelCase(key);
                effects[name] = value.$value.map(l => ({
                  offsetX: l.offsetX || 0, offsetY: l.offsetY || 0,
                  radius: l.radius || 0, spread: l.spread || 0, color: l.color || 'rgba(0,0,0,0)'
                }));
              } else if (!Array.isArray(value)) extractFx(value);
            }
          }
        };
        extractFx(effectsData);
      }

      let themeJs = getJsFileHeader() + `// Pre-built theme: Advertorial with ${colorBrand} colors (${colorMode})
// Dual-axis: Colors from ${colorBrand}, sizing/typography from advertorial

export const ${themeName} = {
  __meta: {
    brand: 'advertorial',
    colorBrand: '${colorBrand}',
    colorMode: '${colorMode}',
    breakpoint: 'md',
    density: 'default'
  },
  colors: ${JSON.stringify(colors, null, 2)},
  spacing: ${JSON.stringify(spacing, null, 2)},
  typography: ${JSON.stringify(typography, null, 2)},
  effects: ${JSON.stringify(effects, null, 2)},
  density: ${JSON.stringify(density, null, 2)}
};

export default ${themeName};
`;
      writeJsFile(path.join(themesDir, `${fileName}.js`), themeJs);
      presetThemes.push({ name: themeName, file: fileName });

      // TypeScript definition
      let themeDts = TS_HEADER + `import type { Theme } from './index';\n\n`;
      themeDts += `export declare const ${themeName}: Theme;\n`;
      themeDts += `export default ${themeName};\n`;
      writeJsFile(path.join(themesDir, `${fileName}.d.ts`), themeDts);
    }
  }

  // Themes index
  let themesIdx = getJsFileHeader() + `// Theme exports\n\n`;
  themesIdx += `export { createTheme, getTokens, availableBrands, colorBrands, colorModes, breakpoints, densityModes } from './createTheme.js';\n\n`;
  themesIdx += `// Pre-built themes\n`;
  presetThemes.forEach(t => { themesIdx += `export { ${t.name} } from './${t.file}.js';\n`; });
  themesIdx += `\n// All themes object\nexport const themes = {\n`;
  presetThemes.forEach(t => { themesIdx += `  ${t.name},\n`; });
  themesIdx += `};\n`;
  writeJsFile(path.join(themesDir, 'index.js'), themesIdx);

  // Themes index types
  let themesIdxDts = TS_HEADER + `import type { TypographyStyle, ShadowLayer } from '../types';\n\n`;
  themesIdxDts += `export interface ThemeMeta {\n`;
  themesIdxDts += `  brand: string;\n  colorBrand: string;\n  colorMode: 'light' | 'dark';\n`;
  themesIdxDts += `  breakpoint: 'xs' | 'sm' | 'md' | 'lg';\n  density: 'default' | 'dense' | 'spacious';\n`;
  themesIdxDts += `}\n\n`;
  themesIdxDts += `export interface Theme {\n`;
  themesIdxDts += `  __meta: ThemeMeta;\n`;
  themesIdxDts += `  colors: Record<string, string>;\n`;
  themesIdxDts += `  spacing: Record<string, string>;\n`;
  themesIdxDts += `  typography: Record<string, TypographyStyle>;\n`;
  themesIdxDts += `  effects: Record<string, ShadowLayer[]>;\n`;
  themesIdxDts += `  density: Record<string, string>;\n`;
  themesIdxDts += `}\n\n`;
  themesIdxDts += `export interface ThemeConfig {\n`;
  themesIdxDts += `  brand?: 'bild' | 'sportbild' | 'advertorial';\n`;
  themesIdxDts += `  colorBrand?: 'bild' | 'sportbild';\n`;
  themesIdxDts += `  colorMode?: 'light' | 'dark';\n`;
  themesIdxDts += `  breakpoint?: 'xs' | 'sm' | 'md' | 'lg';\n`;
  themesIdxDts += `  density?: 'default' | 'dense' | 'spacious';\n`;
  themesIdxDts += `}\n\n`;
  themesIdxDts += `export declare function createTheme(config?: ThemeConfig): Theme;\n`;
  themesIdxDts += `export declare function getTokens(type: 'colors' | 'spacing' | 'typography' | 'effects' | 'density', key1: string, key2: string): Record<string, any>;\n`;
  themesIdxDts += `export declare const availableBrands: readonly ['bild', 'sportbild', 'advertorial'];\n`;
  themesIdxDts += `export declare const colorBrands: readonly ['bild', 'sportbild'];\n`;
  themesIdxDts += `export declare const colorModes: readonly ['light', 'dark'];\n`;
  themesIdxDts += `export declare const breakpoints: readonly ['xs', 'sm', 'md', 'lg'];\n`;
  themesIdxDts += `export declare const densityModes: readonly ['default', 'dense', 'spacious'];\n\n`;
  themesIdxDts += `// Pre-built themes\n`;
  presetThemes.forEach(t => { themesIdxDts += `export declare const ${t.name}: Theme;\n`; });
  themesIdxDts += `\nexport declare const themes: Record<string, Theme>;\n`;
  writeJsFile(path.join(themesDir, 'index.d.ts'), themesIdxDts);

  // Update root index to include themes
  rootIdx = getJsFileHeader() + `// BILD Design System Tokens\n\n`;
  rootIdx += `export * as primitives from './primitives/index.js';\n`;
  rootIdx += `export * as brands from './brands/index.js';\n`;
  rootIdx += `export * as themes from './themes/index.js';\n`;
  rootIdx += `export * as react from './react/index.js';\n\n`;
  BRANDS.forEach(b => { rootIdx += `export * as ${b} from './brands/${b}/index.js';\n`; });
  writeJsFile(path.join(jsDistDir, 'index.js'), rootIdx);

  console.log(`  âœ… Generated ${presetThemes.length} pre-built themes`);

  // ========================================
  // REACT BINDINGS
  // ========================================
  console.log('\n  âš›ï¸  Generating React bindings...');

  const reactDir = path.join(jsDistDir, 'react');
  fs.mkdirSync(reactDir, { recursive: true });

  // ThemeContext.js
  const themeContextJs = getJsFileHeader() + `// React Context for BILD Design System Theme

import { createContext } from 'react';

export const ThemeContext = createContext(null);

export default ThemeContext;
`;
  writeJsFile(path.join(reactDir, 'ThemeContext.js'), themeContextJs);

  // useTheme.js
  const useThemeJs = getJsFileHeader() + `// Hook to access the current theme

import { useContext } from 'react';
import { ThemeContext } from './ThemeContext.js';

export function useTheme() {
  const context = useContext(ThemeContext);

  if (context === null) {
    throw new Error(
      'useTheme must be used within a ThemeProvider. ' +
      'Wrap your component tree with <ThemeProvider>.'
    );
  }

  return context;
}

export default useTheme;
`;
  writeJsFile(path.join(reactDir, 'useTheme.js'), useThemeJs);

  // useBreakpoint.js
  const useBreakpointJs = getJsFileHeader() + `// Hook for responsive breakpoint detection

import { useState, useEffect } from 'react';

const BREAKPOINTS = {
  xs: 320,
  sm: 390,
  md: 600,
  lg: 1024
};

function detectBreakpoint() {
  if (typeof window === 'undefined') return null;
  const width = window.innerWidth;
  if (width >= BREAKPOINTS.lg) return 'lg';
  if (width >= BREAKPOINTS.md) return 'md';
  if (width >= BREAKPOINTS.sm) return 'sm';
  return 'xs';
}

export function useBreakpoint(defaultBreakpoint = 'md') {
  const [breakpoint, setBreakpoint] = useState(
    () => detectBreakpoint() || defaultBreakpoint
  );

  useEffect(() => {
    // SSR check
    if (typeof window === 'undefined') return;

    const handleResize = () => {
      const detected = detectBreakpoint();
      if (detected) setBreakpoint(detected);
    };

    // Set initial value
    handleResize();

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return breakpoint;
}

export function useIsBreakpoint(target) {
  const current = useBreakpoint();
  return current === target;
}

export function useIsBreakpointUp(target) {
  const current = useBreakpoint();
  const order = ['xs', 'sm', 'md', 'lg'];
  return order.indexOf(current) >= order.indexOf(target);
}

export function useIsBreakpointDown(target) {
  const current = useBreakpoint();
  const order = ['xs', 'sm', 'md', 'lg'];
  return order.indexOf(current) <= order.indexOf(target);
}

export { BREAKPOINTS };

export default useBreakpoint;
`;
  writeJsFile(path.join(reactDir, 'useBreakpoint.js'), useBreakpointJs);

  // ThemeProvider.js
  const themeProviderJs = getJsFileHeader() + `// ThemeProvider component for BILD Design System

import { createElement, useState, useMemo, useEffect } from 'react';
import { ThemeContext } from './ThemeContext.js';
import { createTheme } from '../themes/createTheme.js';

const BREAKPOINT_VALUES = {
  xs: 320,
  sm: 390,
  md: 600,
  lg: 1024
};

function detectBreakpoint() {
  if (typeof window === 'undefined') return null;
  const width = window.innerWidth;
  if (width >= BREAKPOINT_VALUES.lg) return 'lg';
  if (width >= BREAKPOINT_VALUES.md) return 'md';
  if (width >= BREAKPOINT_VALUES.sm) return 'sm';
  return 'xs';
}

export function ThemeProvider({
  brand = 'bild',
  colorBrand,
  colorMode = 'light',
  breakpoint = 'md',
  density = 'default',
  autoBreakpoint = false,
  children
}) {
  // Breakpoint state for auto-detection
  const [detectedBreakpoint, setDetectedBreakpoint] = useState(
    () => (autoBreakpoint ? detectBreakpoint() : null) || breakpoint
  );

  // Window resize listener (only when autoBreakpoint=true)
  useEffect(() => {
    if (!autoBreakpoint) return;
    if (typeof window === 'undefined') return;

    const handleResize = () => {
      const detected = detectBreakpoint();
      if (detected) setDetectedBreakpoint(detected);
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [autoBreakpoint]);

  // Effective breakpoint (prop or auto-detected)
  const effectiveBreakpoint = autoBreakpoint ? detectedBreakpoint : breakpoint;

  // Create theme object via createTheme()
  const theme = useMemo(() => {
    return createTheme({
      brand,
      colorBrand,
      colorMode,
      breakpoint: effectiveBreakpoint,
      density
    });
  }, [brand, colorBrand, colorMode, effectiveBreakpoint, density]);

  // Context value with additional metadata
  const contextValue = useMemo(() => ({
    ...theme,
    // Expose current configuration
    brand,
    colorBrand: theme.__meta?.colorBrand || colorBrand || (brand === 'advertorial' ? 'bild' : brand),
    colorMode,
    breakpoint: effectiveBreakpoint,
    density,
    autoBreakpoint
  }), [theme, brand, colorBrand, colorMode, effectiveBreakpoint, density, autoBreakpoint]);

  // Render provider using createElement (no JSX transpilation needed)
  return createElement(ThemeContext.Provider, { value: contextValue }, children);
}

export default ThemeProvider;
`;
  writeJsFile(path.join(reactDir, 'ThemeProvider.js'), themeProviderJs);

  // React index.js
  const reactIndexJs = getJsFileHeader() + `// React bindings for BILD Design System

export { ThemeContext } from './ThemeContext.js';
export { ThemeProvider } from './ThemeProvider.js';
export { useTheme } from './useTheme.js';
export {
  useBreakpoint,
  useIsBreakpoint,
  useIsBreakpointUp,
  useIsBreakpointDown,
  BREAKPOINTS
} from './useBreakpoint.js';
`;
  writeJsFile(path.join(reactDir, 'index.js'), reactIndexJs);

  // React TypeScript definitions
  const reactIndexDts = `/**
 * TypeScript definitions for BILD Design System React bindings
 * Auto-generated - Do not edit directly
 */

import { Context, ReactNode } from 'react';

// Brand and mode types
export type Brand = 'bild' | 'sportbild' | 'advertorial';
export type ColorBrand = 'bild' | 'sportbild';
export type ColorMode = 'light' | 'dark';
export type Breakpoint = 'xs' | 'sm' | 'md' | 'lg';
export type Density = 'default' | 'dense' | 'spacious';

// Theme context value
export interface ThemeContextValue {
  brand: Brand;
  colorBrand: ColorBrand;
  colorMode: ColorMode;
  breakpoint: Breakpoint;
  density: Density;
  autoBreakpoint: boolean;
  colors: Record<string, string | number>;
  spacing: Record<string, string | number>;
  typography: Record<string, {
    fontFamily: string;
    fontWeight: number;
    fontSize: string;
    lineHeight: string;
    letterSpacing?: string;
  }>;
  effects: Record<string, Array<{
    offsetX: number;
    offsetY: number;
    radius: number;
    spread: number;
    color: string;
  }>>;
  __meta?: {
    brand: Brand;
    colorBrand: ColorBrand;
    colorMode: ColorMode;
    breakpoint: Breakpoint;
    density: Density;
  };
}

// ThemeProvider props
export interface ThemeProviderProps {
  brand?: Brand;
  colorBrand?: ColorBrand;
  colorMode?: ColorMode;
  breakpoint?: Breakpoint;
  density?: Density;
  autoBreakpoint?: boolean;
  children: ReactNode;
}

// Breakpoints constant
export declare const BREAKPOINTS: {
  xs: 320;
  sm: 390;
  md: 600;
  lg: 1024;
};

// Context
export declare const ThemeContext: Context<ThemeContextValue | null>;

// Components
export declare function ThemeProvider(props: ThemeProviderProps): JSX.Element;

// Hooks
export declare function useTheme(): ThemeContextValue;
export declare function useBreakpoint(defaultBreakpoint?: Breakpoint): Breakpoint;
export declare function useIsBreakpoint(target: Breakpoint): boolean;
export declare function useIsBreakpointUp(target: Breakpoint): boolean;
export declare function useIsBreakpointDown(target: Breakpoint): boolean;
`;
  writeJsFile(path.join(reactDir, 'index.d.ts'), reactIndexDts);

  console.log('  âœ… Generated React bindings (ThemeProvider, useTheme, useBreakpoint)');

  // Count files
  const countFiles = (dir, ext = '.js') => {
    if (!fs.existsSync(dir)) return 0;
    let count = 0;
    fs.readdirSync(dir).forEach(item => {
      const p = path.join(dir, item);
      if (fs.statSync(p).isDirectory()) count += countFiles(p, ext);
      else if (item.endsWith(ext)) count++;
    });
    return count;
  };

  // ========================================
  // MINIFIED BUILD
  // ========================================
  console.log('\n  ðŸ—œï¸  Generating minified build...');

  const minEsmDir = path.join(DIST_DIR, 'js.min');

  if (fs.existsSync(minEsmDir)) fs.rmSync(minEsmDir, { recursive: true });

  // Recursively minify all JS files
  const minifyDir = (srcDir, destDir, ext) => {
    if (!fs.existsSync(srcDir)) return;
    fs.mkdirSync(destDir, { recursive: true });

    const items = fs.readdirSync(srcDir);
    items.forEach(item => {
      const srcPath = path.join(srcDir, item);
      const stat = fs.statSync(srcPath);

      if (stat.isDirectory()) {
        minifyDir(srcPath, path.join(destDir, item), ext);
      } else if (item.endsWith(ext)) {
        const content = fs.readFileSync(srcPath, 'utf8');
        const minContent = minifyJs(content);
        const destPath = path.join(destDir, item);
        fs.writeFileSync(destPath, minContent, 'utf8');
      }
    });
  };

  minifyDir(jsDistDir, minEsmDir, '.js');

  const jsCount = countFiles(jsDistDir, '.js');
  const dtsCount = countFiles(jsDistDir, '.d.ts');
  const minEsmCount = countFiles(minEsmDir, '.js');

  // Calculate size reduction
  const getDirectorySize = (dir) => {
    let size = 0;
    const walk = (d) => {
      if (!fs.existsSync(d)) return;
      fs.readdirSync(d).forEach(f => {
        const p = path.join(d, f);
        const s = fs.statSync(p);
        if (s.isDirectory()) walk(p);
        else size += s.size;
      });
    };
    walk(dir);
    return size;
  };

  const esmSize = getDirectorySize(jsDistDir);
  const minEsmSize = getDirectorySize(minEsmDir);
  const reduction = Math.round((1 - minEsmSize / esmSize) * 100);

  console.log(`\n  âœ… ESM modules: ${jsCount} files`);
  console.log(`  âœ… Minified ESM: ${minEsmCount} files (${reduction}% smaller)`);
  console.log(`  âœ… TypeScript definitions: ${dtsCount} files`);
}

/**
 * Main function
 */
async function main() {
  console.log('ðŸŽ¨ ============================================');
  console.log('   BILD Design System - Token Build v2');
  console.log('   ============================================\n');

  // Clean dist
  cleanDist();

  // Register custom config
  registerCustomConfig();

  // Check if tokens directory exists
  if (!fs.existsSync(TOKENS_DIR)) {
    console.error('âŒ Tokens directory not found!');
    console.error('   Run "npm run preprocess" first.\n');
    process.exit(1);
  }

  const stats = {};

  // Build shared primitives
  stats.sharedPrimitives = await buildSharedPrimitives();

  // Build shared density tokens (brand-independent, via Style Dictionary)
  stats.sharedDensity = await buildSharedDensityTokens();

  // Build brand-specific tokens
  stats.brandSpecific = await buildBrandSpecificTokens();

  // Build component tokens
  stats.componentTokens = await buildComponentTokens();

  // Optimize component color CSS (consolidate semantic-only mode files)
  stats.colorCssOptimization = await optimizeComponentColorCSS();

  // Build typography tokens
  stats.typographyTokens = await buildTypographyTokens();

  // Build effect tokens
  stats.effectTokens = await buildEffectTokens();

  // Optimize component effects CSS (consolidate identical light/dark effects)
  stats.effectsCssOptimization = await optimizeComponentEffectsCSS();

  // Convert to responsive CSS
  stats.responsiveCSS = await convertToResponsiveCSS();

  // Aggregate Compose component files
  stats.composeAggregated = await aggregateComposeComponents();

  // Generate Compose Theme Providers
  stats.composeThemes = await generateComposeThemeProviders();

  // Consolidate Compose Primitives
  stats.composePrimitives = await consolidateComposePrimitives();

  // Aggregate Compose Semantics
  stats.composeSemantics = await aggregateComposeSemantics();

  // Cleanup individual Compose files
  stats.composeCleanup = await cleanupComposeIndividualFiles();

  // Generate SwiftUI Shared Infrastructure
  stats.swiftuiShared = await generateSwiftUISharedFiles();

  // Build consolidated SwiftUI Primitives
  stats.swiftuiPrimitives = await buildConsolidatedSwiftUIPrimitives();

  // Aggregate SwiftUI component files
  stats.swiftuiAggregated = await aggregateSwiftUIComponents();

  // Generate SwiftUI Theme Providers
  stats.swiftuiThemes = await generateSwiftUIThemeProviders();

  // Cleanup individual SwiftUI primitive files
  stats.swiftuiCleanup = await cleanupSwiftUIIndividualPrimitives();

  // Cleanup individual SwiftUI component files
  stats.swiftuiComponentCleanup = await cleanupSwiftUIIndividualComponentFiles();

  // Create manifest
  createManifest(stats);

  // Summary
  console.log('\nâœ¨ ============================================');
  console.log('   Build completed!');
  console.log('   ============================================\n');

  // Calculate total statistics for GitHub Actions
  const totalBuilds = stats.sharedPrimitives.total + stats.brandSpecific.totalBuilds +
                      stats.componentTokens.totalBuilds + stats.typographyTokens.totalBuilds +
                      stats.effectTokens.totalBuilds;
  const successfulBuilds = stats.sharedPrimitives.successful + stats.brandSpecific.successfulBuilds +
                           stats.componentTokens.successfulBuilds + stats.typographyTokens.successfulBuilds +
                           stats.effectTokens.successfulBuilds;

  console.log(`ðŸ“Š Statistiken:`);
  console.log(`   - Shared Primitives: ${stats.sharedPrimitives.successful}/${stats.sharedPrimitives.total}`);
  console.log(`   - Brand-spezifische Tokens: ${stats.brandSpecific.successfulBuilds}/${stats.brandSpecific.totalBuilds}`);
  console.log(`   - Component Tokens: ${stats.componentTokens.successfulBuilds}/${stats.componentTokens.totalBuilds}`);
  if (stats.colorCssOptimization) {
    console.log(`   - Color CSS Optimized: ${stats.colorCssOptimization.optimizedCount} components (${stats.colorCssOptimization.skippedCount} skipped)`);
  }
  console.log(`   - Typography Builds: ${stats.typographyTokens.successfulBuilds}/${stats.typographyTokens.totalBuilds}`);
  console.log(`   - Effect Builds: ${stats.effectTokens.successfulBuilds}/${stats.effectTokens.totalBuilds}`);
  console.log(`   - Responsive CSS Files: ${stats.responsiveCSS.successfulConversions}/${stats.responsiveCSS.totalConversions}`);
  if (COMPOSE_ENABLED && stats.composeAggregated) {
    console.log(`   - Compose Aggregated: ${stats.composeAggregated.successfulComponents}/${stats.composeAggregated.totalComponents}`);
  }
  if (COMPOSE_ENABLED && stats.composeThemes) {
    console.log(`   - Compose Themes: ${stats.composeThemes.successfulThemes}/${stats.composeThemes.totalThemes}`);
  }
  if (COMPOSE_ENABLED && stats.composePrimitives) {
    console.log(`   - Compose Primitives Consolidated: ${stats.composePrimitives.successful}/${stats.composePrimitives.total}`);
  }
  if (COMPOSE_ENABLED && stats.composeSemantics) {
    console.log(`   - Compose Semantics Aggregated: ${stats.composeSemantics.successfulBrands}/${stats.composeSemantics.totalBrands}`);
  }
  if (COMPOSE_ENABLED && stats.composeCleanup) {
    console.log(`   - Compose Files Cleaned: ${stats.composeCleanup.removed} individual files removed`);
  }
  if (SWIFTUI_ENABLED && stats.swiftuiShared) {
    console.log(`   - SwiftUI Shared Files: ${stats.swiftuiShared.successful}/${stats.swiftuiShared.total}`);
  }
  if (SWIFTUI_ENABLED && stats.swiftuiPrimitives) {
    console.log(`   - SwiftUI Primitives Consolidated: ${stats.swiftuiPrimitives.successful}/${stats.swiftuiPrimitives.total}`);
  }
  if (SWIFTUI_ENABLED && stats.swiftuiThemes) {
    console.log(`   - SwiftUI Themes: ${stats.swiftuiThemes.successfulThemes}/${stats.swiftuiThemes.totalThemes}`);
  }
  if (SWIFTUI_ENABLED && stats.swiftuiCleanup) {
    console.log(`   - SwiftUI Primitives Cleaned: ${stats.swiftuiCleanup.removed} individual files removed`);
  }
  if (SWIFTUI_ENABLED && stats.swiftuiAggregated) {
    console.log(`   - SwiftUI Components Aggregated: ${stats.swiftuiAggregated.successfulComponents}/${stats.swiftuiAggregated.totalComponents}`);
  }
  if (SWIFTUI_ENABLED && stats.swiftuiComponentCleanup) {
    console.log(`   - SwiftUI Components Cleaned: ${stats.swiftuiComponentCleanup.cleaned} individual files removed`);
  }
  console.log(`   - Builds erfolgreich: ${successfulBuilds}/${totalBuilds}`);
  console.log(`   - Output-Verzeichnis: dist/\n`);

  // Build optimized JS output (replaces flat structure with grouped files)
  await buildOptimizedJSOutput();

  // Copy platform-specific README files to dist directories
  console.log(`\nðŸ“„ Kopiere Platform-READMEs:\n`);
  try {
    // Docs are in packages/tokens/docs/
    const readmeSrcDir = path.join(__dirname, '../../packages/tokens/docs');

    // Copy docs/css.md to dist/css/README.md
    const cssReadmeSrc = path.join(readmeSrcDir, 'css.md');
    const cssReadmeDest = path.join(DIST_DIR, 'css/README.md');
    if (fs.existsSync(cssReadmeSrc)) {
      fs.copyFileSync(cssReadmeSrc, cssReadmeDest);
      console.log(`   âœ… docs/css.md â†’ dist/css/README.md`);
    } else {
      console.log(`   âš ï¸  docs/css.md nicht gefunden`);
    }

    // Copy docs/js.md to dist/js/README.md
    const jsReadmeSrc = path.join(readmeSrcDir, 'js.md');
    const jsReadmeDest = path.join(DIST_DIR, 'js/README.md');
    if (fs.existsSync(jsReadmeSrc)) {
      fs.copyFileSync(jsReadmeSrc, jsReadmeDest);
      console.log(`   âœ… docs/js.md â†’ dist/js/README.md`);
    } else {
      console.log(`   âš ï¸  docs/js.md nicht gefunden`);
    }

    // Copy docs/android.md to Android package as USAGE.md (README.md is maintained separately)
    if (COMPOSE_ENABLED) {
      const androidReadmeSrc = path.join(readmeSrcDir, 'android.md');
      const androidReadmeDest = path.join(ANDROID_DIST_DIR, 'USAGE.md');
      if (fs.existsSync(androidReadmeSrc)) {
        fs.mkdirSync(path.dirname(androidReadmeDest), { recursive: true });
        fs.copyFileSync(androidReadmeSrc, androidReadmeDest);
        console.log(`   âœ… docs/android.md â†’ tokens-android/.../USAGE.md`);
      } else {
        console.log(`   âš ï¸  docs/android.md nicht gefunden`);
      }
    }

    // Copy docs/ios.md to iOS package as USAGE.md (README.md is maintained separately)
    if (SWIFTUI_ENABLED) {
      const iosReadmeSrc = path.join(readmeSrcDir, 'ios.md');
      const iosReadmeDest = path.join(IOS_DIST_DIR, 'USAGE.md');
      if (fs.existsSync(iosReadmeSrc)) {
        fs.mkdirSync(path.dirname(iosReadmeDest), { recursive: true });
        fs.copyFileSync(iosReadmeSrc, iosReadmeDest);
        console.log(`   âœ… docs/ios.md â†’ tokens-ios/.../USAGE.md`);
      } else {
        console.log(`   âš ï¸  docs/ios.md nicht gefunden`);
      }
    }
  } catch (err) {
    console.log(`   âš ï¸  Fehler beim Kopieren der READMEs: ${err.message}`);
  }

  console.log(`\nðŸ“ Struktur:`);
  console.log(`   packages/tokens/dist/`);
  console.log(`   â”œâ”€â”€ css/        (CSS with data-attributes)`);
  console.log(`   â”œâ”€â”€ scss/       (SCSS variables)`);
  console.log(`   â”œâ”€â”€ js/         (ESM modules)`);
  console.log(`   â”œâ”€â”€ js.min/     (ESM minified)`);
  console.log(`   â””â”€â”€ json/       (JSON)`);
  if (SWIFTUI_ENABLED) {
    console.log(`   packages/tokens-ios/Sources/BildDesignTokens/`);
    console.log(`   â””â”€â”€ (SwiftUI - for SPM distribution)`);
  }
  if (COMPOSE_ENABLED) {
    console.log(`   packages/tokens-android/src/main/kotlin/.../`);
    console.log(`   â””â”€â”€ (Jetpack Compose - for Maven distribution)`);
  }
  console.log(``);
  console.log(`   JS structure (all variants):`);
  console.log(`   - primitives/          (bundled primitives)`);
  console.log(`   - themes/              (createTheme, pre-built themes)`);
  console.log(`   - react/               (ThemeProvider, useTheme, useBreakpoint)`);
  console.log(`   - brands/{brand}/`);
  console.log(`       â”œâ”€â”€ colors.js      (light/dark + flat exports)`);
  console.log(`       â”œâ”€â”€ spacing.js     (breakpoints + flat exports)`);
  console.log(`       â”œâ”€â”€ typography.js  (breakpoints + flat exports)`);
  console.log(`       â”œâ”€â”€ effects.js     (light/dark + flat exports)`);
  console.log(`       â”œâ”€â”€ density.js     (density modes + flat exports)`);
  console.log(`       â””â”€â”€ components/    (one file per component)`);
  console.log('');

  // Explizit success exit code
  process.exit(0);
}

// FÃ¼hre Script aus
if (require.main === module) {
  main().catch(error => {
    console.error('âŒ Fehler beim Build:', error);
    process.exit(1);
  });
}

module.exports = { main };

/**
 * Style Dictionary Konfiguration für BILD Design System (v4)
 *
 * Diese Datei exportiert Custom Transforms und Formats
 * für Style Dictionary v4
 */

const path = require('path');
const packageJson = require('../../package.json');

// ============================================================================
// FILE HEADER GENERATORS
// ============================================================================

/**
 * Generates standardized file header for all output formats
 * @param {Object} options - Header configuration
 * @param {String} options.fileName - Name of the generated file
 * @param {String} options.commentStyle - Comment style: 'block' | 'line' | 'xml'
 * @param {String} [options.brand] - Brand name (e.g., 'BILD', 'SportBILD')
 * @param {String} [options.context] - Additional context (e.g., 'Light', 'Dark', 'Compact')
 * @returns {String} - Formatted header string
 */
function generateFileHeader({ fileName, commentStyle, brand, context }) {
  const version = packageJson.version;
  const repoUrl = packageJson.homepage;

  const lines = [
    'Do not edit directly, this file was auto-generated.',
    '',
    `BILD Design System Tokens v${version}`,
    'Generated by Style Dictionary v4.0.0',
    ''
  ];

  // Add Brand + Context if available
  if (brand && context) {
    lines.push(`Brand: ${brand} | Context: ${context}`);
    lines.push('');
  } else if (brand) {
    lines.push(`Brand: ${brand}`);
    lines.push('');
  } else if (context) {
    lines.push(`Context: ${context}`);
    lines.push('');
  }

  lines.push(
    'Copyright (c) 2024 Axel Springer Deutschland GmbH',
    'Proprietary and confidential. All rights reserved.',
    '',
    `Documentation: ${repoUrl}`
  );

  // Format based on comment style
  switch (commentStyle) {
    case 'block': // CSS, JS, Swift
      return '/**\n * ' + lines.join('\n * ') + '\n */\n\n';

    case 'line': // SCSS, Dart, Swift alternative
      return '//\n// ' + lines.join('\n// ') + '\n//\n\n';

    case 'xml': // Android XML
      return '<!--\n  ' + lines.join('\n  ') + '\n-->\n';

    default:
      return '/**\n * ' + lines.join('\n * ') + '\n */\n\n';
  }
}

/**
 * Helper to extract context information from options
 */
function getContextString(options) {
  const contexts = [];
  if (options.mode) contexts.push(options.mode);
  if (options.colorMode) contexts.push(options.colorMode);
  if (options.density) contexts.push(options.density);
  if (options.breakpoint) contexts.push(options.breakpoint);
  if (options.sizeClass) contexts.push(options.sizeClass);
  if (options.layer) contexts.push(options.layer);

  return contexts.length > 0 ? contexts.join(', ') : null;
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Groups tokens hierarchically by path segments
 * Returns a structure: { topLevel: { subLevel: [tokens] } }
 */
function groupTokensHierarchically(tokens) {
  const grouped = {};

  tokens.forEach(token => {
    const pathSegments = token.path.slice(0, -1); // All segments except last (token name)

    if (pathSegments.length === 0) {
      if (!grouped['Other']) grouped['Other'] = {};
      if (!grouped['Other']['']) grouped['Other'][''] = [];
      grouped['Other'][''].push(token);
      return;
    }

    const topLevel = pathSegments[0]; // First segment (e.g., "Semantic", "Component")
    const subLevel = pathSegments.slice(1).join(' - '); // Remaining segments (e.g., "Text", "Button - Primary")

    if (!grouped[topLevel]) {
      grouped[topLevel] = {};
    }

    if (!grouped[topLevel][subLevel]) {
      grouped[topLevel][subLevel] = [];
    }

    grouped[topLevel][subLevel].push(token);
  });

  return grouped;
}

/**
 * Name transformation functions for different platforms
 */
const nameTransformers = {
  // Kebab-case für CSS, SCSS
  kebab: (str) => {
    return str
      .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  },

  // snake_case für Android (hyphens sind in Android XML nicht erlaubt)
  snake: (str) => {
    return str
      .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
      .toLowerCase()
      .replace(/[^a-z0-9_]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '');
  },

  // camelCase für JavaScript, Flutter, iOS Swift
  camel: (str) => {
    const kebab = nameTransformers.kebab(str);
    let camelCase = kebab.replace(/-([a-z0-9])/g, (_, letter) => letter.toUpperCase());

    // Prefix with underscore if starts with a number (invalid JS identifier)
    if (/^[0-9]/.test(camelCase)) {
      camelCase = '_' + camelCase;
    }

    return camelCase;
  },

  // PascalCase (kept for potential future use)
  pascal: (str) => {
    const camel = nameTransformers.camel(str);
    if (camel.length === 0) return camel;

    // If starts with underscore followed by number, keep underscore
    if (camel.startsWith('_')) {
      return '_' + camel.charAt(1).toUpperCase() + camel.slice(2);
    }

    return camel.charAt(0).toUpperCase() + camel.slice(1);
  }
};

/**
 * Generates unique token names by using the minimum number of path segments needed
 * to avoid collisions. Starts with the last segment, adds previous segments as needed.
 *
 * @param {Array} tokens - Array of tokens to process
 * @param {String} transformType - Type of transformation: 'kebab', 'camel', or 'pascal'
 * @returns {Map} - Map of token path string to unique name
 */
function generateUniqueNames(tokens, transformType = 'kebab') {
  const transformFn = nameTransformers[transformType];
  const nameMap = new Map();
  const collisionGroups = new Map();

  // First pass: Group tokens by their base name (last segment only)
  tokens.forEach(token => {
    const lastSegment = token.path[token.path.length - 1];
    const baseName = transformFn(lastSegment);
    const pathKey = token.path.join('.');

    if (!collisionGroups.has(baseName)) {
      collisionGroups.set(baseName, []);
    }
    collisionGroups.get(baseName).push({ token, pathKey });
  });

  // Second pass: Generate unique names, resolving collisions
  collisionGroups.forEach((tokenGroup, baseName) => {
    if (tokenGroup.length === 1) {
      // No collision - use simple name
      nameMap.set(tokenGroup[0].pathKey, baseName);
    } else {
      // Collision detected - resolve by adding more path segments
      tokenGroup.forEach(({ token, pathKey }) => {
        let uniqueName = baseName;
        let segmentCount = 1;

        // Incrementally add more segments until name is unique within this collision group
        while (segmentCount < token.path.length) {
          segmentCount++;
          const segments = token.path.slice(-segmentCount);
          const candidateName = transformFn(segments.join('-'));

          // Check if candidate is unique within this collision group
          const hasCollision = tokenGroup.some(other => {
            if (other.pathKey === pathKey) return false; // Don't compare with self
            const otherSegments = other.token.path.slice(-segmentCount);
            return transformFn(otherSegments.join('-')) === candidateName;
          });

          if (!hasCollision) {
            uniqueName = candidateName;
            break;
          }
        }

        // Fallback: use full path if still not unique (edge case)
        if (segmentCount >= token.path.length && tokenGroup.length > 1) {
          uniqueName = transformFn(token.path.join('-'));
        }

        nameMap.set(pathKey, uniqueName);
      });
    }
  });

  return nameMap;
}

// ============================================================================
// CUSTOM TRANSFORMS
// ============================================================================

/**
 * Transform: Color zu CSS hex/rgba
 */
const colorCssTransform = {
  name: 'color/css',
  type: 'value',
  filter: (token) => token.$type === 'color' || token.type === 'color',
  transform: (token) => {
    // If already a valid color value, return directly
    if (typeof token.$value === 'string' || typeof token.value === 'string') {
      return token.$value || token.value;
    }
    return token.$value || token.value;
  }
};

/**
 * Transform: Color zu iOS UIColor
 */
const colorUIColorTransform = {
  name: 'custom/color/UIColor',
  type: 'value',
  transitive: true,
  filter: (token) => token.$type === 'color' || token.type === 'color',
  transform: (token) => {
    const value = token.$value || token.value;

    // Hex zu UIColor
    if (value.startsWith('#')) {
      const hex = value.replace('#', '');
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      const a = hex.length === 8 ? parseInt(hex.substring(6, 8), 16) / 255 : 1;

      return `UIColor(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: ${a.toFixed(3)})`;
    }

    // RGBA zu UIColor
    if (value.startsWith('rgb')) {
      const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (match) {
        const r = parseInt(match[1]) / 255;
        const g = parseInt(match[2]) / 255;
        const b = parseInt(match[3]) / 255;
        const a = match[4] ? parseFloat(match[4]) : 1;

        return `UIColor(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: ${a.toFixed(3)})`;
      }
    }

    return value;
  }
};

/**
 * Helper function to round numeric values (defined here for use in transforms)
 */
function roundValue(value) {
  if (typeof value === 'number') {
    // If it's a whole number, return as-is
    if (Number.isInteger(value)) {
      return value;
    }
    // Round to 2 decimal places
    return Math.round(value * 100) / 100;
  }
  return value;
}

/**
 * Transform: Dimension zu px (with rounding)
 */
const sizePxTransform = {
  name: 'custom/size/px',  // Renamed to avoid conflicts with built-in transforms
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;

    // Only match if type is dimension-related AND value is numeric
    const isMatchingType = ['spacing', 'size', 'fontSize', 'dimension'].includes(type);
    const isNumeric = typeof value === 'number';

    return isMatchingType && isNumeric;
  },
  transform: (token) => {
    const value = token.$value || token.value;

    // Safety check: only transform if value is actually a number
    if (typeof value === 'number') {
      // Round the value before adding 'px' to remove floating-point precision errors
      const rounded = roundValue(value);
      return `${rounded}px`;
    }

    // If not a number, return unchanged (shouldn't happen due to filter, but safety first)
    return value;
  }
};

/**
 * Transform: Spacing/Sizing zu rem (with rounding)
 */
const sizeRemTransform = {
  name: 'size/rem',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    return ['spacing', 'size', 'fontSize', 'dimension'].includes(type);
  },
  transform: (token) => {
    const value = token.$value || token.value;
    if (typeof value === 'number') {
      // Konvertiere px zu rem (angenommen 16px = 1rem) and round
      const remValue = value / 16;
      const rounded = roundValue(remValue);
      return `${rounded}rem`;
    }
    return value;
  }
};

/**
 * Transform: Dimension zu iOS Points (CGFloat - reine Zahlen ohne Einheit)
 * iOS nutzt Points statt Pixels. 1pt ≈ 1px auf @1x screens
 */
const sizeIosPointsTransform = {
  name: 'custom/size/ios-points',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;

    // Only match if type is dimension-related AND value is numeric
    const isMatchingType = ['spacing', 'size', 'fontSize', 'dimension'].includes(type);
    const isNumeric = typeof value === 'number';

    return isMatchingType && isNumeric;
  },
  transform: (token) => {
    const value = token.$value || token.value;

    // Return rounded number (CGFloat) without any unit
    if (typeof value === 'number') {
      return roundValue(value);
    }

    return value;
  }
};

/**
 * Transform: Name zu CSS Custom Property (Kebab-Case)
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameKebabTransform = {
  name: 'name/custom/kebab',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    return nameTransformers.kebab(lastSegment);
  }
};

/**
 * Transform: Name zu gültigem JavaScript Identifier (Camel-Case)
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameJsTransform = {
  name: 'name/custom/js',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    return nameTransformers.camel(lastSegment);
  }
};

/**
 * Transform: Name für iOS Swift (PascalCase, behält Unterstriche in Dezimalzahlen)
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameIosSwiftTransform = {
  name: 'name/custom/ios-swift',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    // Changed from PascalCase to camelCase - more consistent with Swift property naming
    return nameTransformers.camel(lastSegment);
  }
};

/**
 * Transform: Name für Android XML (snake_case)
 * Hyphens sind in Android Resource Namen nicht erlaubt!
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameAndroidTransform = {
  name: 'name/custom/android',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    return nameTransformers.snake(lastSegment);
  }
};

/**
 * Transform: Name für Flutter Dart (camelCase, behält Unterstriche in Dezimalzahlen)
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameFlutterDartTransform = {
  name: 'name/custom/flutter-dart',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    return nameTransformers.camel(lastSegment);
  }
};

/**
 * Transform: Name für Jetpack Compose (camelCase für Properties)
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameComposeTransform = {
  name: 'name/custom/compose',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    return nameTransformers.camel(lastSegment);
  }
};

/**
 * Transform: Color für Jetpack Compose - Color(0xFFRRGGBB) Format
 */
const colorComposeTransform = {
  name: 'color/custom/compose',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    return type === 'color';
  },
  transform: (token) => {
    const value = token.$value || token.value;

    // Handle hex colors: #RRGGBB or #AARRGGBB
    if (typeof value === 'string' && value.startsWith('#')) {
      let hex = value.replace('#', '').toUpperCase();
      // If 6 chars, add FF alpha prefix
      if (hex.length === 6) {
        hex = 'FF' + hex;
      }
      // If 8 chars (AARRGGBB), use as-is
      return `Color(0x${hex})`;
    }

    // Handle rgba: rgba(r, g, b, a)
    if (typeof value === 'string' && value.startsWith('rgba')) {
      const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*([\d.]*)\)/);
      if (match) {
        const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
        const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
        const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
        const a = match[4] ? Math.round(parseFloat(match[4]) * 255).toString(16).padStart(2, '0').toUpperCase() : 'FF';
        return `Color(0x${a}${r}${g}${b})`;
      }
    }

    // Handle rgb: rgb(r, g, b)
    if (typeof value === 'string' && value.startsWith('rgb(')) {
      const match = value.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (match) {
        const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
        const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
        const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
        return `Color(0xFF${r}${g}${b})`;
      }
    }

    // Fallback
    return value;
  }
};

/**
 * Transform: Size/Dimension für Jetpack Compose - X.dp Format
 */
const sizeComposeTransform = {
  name: 'size/custom/compose',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    return type === 'dimension' || type === 'float' || type === 'sizing' || type === 'spacing';
  },
  transform: (token) => {
    let value = token.$value || token.value;

    // Remove 'px' if present and convert to number
    if (typeof value === 'string') {
      value = parseFloat(value.replace('px', ''));
    }

    // Return as Dp value
    if (Number.isInteger(value)) {
      return `${value}.dp`;
    }
    return `${value}.dp`;
  }
};

/**
 * Transform: Opacity - Convert Figma % (5, 10, 70) to CSS decimal (0.05, 0.1, 0.7)
 */
const opacityTransform = {
  name: 'custom/opacity',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;
    return type === 'opacity' && typeof value === 'number';
  },
  transform: (token) => {
    const value = token.$value || token.value;
    // Figma exports % (5, 10, 70), CSS needs 0-1 (0.05, 0.1, 0.7)
    const cssValue = value / 100;
    return roundValue(cssValue); // Round to avoid precision errors
  }
};

/**
 * Transform: Font Weight - Unitless integer
 */
const fontWeightTransform = {
  name: 'custom/fontWeight',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;
    return type === 'fontWeight' && typeof value === 'number';
  },
  transform: (token) => {
    return Math.round(token.$value || token.value); // 700, no "px"
  }
};

/**
 * Transform: Number - Unitless rounded number (for columns, z-index, etc.)
 */
const numberTransform = {
  name: 'custom/number',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;
    return type === 'number' && typeof value === 'number';
  },
  transform: (token) => {
    return Math.round(token.$value || token.value); // Unitless integer
  }
};

/**
 * Transform: Round numeric values to remove floating-point precision errors
 * This transform runs AFTER all other value transforms (color, size, etc.)
 * and rounds numeric values in strings to 2 decimal places
 */
const valueRoundTransform = {
  name: 'value/round',
  type: 'value',
  transitive: true,
  filter: () => true,
  transform: (token) => {
    let value = token.$value || token.value;

    // Only process string values that might contain numbers
    if (typeof value !== 'string') {
      return value;
    }

    // Round rgba() alpha values (0.699999988079071 -> 0.7)
    value = value.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/g, (match, r, g, b, a) => {
      const roundedAlpha = Math.round(parseFloat(a) * 100) / 100;
      return `rgba(${r}, ${g}, ${b}, ${roundedAlpha})`;
    });

    // Round UIColor values (for iOS)
    value = value.replace(/(red|green|blue|alpha):\s*([\d.]+)/g, (match, component, num) => {
      const rounded = Math.round(parseFloat(num) * 1000) / 1000; // 3 decimals for UIColor
      return `${component}: ${rounded}`;
    });

    // Round pixel values (0.33000001311302185px -> 0.33px, 16.0px -> 16px)
    value = value.replace(/([\d.]+)px/g, (match, num) => {
      const n = parseFloat(num);
      if (Number.isInteger(n)) {
        return `${n}px`;
      }
      const rounded = Math.round(n * 100) / 100;
      return `${rounded}px`;
    });

    // Round rem values
    value = value.replace(/([\d.]+)rem/g, (match, num) => {
      const n = parseFloat(num);
      if (Number.isInteger(n)) {
        return `${n}rem`;
      }
      const rounded = Math.round(n * 100) / 100;
      return `${rounded}rem`;
    });

    // Round em values
    value = value.replace(/([\d.]+)em/g, (match, num) => {
      const n = parseFloat(num);
      if (Number.isInteger(n)) {
        return `${n}em`;
      }
      const rounded = Math.round(n * 100) / 100;
      return `${rounded}em`;
    });

    // Round percentage values
    value = value.replace(/([\d.]+)%/g, (match, num) => {
      const n = parseFloat(num);
      if (Number.isInteger(n)) {
        return `${n}%`;
      }
      const rounded = Math.round(n * 100) / 100;
      return `${rounded}%`;
    });

    // Round standalone decimal numbers (for opacity, line-height, etc.)
    // Only if they have more than 2 decimal places
    if (/^[\d.]+$/.test(value) && value.includes('.')) {
      const num = parseFloat(value);
      if (!Number.isInteger(num) && value.split('.')[1].length > 2) {
        const rounded = Math.round(num * 100) / 100;
        return rounded.toString();
      }
    }

    return value;
  }
};

// ============================================================================
// CUSTOM FORMATS
// ============================================================================

/**
 * Format: CSS Custom Properties mit Kategorisierung und Gruppierung
 */
const cssVariablesFormat = ({ dictionary, options, file }) => {
  const selector = options.selector || ':root';
  const context = getContextString(options);

  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: options.brand,
    context: context
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  output += `${selector} {\n`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `  /* ============================================\n`;
    output += `     ${topLevel.toUpperCase()}\n`;
    output += `     ============================================ */\n\n`;
    isFirstTopLevel = false;

    // Sort sub-level keys
    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `  /* ${topLevel} - ${subLevel} */\n`;
      }

      // Add tokens
      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `  /**\n   * ${comment}\n   */\n`;
        }
        // Use $value (transformed) or fallback to value (original)
        const finalValue = token.$value !== undefined ? token.$value : token.value;
        output += `  --${uniqueName}: ${finalValue};\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

/**
 * Format: SCSS Variables mit Gruppierung
 */
const scssVariablesFormat = ({ dictionary, options, file }) => {
  const context = getContextString(options);
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'line',
    brand: options.brand,
    context: context
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `// ${comment}\n`;
        }
        output += `$${uniqueName}: ${token.$value !== undefined ? token.$value : token.value};\n`;
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * Format: JavaScript/TypeScript ES6 Module mit Gruppierung
 */
const javascriptEs6Format = ({ dictionary, options, file }) => {
  const context = getContextString(options);
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: options.brand,
    context: context
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `/** ${comment} */\n`;
        }
        output += `export const ${uniqueName} = "${token.$value !== undefined ? token.$value : token.value}";\n`;
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * Format: JSON strukturiert
 */
const jsonNestedFormat = ({ dictionary }) => {
  return JSON.stringify(dictionary.tokens, null, 2);
};

/**
 * Format: iOS Swift Class mit korrekter className Handhabung und Gruppierung
 */
const iosSwiftClassFormat = ({ dictionary, options, file }) => {
  const className = options.className || file.className || 'StyleDictionary';
  const context = getContextString(options);
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'line',
    brand: options.brand,
    context: context
  });

  output += `import UIKit\n\npublic class ${className} {\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `    // MARK: - ============================================\n`;
    output += `    // MARK: - ${topLevel.toUpperCase()}\n`;
    output += `    // MARK: - ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `    // MARK: - ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `    /** ${comment} */\n`;
        }

        let valueOutput;
        const value = token.$value !== undefined ? token.$value : token.value;
        const type = token.$type || token.type;

        if (type === 'color') {
          // Value from custom/color/UIColor transform is already formatted as UIColor constructor
          if (value.startsWith('UIColor(')) {
            valueOutput = value;  // Use directly without quotes
          } else if (value.startsWith('#')) {
            const hex = value.replace('#', '');
            const r = (parseInt(hex.substring(0, 2), 16) / 255).toFixed(3);
            const g = (parseInt(hex.substring(2, 4), 16) / 255).toFixed(3);
            const b = (parseInt(hex.substring(4, 6), 16) / 255).toFixed(3);
            const a = hex.length === 8 ? (parseInt(hex.substring(6, 8), 16) / 255).toFixed(3) : '1.000';
            valueOutput = `UIColor(red: ${r}, green: ${g}, blue: ${b}, alpha: ${a})`;
          } else if (value.startsWith('rgb')) {
            const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (match) {
              const r = (parseInt(match[1]) / 255).toFixed(3);
              const g = (parseInt(match[2]) / 255).toFixed(3);
              const b = (parseInt(match[3]) / 255).toFixed(3);
              const a = match[4] ? parseFloat(match[4]).toFixed(3) : '1.000';
              valueOutput = `UIColor(red: ${r}, green: ${g}, blue: ${b}, alpha: ${a})`;
            } else {
              valueOutput = `"${value}"`;
            }
          } else {
            valueOutput = `"${value}"`;
          }
        } else if (typeof value === 'number') {
          valueOutput = value;
        } else if (typeof value === 'string') {
          valueOutput = `"${value}"`;
        } else {
          valueOutput = value;
        }

        output += `    public static let ${uniqueName} = ${valueOutput}\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Flutter Dart Class mit korrekter className Handhabung und Gruppierung
 */
const flutterDartClassFormat = ({ dictionary, options, file }) => {
  const className = options.className || file.className || 'StyleDictionary';
  const context = getContextString(options);
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'line',
    brand: options.brand,
    context: context
  });

  output += `import 'dart:ui';\n\nclass ${className} {\n    ${className}._();\n\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `    // ============================================\n`;
    output += `    // ${topLevel.toUpperCase()}\n`;
    output += `    // ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `    // ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `    /** ${comment} */\n`;
        }

        let valueOutput;
        const value = token.$value !== undefined ? token.$value : token.value;
        const type = token.$type || token.type;

        if (type === 'color') {
          if (value.startsWith('#')) {
            const hex = value.replace('#', '');
            let argb;
            if (hex.length === 6) {
              argb = 'FF' + hex;
            } else if (hex.length === 8) {
              argb = hex.substring(6, 8) + hex.substring(0, 6);
            } else {
              argb = 'FF000000';
            }
            valueOutput = `Color(0x${argb})`;
          } else if (value.startsWith('rgb')) {
            const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (match) {
              const r = parseInt(match[1]).toString(16).padStart(2, '0');
              const g = parseInt(match[2]).toString(16).padStart(2, '0');
              const b = parseInt(match[3]).toString(16).padStart(2, '0');
              const a = match[4] ? Math.round(parseFloat(match[4]) * 255).toString(16).padStart(2, '0') : 'FF';
              valueOutput = `Color(0x${a}${r}${g}${b})`;
            } else {
              valueOutput = `"${value}"`;
            }
          } else {
            valueOutput = `"${value}"`;
          }
        } else if (typeof value === 'number') {
          valueOutput = value;
        } else if (typeof value === 'string') {
          valueOutput = `"${value}"`;
        } else {
          valueOutput = value;
        }

        output += `    static const ${uniqueName} = ${valueOutput};\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

// ============================================================================
// COMPOSITE TOKEN FORMATS
// ============================================================================

/**
 * Format: CSS Typography Classes
 * Generiert fertige CSS-Klassen für Typography Composite Tokens
 */
const cssTypographyClassesFormat = ({ dictionary, options }) => {
  const { brand, breakpoint } = options;

  let output = generateFileHeader({
    fileName: `typography-${breakpoint}.css`,
    commentStyle: 'block',
    brand: brand,
    context: `Breakpoint: ${breakpoint}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  // Build data-attribute selector for Strategy A (full brand + breakpoint scoping)
  const brandLowercase = brand.toLowerCase();
  const dataSelector = `[data-brand="${brandLowercase}"][data-breakpoint="${breakpoint}"]`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `/* ============================================\n`;
    output += `   ${topLevel.toUpperCase()}\n`;
    output += `   ============================================ */\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `/* ${topLevel} - ${subLevel} */\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const style = token.$value;
          const aliases = token.$aliases || {};

          // Helper to get value with var() reference if alias exists
          const getValueWithAlias = (property, value, unit = '') => {
            const alias = aliases[property];
            if (alias?.token) {
              const varName = nameTransformers.kebab(alias.token);
              const formattedValue = unit && typeof value === 'number' ? `${value}${unit}` : value;
              return `var(--${varName}, ${formattedValue})`;
            }
            return unit && typeof value === 'number' ? `${value}${unit}` : value;
          };

          // Use only the last path segment as class name, convert to kebab-case for CSS
          let className = nameTransformers.kebab(token.path[token.path.length - 1]);
          // Remove leading dot if present (token names may already include it)
          if (className.startsWith('.')) {
            className = className.substring(1);
          }

          if (token.comment) {
            output += `/* ${token.comment} */\n`;
          }

          // Wrap class selector with data-attribute selector (Strategy A)
          output += `${dataSelector} .${className} {\n`;
          if (style.fontFamily) output += `  font-family: ${getValueWithAlias('fontFamily', style.fontFamily)};\n`;
          if (style.fontWeight) output += `  font-weight: ${getValueWithAlias('fontWeight', style.fontWeight)};\n`;
          if (style.fontSize) output += `  font-size: ${getValueWithAlias('fontSize', style.fontSize, 'px')};\n`;
          if (style.lineHeight) output += `  line-height: ${getValueWithAlias('lineHeight', style.lineHeight, 'px')};\n`;
          if (style.letterSpacing) output += `  letter-spacing: ${getValueWithAlias('letterSpacing', style.letterSpacing, 'px')};\n`;
          if (style.fontStyle && style.fontStyle !== 'null') output += `  font-style: ${style.fontStyle.toLowerCase()};\n`;
          if (style.textCase && style.textCase !== 'ORIGINAL') {
            output += `  text-transform: ${mapTextCase(style.textCase)};\n`;
          }
          if (style.textDecoration && style.textDecoration !== 'NONE') {
            output += `  text-decoration: ${style.textDecoration.toLowerCase()};\n`;
          }
          output += `}\n\n`;
        }
      });
    });
  });

  return output;
};

/**
 * Format: CSS Effect Classes
 * Generiert fertige CSS-Klassen für Effect Composite Tokens
 */
const cssEffectClassesFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;

  let output = generateFileHeader({
    fileName: `effects-${colorMode}.css`,
    commentStyle: 'block',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  // Build data-attribute selector for Strategy A (full brand + theme scoping)
  const brandLowercase = brand.toLowerCase();
  const dataSelector = `[data-brand="${brandLowercase}"][data-theme="${colorMode}"]`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `/* ============================================\n`;
    output += `   ${topLevel.toUpperCase()}\n`;
    output += `   ============================================ */\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `/* ${topLevel} - ${subLevel} */\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const aliases = token.$aliases || [];

          // Use only the last path segment as class name, convert to kebab-case for CSS
          let className = nameTransformers.kebab(token.path[token.path.length - 1]);
          // Remove leading dot if present (token names may already include it)
          if (className.startsWith('.')) {
            className = className.substring(1);
          }

          if (token.comment) {
            output += `/* ${token.comment} */\n`;
          }

          // Wrap class selector with data-attribute selector (Strategy A)
          output += `${dataSelector} .${className} {\n`;

          // Convert to CSS box-shadow with var() references for colors
          const shadows = token.$value.map((effect, index) => {
            if (effect.type === 'dropShadow') {
              // Check if there's an alias for this effect's color
              const aliasEntry = aliases.find(a => a.index === index);
              let colorValue = effect.color;

              if (aliasEntry?.color?.token) {
                const varName = nameTransformers.kebab(aliasEntry.color.token);
                colorValue = `var(--${varName}, ${effect.color})`;
              }

              return `${effect.offsetX}px ${effect.offsetY}px ${effect.radius}px ${effect.spread}px ${colorValue}`;
            }
            return null;
          }).filter(Boolean);

          if (shadows.length > 0) {
            output += `  box-shadow: ${shadows.join(', ')};\n`;
          }

          output += `}\n\n`;
        }
      });
    });
  });

  return output;
};

/**
 * Format: iOS Swift Typography Extension
 */
const iosSwiftTypographyFormat = ({ dictionary, options }) => {
  const { brand, breakpoint, sizeClass } = options;
  const className = `Typography${brand}${sizeClass || breakpoint}`;

  let output = generateFileHeader({
    fileName: `typography-${sizeClass || breakpoint}.swift`,
    commentStyle: 'line',
    brand: brand,
    context: `SizeClass: ${sizeClass || breakpoint}`
  });

  output += `import UIKit\n\n`;
  output += `extension UIFont {\n`;
  output += `    struct ${className} {\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `        // MARK: - ============================================\n`;
    output += `        // MARK: - ${topLevel.toUpperCase()}\n`;
    output += `        // MARK: - ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `        // MARK: - ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const style = token.$value;
          // Use only the last path segment as property name, transformed to camelCase
          const rawName = token.path[token.path.length - 1];
          const propName = nameTransformers.camel(rawName);

          if (token.comment) {
            output += `        /** ${token.comment} */\n`;
          }

          const family = style.fontFamily || 'System';
          const size = parseFloat(style.fontSize) || 16;
          const weight = style.fontWeight || 400;

          // Map weight to UIFont.Weight
          let weightString = 'regular';
          if (weight >= 900) weightString = 'black';
          else if (weight >= 800) weightString = 'heavy';
          else if (weight >= 700) weightString = 'bold';
          else if (weight >= 600) weightString = 'semibold';
          else if (weight >= 500) weightString = 'medium';
          else if (weight >= 300) weightString = 'light';
          else if (weight >= 200) weightString = 'ultraLight';
          else if (weight >= 100) weightString = 'thin';

          output += `        static let ${propName} = UIFont(name: "${family}", size: ${size})?.withWeight(.${weightString}) ?? UIFont.systemFont(ofSize: ${size}, weight: .${weightString})\n`;
        }
      });
    });
  });

  output += `    }\n`;
  output += `}\n`;

  return output;
};

/**
 * Format: Android XML Resources with hierarchical grouping
 */
const androidResourcesFormat = ({ dictionary, options, file }) => {
  const context = getContextString(options);
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'snake');

  let output = `<?xml version="1.0" encoding="UTF-8"?>\n\n`;
  output += generateFileHeader({
    fileName: file.destination,
    commentStyle: 'xml',
    brand: options.brand,
    context: context
  });
  output += `<resources>\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `  <!-- ============================================\n`;
    output += `       ${topLevel.toUpperCase()}\n`;
    output += `       ============================================ -->\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `  <!-- ${topLevel} - ${subLevel} -->\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const value = token.$value !== undefined ? token.$value : token.value;
        const type = token.$type || token.type;
        const comment = token.comment || token.description;

        let resourceType = 'string';
        if (type === 'color') {
          resourceType = 'color';
        } else if (type === 'dimension' || type === 'number') {
          resourceType = 'dimen';
        }

        output += `  <${resourceType} name="${uniqueName}">${value}</${resourceType}>`;
        if (comment) {
          output += `<!-- ${comment} -->`;
        }
        output += `\n`;
      });

      output += `\n`;
    });
  });

  output += `</resources>\n`;
  return output;
};

/**
 * Helper: Convert token name to Android TextAppearance style name
 * Transforms: "ateaser-ateaserkicker" → "ATeaser.Kicker"
 *             "buttonlabel" → "ButtonLabel"
 */
const toAndroidTypographyStyleName = (tokenName, brand) => {
  // Remove common prefixes and clean up the name
  let cleanName = tokenName;

  // Split by hyphens and process each part
  const parts = cleanName.split('-').map(part => {
    // Convert camelCase or lowercase to PascalCase
    return part
      .replace(/([a-z])([A-Z])/g, '$1.$2')  // Split camelCase with dots
      .split('.')
      .map(segment => segment.charAt(0).toUpperCase() + segment.slice(1).toLowerCase())
      .join('');
  });

  // Join with dots for Android style hierarchy
  const stylePart = parts.join('.');

  // Format brand name (capitalize first letter)
  const brandName = brand.charAt(0).toUpperCase() + brand.slice(1);

  return `TextAppearance.${brandName}.${stylePart}`;
};

/**
 * Format: Android XML Typography Styles
 * Uses Material Design naming convention: TextAppearance.Brand.Component.Style
 */
const androidXmlTypographyFormat = ({ dictionary, options }) => {
  const { brand, breakpoint } = options;

  let output = `<?xml version="1.0" encoding="utf-8"?>\n`;
  output += generateFileHeader({
    fileName: `typography_styles.xml`,
    commentStyle: 'xml',
    brand: brand,
    context: `Breakpoint: ${breakpoint}`
  });
  output += `<resources>\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `    <!-- ============================================\n`;
    output += `         ${topLevel.toUpperCase()}\n`;
    output += `         ============================================ -->\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `    <!-- ${topLevel} - ${subLevel} -->\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const style = token.$value;
          // Convert to Android TextAppearance naming convention
          const rawName = token.path[token.path.length - 1];
          const styleName = toAndroidTypographyStyleName(rawName, brand);

          output += `    <style name="${styleName}">\n`;
          if (style.fontFamily) output += `        <item name="android:fontFamily">${style.fontFamily}</item>\n`;
          if (style.fontSize) {
            const size = parseFloat(style.fontSize);
            output += `        <item name="android:textSize">${size}sp</item>\n`;
          }
          if (style.fontWeight && style.fontWeight >= 700) {
            output += `        <item name="android:textStyle">bold</item>\n`;
          }
          if (style.lineHeight) {
            const lineHeight = parseFloat(style.lineHeight);
            output += `        <item name="android:lineHeight">${lineHeight}sp</item>\n`;
          }
          if (style.letterSpacing) {
            const letterSpacing = parseFloat(style.letterSpacing);
            output += `        <item name="android:letterSpacing">${letterSpacing / 16}</item>\n`;
          }
          // Android only supports textAllCaps (uppercase), not lowercase or capitalize
          if (style.textCase === 'UPPER') {
            output += `        <item name="android:textAllCaps">true</item>\n`;
          }
          output += `    </style>\n`;
        }
      });
    });
  });

  output += `</resources>\n`;

  return output;
};

/**
 * Format: iOS Swift Effects
 * Exports shadow tokens as properly formatted Swift code
 */
const iosSwiftEffectsFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;
  const className = `Effects${brand}${colorMode.charAt(0).toUpperCase() + colorMode.slice(1)}`;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: `effects-${colorMode}.swift`,
    commentStyle: 'line',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  output += `import UIKit\n\n`;
  output += `public class ${className} {\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    output += `    // MARK: - ============================================\n`;
    output += `    // MARK: - ${topLevel.toUpperCase()}\n`;
    output += `    // MARK: - ============================================\n\n`;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `    // MARK: - ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const uniqueName = uniqueNames.get(token.path.join('.'));

          if (token.comment) {
            output += `    /** ${token.comment} */\n`;
          }

          // Convert shadow array to NSShadow array
          const shadowsSwift = token.$value.map(effect => {
            if (effect.type === 'dropShadow') {
              // Parse color
              let colorValue = 'UIColor.black';
              if (effect.color) {
                const colorStr = effect.color.replace(/\s/g, '');
                if (colorStr.startsWith('rgba')) {
                  const match = colorStr.match(/rgba?\((\d+),(\d+),(\d+),?([\d.]*)\)/);
                  if (match) {
                    const r = (parseInt(match[1]) / 255).toFixed(3);
                    const g = (parseInt(match[2]) / 255).toFixed(3);
                    const b = (parseInt(match[3]) / 255).toFixed(3);
                    const a = match[4] || '1';
                    colorValue = `UIColor(red: ${r}, green: ${g}, blue: ${b}, alpha: ${a})`;
                  }
                }
              }

              return `NSShadow(offset: CGSize(width: ${effect.offsetX || 0}, height: ${effect.offsetY || 0}), blurRadius: ${effect.radius || 0}, color: ${colorValue})`;
            }
            return null;
          }).filter(Boolean);

          output += `    public static let ${uniqueName}: [NSShadow] = [${shadowsSwift.join(', ')}]\n`;
        }
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

/**
 * Format: JavaScript/TypeScript Effects
 * Exports shadow tokens as properly formatted objects
 */
const javascriptEffectsFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: `effects-${colorMode}.js`,
    commentStyle: 'block',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const uniqueName = uniqueNames.get(token.path.join('.'));

          if (token.comment) {
            output += `/** ${token.comment} */\n`;
          }

          // Convert shadow array to JS object array
          const shadowsJS = token.$value.map(effect => {
            if (effect.type === 'dropShadow') {
              return `{
    offsetX: ${effect.offsetX || 0},
    offsetY: ${effect.offsetY || 0},
    radius: ${effect.radius || 0},
    spread: ${effect.spread || 0},
    color: "${effect.color || 'rgba(0, 0, 0, 0)'}"
  }`;
            }
            return null;
          }).filter(Boolean);

          output += `export const ${uniqueName} = [\n  ${shadowsJS.join(',\n  ')}\n];\n`;
        }
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * Format: Flutter Dart Effects
 * Exports shadow tokens as properly formatted Dart objects
 */
const flutterEffectsFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;
  const className = `Effects${brand.charAt(0).toUpperCase() + brand.slice(1)}${colorMode.charAt(0).toUpperCase() + colorMode.slice(1)}`;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: `effects-${colorMode}.dart`,
    commentStyle: 'line',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  output += `import 'dart:ui';\n\n`;
  output += `class ${className} {\n`;
  output += `    ${className}._();\n\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    output += `    // ============================================\n`;
    output += `    // ${topLevel.toUpperCase()}\n`;
    output += `    // ============================================\n\n`;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `    // ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const uniqueName = uniqueNames.get(token.path.join('.'));

          if (token.comment) {
            output += `    /** ${token.comment} */\n`;
          }

          // Convert shadow array to Dart BoxShadow list
          const shadowsDart = token.$value.map(effect => {
            if (effect.type === 'dropShadow') {
              // Parse color
              let colorValue = 'Color(0xFF000000)';
              if (effect.color) {
                const colorStr = effect.color.replace(/\s/g, '');
                if (colorStr.startsWith('rgba')) {
                  const match = colorStr.match(/rgba?\((\d+),(\d+),(\d+),?([\d.]*)\)/);
                  if (match) {
                    const r = parseInt(match[1]).toString(16).padStart(2, '0');
                    const g = parseInt(match[2]).toString(16).padStart(2, '0');
                    const b = parseInt(match[3]).toString(16).padStart(2, '0');
                    const a = match[4] ? Math.round(parseFloat(match[4]) * 255).toString(16).padStart(2, '0') : 'FF';
                    colorValue = `Color(0x${a}${r}${g}${b})`;
                  }
                } else if (colorStr.startsWith('#')) {
                  const hex = colorStr.replace('#', '');
                  if (hex.length === 6) {
                    colorValue = `Color(0xFF${hex})`;
                  } else if (hex.length === 8) {
                    colorValue = `Color(0x${hex.substring(6, 8)}${hex.substring(0, 6)})`;
                  }
                }
              }

              return `BoxShadow(
      offset: Offset(${effect.offsetX || 0}, ${effect.offsetY || 0}),
      blurRadius: ${effect.radius || 0},
      spreadRadius: ${effect.spread || 0},
      color: ${colorValue}
    )`;
            }
            return null;
          }).filter(Boolean);

          output += `    static const ${uniqueName} = [\n      ${shadowsDart.join(',\n      ')}\n    ];\n`;
        }
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

/**
 * Format: JavaScript/TypeScript Typography
 * Exports typography tokens as properly formatted objects
 */
const javascriptTypographyFormat = ({ dictionary, options }) => {
  const { brand, breakpoint } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: `typography-${breakpoint}.js`,
    commentStyle: 'block',
    brand: brand,
    context: `Breakpoint: ${breakpoint}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const style = token.$value;

          if (token.comment) {
            output += `/** ${token.comment} */\n`;
          }

          output += `export const ${uniqueName} = {\n`;
          if (style.fontFamily) output += `  fontFamily: "${style.fontFamily}",\n`;
          if (style.fontWeight) output += `  fontWeight: ${style.fontWeight},\n`;
          if (style.fontSize) output += `  fontSize: "${typeof style.fontSize === 'number' ? style.fontSize + 'px' : style.fontSize}",\n`;
          if (style.lineHeight) output += `  lineHeight: "${typeof style.lineHeight === 'number' ? style.lineHeight + 'px' : style.lineHeight}",\n`;
          if (style.letterSpacing) output += `  letterSpacing: "${typeof style.letterSpacing === 'number' ? style.letterSpacing + 'px' : style.letterSpacing}",\n`;
          if (style.fontStyle && style.fontStyle !== 'null') output += `  fontStyle: "${style.fontStyle.toLowerCase()}",\n`;
          if (style.textCase && style.textCase !== 'ORIGINAL') output += `  textTransform: "${mapTextCase(style.textCase)}",\n`;
          if (style.textDecoration && style.textDecoration !== 'NONE') output += `  textDecoration: "${style.textDecoration.toLowerCase()}",\n`;
          output += `};\n`;
        }
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * Format: Flutter Dart Typography
 * Exports typography tokens as properly formatted Dart objects
 */
/**
 * Helper: Map font weight number to Flutter FontWeight
 */
function mapFontWeight(weight) {
  if (!weight) return 'FontWeight.w400';
  const w = parseInt(weight);
  if (w >= 900) return 'FontWeight.w900';
  if (w >= 800) return 'FontWeight.w800';
  if (w >= 700) return 'FontWeight.w700';
  if (w >= 600) return 'FontWeight.w600';
  if (w >= 500) return 'FontWeight.w500';
  if (w >= 400) return 'FontWeight.w400';
  if (w >= 300) return 'FontWeight.w300';
  if (w >= 200) return 'FontWeight.w200';
  return 'FontWeight.w100';
}

/**
 * Helper: Map Figma textCase to CSS text-transform value
 * Figma exports: UPPER, LOWER, TITLE, ORIGINAL
 * CSS expects: uppercase, lowercase, capitalize, none
 */
function mapTextCase(figmaTextCase) {
  const mapping = {
    'UPPER': 'uppercase',
    'LOWER': 'lowercase',
    'TITLE': 'capitalize',
    'SMALL_CAPS': 'small-caps',
    'SMALL_CAPS_FORCED': 'small-caps'
  };
  return mapping[figmaTextCase] || figmaTextCase.toLowerCase();
}

/**
 * Format: Flutter Dart Typography using TextStyle class
 * Exports typography tokens as properly typed TextStyle objects
 */
const flutterTypographyFormat = ({ dictionary, options }) => {
  const { brand, breakpoint, sizeClass } = options;
  const className = `Typography${brand.charAt(0).toUpperCase() + brand.slice(1)}${(sizeClass || breakpoint).charAt(0).toUpperCase() + (sizeClass || breakpoint).slice(1)}`;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: `typography-${sizeClass || breakpoint}.dart`,
    commentStyle: 'line',
    brand: brand,
    context: `SizeClass: ${sizeClass || breakpoint}`
  });

  output += `import 'package:flutter/material.dart';\n\n`;
  output += `/// Typography tokens for ${brand} at ${sizeClass || breakpoint} size class\n`;
  output += `/// Usage: Text('Hello', style: ${className}.display1)\n`;
  output += `class ${className} {\n`;
  output += `    ${className}._();\n\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    output += `    // ============================================\n`;
    output += `    // ${topLevel.toUpperCase()}\n`;
    output += `    // ============================================\n\n`;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `    // ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const style = token.$value;

          if (token.comment) {
            output += `    /// ${token.comment}\n`;
          }

          // Build TextStyle with proper Flutter types
          const fontSize = typeof style.fontSize === 'number' ? style.fontSize : parseFloat(style.fontSize) || 16;
          const lineHeight = typeof style.lineHeight === 'number' ? style.lineHeight : parseFloat(style.lineHeight);
          const letterSpacing = typeof style.letterSpacing === 'number' ? style.letterSpacing : parseFloat(style.letterSpacing);

          // Calculate height ratio (Flutter uses height as multiplier, not absolute value)
          const heightRatio = lineHeight && fontSize ? (lineHeight / fontSize).toFixed(2) : null;

          output += `    static const TextStyle ${uniqueName} = TextStyle(\n`;
          if (style.fontFamily) output += `      fontFamily: '${style.fontFamily}',\n`;
          output += `      fontSize: ${fontSize},\n`;
          if (style.fontWeight) output += `      fontWeight: ${mapFontWeight(style.fontWeight)},\n`;
          if (heightRatio && heightRatio !== '1.00') output += `      height: ${heightRatio},\n`;
          if (letterSpacing) output += `      letterSpacing: ${letterSpacing},\n`;
          if (style.fontStyle && style.fontStyle !== 'null' && style.fontStyle.toLowerCase() === 'italic') {
            output += `      fontStyle: FontStyle.italic,\n`;
          }
          if (style.textDecoration && style.textDecoration !== 'NONE') {
            const decoration = style.textDecoration.toLowerCase();
            if (decoration === 'underline') output += `      decoration: TextDecoration.underline,\n`;
            else if (decoration === 'line-through' || decoration === 'strikethrough') output += `      decoration: TextDecoration.lineThrough,\n`;
          }
          output += `    );\n\n`;
        }
      });
    });
  });

  output += `}\n`;
  return output;
};

/**
 * SCSS Effects Format - Outputs shadow tokens as SCSS maps
 */
const scssEffectsFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: `effects-${colorMode}.scss`,
    commentStyle: 'line',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const uniqueName = uniqueNames.get(token.path.join('.'));

          if (token.comment) {
            output += `/** ${token.comment} */\n`;
          }

          // Convert shadow array to SCSS map array with kebab-case keys
          const shadowsSCSS = token.$value.map((effect, idx) => {
            if (effect.type === 'dropShadow') {
              return `  ${idx + 1}: (\n    offset-x: ${effect.offsetX || 0}px,\n    offset-y: ${effect.offsetY || 0}px,\n    blur-radius: ${effect.radius || 0}px,\n    spread-radius: ${effect.spread || 0}px,\n    color: ${effect.color || 'rgba(0, 0, 0, 0)'}\n  )`;
            }
            return null;
          }).filter(Boolean);

          output += `$${uniqueName}: (\n${shadowsSCSS.join(',\n')}\n);\n`;
        }
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * SCSS Typography Format - Outputs typography tokens as SCSS maps
 */
const scssTypographyFormat = ({ dictionary, options }) => {
  const { brand, breakpoint } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: `typography-${breakpoint}.scss`,
    commentStyle: 'line',
    brand: brand,
    context: `Breakpoint: ${breakpoint}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const style = token.$value;

          if (token.comment) {
            output += `/** ${token.comment} */\n`;
          }

          output += `$${uniqueName}: (\n`;
          // Use kebab-case for SCSS map keys (CSS property naming convention)
          if (style.fontFamily) output += `  font-family: ${style.fontFamily},\n`;
          if (style.fontWeight) output += `  font-weight: ${style.fontWeight},\n`;
          if (style.fontSize) output += `  font-size: ${typeof style.fontSize === 'number' ? style.fontSize + 'px' : style.fontSize},\n`;
          if (style.lineHeight) output += `  line-height: ${typeof style.lineHeight === 'number' ? style.lineHeight + 'px' : style.lineHeight},\n`;
          if (style.letterSpacing) output += `  letter-spacing: ${typeof style.letterSpacing === 'number' ? style.letterSpacing + 'px' : style.letterSpacing},\n`;
          if (style.fontStyle && style.fontStyle !== 'null') output += `  font-style: ${style.fontStyle.toLowerCase()},\n`;
          if (style.textCase && style.textCase !== 'ORIGINAL') output += `  text-transform: ${mapTextCase(style.textCase)},\n`;
          if (style.textDecoration && style.textDecoration !== 'NONE') output += `  text-decoration: ${style.textDecoration.toLowerCase()},\n`;
          output += `);\n`;
        }
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * Helper: Calculate Material Design elevation from shadow blur radius
 * Based on Material Design shadow specs where blur roughly maps to elevation
 */
function calculateElevationFromShadow(effects) {
  if (!effects || effects.length === 0) return 0;

  // Get the maximum blur radius from all shadow layers
  const maxBlur = Math.max(...effects.map(e => e.radius || 0));
  const maxOffset = Math.max(...effects.map(e => Math.abs(e.offsetY || 0)));

  // Material Design elevation mapping (approximate)
  // Elevation 1dp ≈ blur 1-2px, 4dp ≈ blur 4-6px, 8dp ≈ blur 12-16px, etc.
  const combined = maxBlur + maxOffset;

  if (combined <= 3) return 1;
  if (combined <= 6) return 2;
  if (combined <= 10) return 4;
  if (combined <= 16) return 6;
  if (combined <= 24) return 8;
  if (combined <= 32) return 12;
  if (combined <= 48) return 16;
  return 24;
}

/**
 * Android XML Effects Format - Outputs shadow tokens with Material Design elevation + raw data
 */
const androidXmlEffectsFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'snake');

  let output = `<?xml version="1.0" encoding="utf-8"?>\n`;

  // Generate header with additional note about Android shadows
  const header = generateFileHeader({
    fileName: `effects-${colorMode}.xml`,
    commentStyle: 'xml',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  // Insert Android-specific note before closing comment
  output += header.replace('-->\n', `\n  NOTE: This file provides both Material Design elevation values and raw shadow data.\n  - Use elevation dimens with CardView, MaterialCardView, or android:elevation\n  - Use string-arrays for custom shadow implementations if needed\n-->\n`);

  output += `<resources>\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  // First pass: Output elevation dimens
  output += `\n  <!-- ============================================ -->\n`;
  output += `  <!-- MATERIAL DESIGN ELEVATION VALUES -->\n`;
  output += `  <!-- Use with android:elevation or CardView.cardElevation -->\n`;
  output += `  <!-- ============================================ -->\n\n`;

  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const elevation = calculateElevationFromShadow(token.$value);

          output += `  <dimen name="${uniqueName}_elevation">${elevation}dp</dimen>\n`;
        }
      });
    });
  });

  // Second pass: Output raw shadow data as string-arrays
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    output += `\n  <!-- ============================================ -->\n`;
    output += `  <!-- ${topLevel.toUpperCase()} - RAW SHADOW DATA -->\n`;
    output += `  <!-- For custom shadow implementations -->\n`;
    output += `  <!-- ============================================ -->\n\n`;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `  <!-- ${topLevel} - ${subLevel} -->\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const uniqueName = uniqueNames.get(token.path.join('.'));

          if (token.comment) {
            output += `  <!-- ${token.comment} -->\n`;
          }

          // Output shadow data as string-array for custom implementations
          output += `  <string-array name="${uniqueName}_data">\n`;
          token.$value.forEach((effect, idx) => {
            if (effect.type === 'dropShadow') {
              // Parse color to Android format
              let colorValue = '#FF000000';
              if (effect.color) {
                const colorStr = effect.color.replace(/\s/g, '');
                if (colorStr.startsWith('rgba')) {
                  const match = colorStr.match(/rgba?\((\d+),(\d+),(\d+),?([\d.]*)\)/);
                  if (match) {
                    const r = parseInt(match[1]).toString(16).padStart(2, '0');
                    const g = parseInt(match[2]).toString(16).padStart(2, '0');
                    const b = parseInt(match[3]).toString(16).padStart(2, '0');
                    const a = match[4] ? Math.round(parseFloat(match[4]) * 255).toString(16).padStart(2, '0') : 'FF';
                    colorValue = `#${a}${r}${g}${b}`;
                  }
                } else if (colorStr.startsWith('#')) {
                  colorValue = colorStr;
                }
              }

              output += `    <item>offsetX:${effect.offsetX || 0}|offsetY:${effect.offsetY || 0}|radius:${effect.radius || 0}|spread:${effect.spread || 0}|color:${colorValue}</item>\n`;
            }
          });
          output += `  </string-array>\n\n`;
        }
      });
    });
  });

  output += `</resources>\n`;
  return output;
};

// ============================================================================
// TRANSFORM GROUPS
// ============================================================================

/**
 * Custom Transform Groups that use our shortened token names
 * IMPORTANT: We do NOT use 'attribute/cti' or 'name/cti/*', as these
 * use the full path. Instead, we only use our custom name transforms.
 *
 * NOTE: 'value/round' is placed LAST in each group to round values
 * AFTER all other transforms (color conversion, size conversion, etc.)
 */
const customTransformGroups = {
  'custom/css': ['name/custom/kebab', 'color/css', 'custom/size/px', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/scss': ['name/custom/kebab', 'color/css', 'custom/size/px', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/js': ['name/custom/js', 'color/css', 'custom/size/px', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/ios-swift': ['name/custom/ios-swift', 'custom/color/UIColor', 'custom/size/ios-points', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/android': ['name/custom/android', 'color/hex', 'custom/size/px', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/flutter': ['name/custom/flutter-dart', 'color/hex', 'custom/size/px', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/compose': ['name/custom/compose', 'color/custom/compose', 'size/custom/compose', 'custom/opacity', 'custom/fontWeight', 'custom/number']
};

// ============================================================================
// THEMED CSS FORMAT - Data-Attribute Based Theme Switching
// ============================================================================

/**
 * Format: CSS Themed Variables with Data-Attributes
 * Generates CSS with [data-brand] and [data-theme/data-breakpoint] selectors
 * for runtime theme switching without file swapping.
 *
 * Options:
 * - brand: Brand name (e.g., 'bild', 'sportbild')
 * - mode: Color mode, breakpoint, or density (e.g., 'light', 'dark', 'xs', 'dense')
 * - modeType: Type of mode ('theme', 'breakpoint', 'density')
 * - includeRoot: Whether to include default :root fallback (default: false)
 */
const cssThemedVariablesFormat = ({ dictionary, options, file }) => {
  const { brand, mode, modeType = 'theme', includeRoot = false } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: brand ? brand.charAt(0).toUpperCase() + brand.slice(1) : 'All Brands',
    context: modeType && mode ? `${modeType}: ${mode}` : 'All Modes'
  });

  // Build selector based on brand and mode
  let selector;
  if (brand && mode) {
    // Specific brand + mode combination
    const dataMode = modeType === 'theme' ? 'data-theme' :
                     modeType === 'breakpoint' ? 'data-breakpoint' :
                     modeType === 'density' ? 'data-density' : 'data-mode';
    selector = `[data-brand="${brand}"][${dataMode}="${mode}"]`;
  } else if (brand) {
    // Brand only
    selector = `[data-brand="${brand}"]`;
  } else if (mode) {
    // Mode only
    const dataMode = modeType === 'theme' ? 'data-theme' :
                     modeType === 'breakpoint' ? 'data-breakpoint' :
                     modeType === 'density' ? 'data-density' : 'data-mode';
    selector = `[${dataMode}="${mode}"]`;
  } else {
    // Fallback to root if no brand/mode specified
    selector = ':root';
  }

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  // Optional: Include :root fallback for default values
  if (includeRoot) {
    output += `:root {\n`;
    output += `  /* Default values (will be overridden by data-attributes) */\n`;

    Object.keys(hierarchicalGroups).forEach(topLevel => {
      const subGroups = hierarchicalGroups[topLevel];
      Object.keys(subGroups).forEach(subLevel => {
        const tokens = subGroups[subLevel];
        tokens.forEach(token => {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const finalValue = token.$value !== undefined ? token.$value : token.value;
          output += `  --${uniqueName}: ${finalValue};\n`;
        });
      });
    });

    output += `}\n\n`;
  }

  // Main themed selector
  output += `${selector} {\n`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `  /* ============================================\n`;
    output += `     ${topLevel.toUpperCase()}\n`;
    output += `     ============================================ */\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `  /* ${topLevel} - ${subLevel} */\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `  /**\n   * ${comment}\n   */\n`;
        }
        const finalValue = token.$value !== undefined ? token.$value : token.value;
        output += `  --${uniqueName}: ${finalValue};\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

// ============================================================================
// CSS FORMAT WITH ALIAS REFERENCES (var() pattern)
// ============================================================================

/**
 * Converts alias token name to CSS variable name
 * Uses kebab-case transformation
 * @param {string} tokenName - Token name from alias
 * @returns {string} - CSS variable name (without --)
 */
function aliasToVarName(tokenName) {
  if (!tokenName) return null;
  return nameTransformers.kebab(tokenName);
}

/**
 * Format: CSS Variables with Alias References
 * Generates CSS with var(--reference, fallback) pattern for tokens with $alias
 * Other platforms ignore $alias and use resolved values
 *
 * For simple tokens: Uses $alias field
 * For combined tokens (typography/effects): Uses $aliases object/array
 */
const cssVariablesWithAliasFormat = ({ dictionary, options, file }) => {
  const selector = options.selector || ':root';
  const context = getContextString(options);
  const { outputReferences = true } = options;

  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: options.brand,
    context: context
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  output += `${selector} {\n`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `  /* ============================================\n`;
    output += `     ${topLevel.toUpperCase()}\n`;
    output += `     ============================================ */\n\n`;
    isFirstTopLevel = false;

    // Sort sub-level keys
    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `  /* ${topLevel} - ${subLevel} */\n`;
      }

      // Add tokens
      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment && options.showDescriptions !== false) {
          output += `  /**\n   * ${comment}\n   */\n`;
        }

        // Use $value (transformed) or fallback to value (original)
        const finalValue = token.$value !== undefined ? token.$value : token.value;

        // Check for $alias (simple tokens) and generate var() reference
        // Skip self-references (when token name equals alias name, e.g., breakpoint → density with same name)
        if (outputReferences && token.$alias && token.$alias.token) {
          const refName = aliasToVarName(token.$alias.token);
          if (refName && refName !== uniqueName) {
            output += `  --${uniqueName}: var(--${refName}, ${finalValue});\n`;
            return;
          }
        }

        // No alias or outputReferences disabled → direct value
        output += `  --${uniqueName}: ${finalValue};\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

/**
 * Format: CSS Themed Variables with Alias References
 * Combines themed data-attribute selectors with var() references
 */
const cssThemedVariablesWithAliasFormat = ({ dictionary, options, file }) => {
  const { brand, mode, modeType = 'theme', includeRoot = false, outputReferences = true } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: brand ? brand.charAt(0).toUpperCase() + brand.slice(1) : 'All Brands',
    context: modeType && mode ? `${modeType}: ${mode}` : 'All Modes'
  });

  // Build selector based on brand and mode
  let selector;
  if (brand && mode) {
    const dataMode = modeType === 'theme' ? 'data-theme' :
                     modeType === 'breakpoint' ? 'data-breakpoint' :
                     modeType === 'density' ? 'data-density' : 'data-mode';
    selector = `[data-brand="${brand}"][${dataMode}="${mode}"]`;
  } else if (brand) {
    selector = `[data-brand="${brand}"]`;
  } else if (mode) {
    const dataMode = modeType === 'theme' ? 'data-theme' :
                     modeType === 'breakpoint' ? 'data-breakpoint' :
                     modeType === 'density' ? 'data-density' : 'data-mode';
    selector = `[${dataMode}="${mode}"]`;
  } else {
    selector = ':root';
  }

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  // Optional: Include :root fallback for default values
  if (includeRoot) {
    output += `:root {\n`;
    output += `  /* Default values (will be overridden by data-attributes) */\n`;

    Object.keys(hierarchicalGroups).forEach(topLevel => {
      const subGroups = hierarchicalGroups[topLevel];
      Object.keys(subGroups).forEach(subLevel => {
        const tokens = subGroups[subLevel];
        tokens.forEach(token => {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const finalValue = token.$value !== undefined ? token.$value : token.value;
          output += `  --${uniqueName}: ${finalValue};\n`;
        });
      });
    });

    output += `}\n\n`;
  }

  // Main themed selector
  output += `${selector} {\n`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `  /* ============================================\n`;
    output += `     ${topLevel.toUpperCase()}\n`;
    output += `     ============================================ */\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `  /* ${topLevel} - ${subLevel} */\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment && options.showDescriptions !== false) {
          output += `  /**\n   * ${comment}\n   */\n`;
        }

        const finalValue = token.$value !== undefined ? token.$value : token.value;

        // Check for $alias and generate var() reference
        // Skip self-references (when token name equals alias name, e.g., breakpoint → density with same name)
        if (outputReferences && token.$alias && token.$alias.token) {
          const refName = aliasToVarName(token.$alias.token);
          if (refName && refName !== uniqueName) {
            output += `  --${uniqueName}: var(--${refName}, ${finalValue});\n`;
            return;
          }
        }

        output += `  --${uniqueName}: ${finalValue};\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

// ============================================================================
// JETPACK COMPOSE FORMATS
// ============================================================================

/**
 * Helper: Convert brand name to PascalCase for Kotlin class names
 */
function brandToPascalCase(brand) {
  if (brand === 'sportbild') return 'Sportbild';
  if (brand === 'advertorial') return 'Advertorial';
  return brand.charAt(0).toUpperCase() + brand.slice(1);
}

/**
 * Format: Jetpack Compose Primitives Object
 * Generates a Kotlin object with internal val declarations for primitive tokens
 *
 * Output example:
 * object ColorPrimitives {
 *     internal val BildRed = Color(0xFFDD0000)
 *     internal val Bild015 = Color(0xFF232629)
 * }
 */
/**
 * Helper: Transform a color value to Compose Color format
 */
function toComposeColor(value) {
  if (!value) return value;

  // Already in Compose format
  if (typeof value === 'string' && value.startsWith('Color(')) {
    return value;
  }

  // Handle hex colors: #RRGGBB or #AARRGGBB
  if (typeof value === 'string' && value.startsWith('#')) {
    let hex = value.replace('#', '').toUpperCase();
    if (hex.length === 6) {
      hex = 'FF' + hex;
    }
    return `Color(0x${hex})`;
  }

  // Handle rgba: rgba(r, g, b, a)
  if (typeof value === 'string' && value.startsWith('rgba')) {
    const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*([\d.]*)\)/);
    if (match) {
      const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
      const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
      const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
      const a = match[4] ? Math.round(parseFloat(match[4]) * 255).toString(16).padStart(2, '0').toUpperCase() : 'FF';
      return `Color(0x${a}${r}${g}${b})`;
    }
  }

  // Handle rgb: rgb(r, g, b)
  if (typeof value === 'string' && value.startsWith('rgb(')) {
    const match = value.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (match) {
      const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
      const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
      const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
      return `Color(0xFF${r}${g}${b})`;
    }
  }

  return value;
}

/**
 * Helper: Transform a size value to Compose Dp format
 */
function toComposeDp(value) {
  // Handle null/undefined
  if (value === null || value === undefined) return value;

  // Already in Compose format
  if (typeof value === 'string' && (value.endsWith('.dp') || value.endsWith('.sp'))) {
    return value;
  }

  // Handle number (including 0)
  if (typeof value === 'number') {
    return `${value}.dp`;
  }

  // Handle string with px
  if (typeof value === 'string') {
    const num = parseFloat(value.replace('px', ''));
    if (!isNaN(num)) {
      return `${num}.dp`;
    }
  }

  return value;
}

/**
 * Helper: Transform a font size value to Compose Sp format
 */
function toComposeSp(value) {
  // Handle null/undefined
  if (value === null || value === undefined) return value;

  // Already in Compose format
  if (typeof value === 'string' && value.endsWith('.sp')) {
    return value;
  }

  // Handle number (including 0)
  if (typeof value === 'number') {
    return `${value}.sp`;
  }

  // Handle string with px
  if (typeof value === 'string') {
    const num = parseFloat(value.replace('px', ''));
    if (!isNaN(num)) {
      return `${num}.sp`;
    }
  }

  return value;
}

const composePrimitivesFormat = ({ dictionary, options, file }) => {
  const { packageName, className } = options;
  const version = packageJson.version;

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

/**
 * ${className} - Primitive design tokens
 * These are the raw values that semantic and component tokens reference.
 */
object ${className} {
`;

  // Group tokens by their first path segment for organization
  const grouped = {};
  dictionary.allTokens.forEach(token => {
    const category = token.path[0] || 'Other';
    if (!grouped[category]) grouped[category] = [];
    grouped[category].push(token);
  });

  Object.keys(grouped).sort().forEach(category => {
    output += `    // ${category}\n`;
    grouped[category].forEach(token => {
      // Use token.name directly - already camelCase from name/custom/compose transform
      const name = token.name;
      const type = token.$type || token.type;
      let value = token.value;

      // Apply Compose-specific formatting based on $type (set by preprocessor)
      if (type === 'color') {
        value = toComposeColor(value);
      } else if (type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing') {
        // Text-related types use sp units
        value = toComposeSp(value);
      } else if (type === 'fontWeight' || type === 'number') {
        // Unitless integers - parse string if needed
        if (typeof value === 'string' && /^\d+$/.test(value)) {
          value = parseInt(value, 10);
        }
      } else if (type === 'opacity') {
        // Opacity stays as float
        if (typeof value === 'string') {
          value = parseFloat(value);
        }
      } else if (type === 'fontFamily' || type === 'string') {
        // Quote string values (font family names, etc.)
        value = `"${value}"`;
      } else if (type === 'dimension') {
        value = toComposeDp(value);
      } else if (type === 'boolean') {
        value = value ? 'true' : 'false';
      }

      output += `    internal val ${name} = ${value}\n`;
    });
    output += `\n`;
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Jetpack Compose Semantic Colors Data Class
 * Generates @Immutable data class with color properties
 *
 * Output example:
 * @Immutable
 * data class BildColorScheme(
 *     val textColorPrimary: Color,
 *     val surfaceColorPrimary: Color,
 * )
 *
 * val BildLightColorScheme = BildColorScheme(
 *     textColorPrimary = Color(0xFF232629),
 *     surfaceColorPrimary = Color(0xFFFFFFFF),
 * )
 */
const composeSemanticColorsFormat = ({ dictionary, options, file }) => {
  const { packageName, brand, mode } = options;
  const brandPascal = brandToPascalCase(brand);
  const modePascal = mode.charAt(0).toUpperCase() + mode.slice(1);
  const version = packageJson.version;

  // Collect all tokens and their properties
  const tokens = dictionary.allTokens.filter(t => {
    const type = t.$type || t.type;
    return type === 'color';
  });

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Brand: ${brandPascal} | Mode: ${modePascal}
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

import androidx.compose.runtime.Immutable
import androidx.compose.runtime.Stable
import androidx.compose.ui.graphics.Color

`;

  // Generate interface (only for Light mode to avoid duplication)
  if (mode.toLowerCase() === 'light') {
    output += `/**
 * Color scheme interface for ${brandPascal}
 * Allows type-safe access to colors and enables color scheme sharing across brands
 */
@Stable
interface ${brandPascal}ColorScheme {
`;
    tokens.forEach(token => {
      output += `    val ${token.name}: Color\n`;
    });
    output += `}

`;
  }

  // Generate object implementing the interface
  output += `/**
 * ${brandPascal} Color Scheme - ${modePascal} Mode
 */
@Immutable
object ${brandPascal}${modePascal}Colors : ${brandPascal}ColorScheme {
`;

  tokens.forEach(token => {
    const name = token.name;
    const value = toComposeColor(token.value);
    output += `    override val ${name} = ${value}\n`;
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Jetpack Compose Spacing/Sizing Object
 * Generates object with Dp values and interfaces for type safety
 */
const composeSpacingFormat = ({ dictionary, options, file }) => {
  const { packageName, brand, mode, modeType } = options;
  const brandPascal = brandToPascalCase(brand);
  const version = packageJson.version;

  // Map mode to correct name (sm -> Compact, lg -> Regular)
  let modePascal = '';
  if (mode) {
    if (mode === 'sm' || mode === 'compact') {
      modePascal = 'Compact';
    } else if (mode === 'lg' || mode === 'regular') {
      modePascal = 'Regular';
    } else {
      modePascal = mode.charAt(0).toUpperCase() + mode.slice(1);
    }
  }

  // Determine class name and interface based on mode type
  let className;
  let interfaceName;
  let generateInterface = false;

  if (modeType === 'sizeclass') {
    className = `${brandPascal}Sizing${modePascal}`;
    interfaceName = `${brandPascal}SizingScheme`;
    // Generate interface only for Compact mode to avoid duplication
    generateInterface = modePascal === 'Compact';
  } else if (modeType === 'density') {
    className = `${brandPascal}Density${modePascal}`;
  } else {
    className = `${brandPascal}Spacing`;
  }

  // Check if any tokens need sp import (font sizes, line heights, letter spacing)
  // Uses $type from preprocessor instead of name-based heuristics
  const needsSpImport = dictionary.allTokens.some(token => {
    const type = token.$type || token.type;
    return type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing';
  });

  const imports = ['import androidx.compose.runtime.Stable', 'import androidx.compose.ui.unit.Dp', 'import androidx.compose.ui.unit.dp'];
  if (needsSpImport) {
    imports.push('import androidx.compose.ui.unit.sp');
    imports.push('import androidx.compose.ui.unit.TextUnit');
  }

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Brand: ${brandPascal}${mode ? ` | ${modeType}: ${modePascal}` : ''}
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

${imports.join('\n')}

`;

  // Helper function to determine if a token should be filtered out
  // Filter out generic string tokens that aren't useful for Compose (e.g., breakpointName, changeOnLg)
  const shouldFilterStringToken = (token) => {
    const type = token.$type || token.type;
    // Keep fontFamily strings, filter out generic strings
    if (type === 'fontFamily') return false;
    if (type === 'string') return true;  // Filter out generic strings
    return false;
  };

  // Filter tokens to exclude generic string tokens
  const filteredTokens = dictionary.allTokens.filter(token => !shouldFilterStringToken(token));

  // Generate interface for sizeclass (only for Compact mode)
  if (generateInterface && modeType === 'sizeclass') {
    output += `/**
 * Sizing scheme interface for ${brandPascal}
 * Provides type-safe access to sizing tokens across WindowSizeClass variants
 */
@Stable
interface ${interfaceName} {
`;
    filteredTokens.forEach(token => {
      const type = token.$type || token.type;

      // Determine Kotlin type based on $type
      let propType = 'Dp';  // Default
      if (type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing') {
        propType = 'TextUnit';
      } else if (type === 'fontFamily') {
        propType = 'String';
      } else if (type === 'fontWeight' || type === 'number' || type === 'opacity') {
        propType = 'Int';
      } else if (type === 'color') {
        propType = 'Color';
      } else if (type === 'boolean') {
        propType = 'Boolean';
      }
      // type === 'dimension' → stays 'Dp'

      output += `    val ${token.name}: ${propType}\n`;
    });
    output += `}

`;
  }

  // Generate object (implementing interface for sizeclass)
  const implementsClause = modeType === 'sizeclass' ? ` : ${interfaceName}` : '';
  const overrideKeyword = modeType === 'sizeclass' ? 'override ' : '';

  output += `/**
 * ${className} - Spacing and sizing tokens
 */
object ${className}${implementsClause} {
`;

  filteredTokens.forEach(token => {
    const name = token.name;
    const type = token.$type || token.type;
    let value = token.value;

    // Apply Compose-specific formatting based on $type (set by preprocessor)
    if (type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing') {
      // Text-related types use sp units
      value = toComposeSp(value);
    } else if (type === 'fontWeight') {
      // FontWeight should always be an integer (e.g., 700, not "700")
      if (typeof value === 'string' && /^\d+$/.test(value)) {
        value = parseInt(value, 10);
      }
    } else if (type === 'number') {
      // Unitless integers
      if (typeof value === 'string' && /^\d+$/.test(value)) {
        value = parseInt(value, 10);
      }
    } else if (type === 'opacity') {
      // Opacity as float
      if (typeof value === 'string') {
        value = parseFloat(value);
      }
    } else if (type === 'fontFamily') {
      // Quote string values
      value = `"${value}"`;
    } else if (type === 'dimension') {
      value = toComposeDp(value);
    } else if (type === 'color') {
      value = toComposeColor(value);
    } else if (type === 'boolean') {
      value = value ? 'true' : 'false';
    }

    output += `    ${overrideKeyword}val ${name} = ${value}\n`;
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Jetpack Compose Component Tokens (Aggregated)
 * Generates a single file with Colors, Sizing, Density data classes for a component
 */
const composeComponentTokensFormat = ({ dictionary, options, file }) => {
  const { packageName, componentName, brand, tokenType, mode } = options;
  const brandPascal = brandToPascalCase(brand);
  const version = packageJson.version;

  // Map mode to correct name (sm -> Compact, lg -> Regular)
  let modePascal = '';
  if (mode) {
    if (mode === 'sm' || mode === 'compact') {
      modePascal = 'Compact';
    } else if (mode === 'lg' || mode === 'regular') {
      modePascal = 'Regular';
    } else {
      modePascal = mode.charAt(0).toUpperCase() + mode.slice(1);
    }
  }

  // Check if any tokens need sp import (font sizes, line heights, letter spacing)
  // Uses $type from preprocessor instead of name-based heuristics
  const needsSpImport = dictionary.allTokens.some(token => {
    const type = token.$type || token.type;
    return type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing';
  });

  // Determine output class name
  let className;
  let imports = [];

  if (tokenType === 'color') {
    className = `${componentName}Colors${modePascal}`;
    imports.push('import androidx.compose.ui.graphics.Color');
  } else if (tokenType === 'sizing' || tokenType === 'breakpoint') {
    className = `${componentName}Sizing${modePascal}`;
    imports.push('import androidx.compose.ui.unit.Dp');
    imports.push('import androidx.compose.ui.unit.dp');
    if (needsSpImport) imports.push('import androidx.compose.ui.unit.sp');
  } else if (tokenType === 'density') {
    className = `${componentName}Density${modePascal}`;
    imports.push('import androidx.compose.ui.unit.Dp');
    imports.push('import androidx.compose.ui.unit.dp');
    if (needsSpImport) imports.push('import androidx.compose.ui.unit.sp');
  } else if (tokenType === 'typography') {
    className = `${componentName}Typography${modePascal}`;
    imports.push('import androidx.compose.ui.unit.sp');
  } else {
    className = `${componentName}Tokens${modePascal}`;
    imports.push('import androidx.compose.ui.graphics.Color');
    imports.push('import androidx.compose.ui.unit.Dp');
    imports.push('import androidx.compose.ui.unit.dp');
    if (needsSpImport) imports.push('import androidx.compose.ui.unit.sp');
  }

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Component: ${componentName} | Brand: ${brandPascal}${mode ? ` | ${tokenType}: ${modePascal}` : ''}
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

${imports.join('\n')}

/**
 * ${className}
 */
object ${className} {
`;

  dictionary.allTokens.forEach(token => {
    const name = token.name;
    const type = token.$type || token.type;
    let value = token.value;

    // Apply Compose-specific formatting based on $type (set by preprocessor)
    if (type === 'color') {
      value = toComposeColor(value);
    } else if (type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing') {
      // Text-related types use sp units
      value = toComposeSp(value);
    } else if (type === 'fontWeight') {
      // FontWeight should always be an integer (e.g., 700, not "700")
      if (typeof value === 'string' && /^\d+$/.test(value)) {
        value = parseInt(value, 10);
      }
    } else if (type === 'number') {
      // Unitless integers
      if (typeof value === 'string' && /^\d+$/.test(value)) {
        value = parseInt(value, 10);
      }
    } else if (type === 'opacity') {
      // Opacity as float
      if (typeof value === 'string') {
        value = parseFloat(value);
      }
    } else if (type === 'fontFamily' || type === 'string') {
      // Quote string values
      value = `"${value}"`;
    } else if (type === 'dimension') {
      value = toComposeDp(value);
    } else if (type === 'boolean') {
      value = value ? 'true' : 'false';
    }

    output += `    val ${name} = ${value}\n`;
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Jetpack Compose Typography Tokens
 * Generates typography values (not full TextStyle, as FontFamily needs runtime injection)
 */
const composeTypographyFormat = ({ dictionary, options, file }) => {
  const { packageName, brand, mode, componentName } = options;
  const brandPascal = brandToPascalCase(brand);
  const modePascal = mode ? mode.charAt(0).toUpperCase() + mode.slice(1) : '';
  const version = packageJson.version;

  const prefix = componentName ? componentName : brandPascal;
  const className = `${prefix}Typography${modePascal}Values`;

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Brand: ${brandPascal}${mode ? ` | SizeClass: ${modePascal}` : ''}${componentName ? ` | Component: ${componentName}` : ''}
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.unit.sp

/**
 * ${className}
 * Note: FontFamily should be provided at runtime via CompositionLocal
 */
object ${className} {
`;

  dictionary.allTokens.forEach(token => {
    const value = token.$value || token.value;

    // Handle composite typography tokens
    if (typeof value === 'object' && value !== null) {
      output += `    // ${token.name}\n`;
      if (value.fontFamily) output += `    val ${token.name}FontFamily = "${value.fontFamily}"\n`;
      if (value.fontWeight) {
        // Ensure fontWeight is an integer, not a string
        const fontWeight = typeof value.fontWeight === 'string' ? parseInt(value.fontWeight, 10) : value.fontWeight;
        output += `    val ${token.name}FontWeight = ${fontWeight}\n`;
      }
      if (value.fontSize) output += `    val ${token.name}FontSize = ${value.fontSize}.sp\n`;
      if (value.lineHeight) output += `    val ${token.name}LineHeight = ${value.lineHeight}.sp\n`;
      if (value.letterSpacing !== null && value.letterSpacing !== undefined) {
        output += `    val ${token.name}LetterSpacing = ${value.letterSpacing}f.sp\n`;
      }
      // Handle fontStyle for italic support - output Compose FontStyle enum value
      if (value.fontStyle && value.fontStyle !== 'null' && value.fontStyle.toLowerCase() === 'italic') {
        output += `    val ${token.name}FontStyle = FontStyle.Italic\n`;
      }
      if (value.textCase) output += `    val ${token.name}TextCase = "${value.textCase}"\n`;
      output += `\n`;
    } else {
      output += `    val ${token.name} = ${token.value}\n`;
    }
  });

  output += `}\n`;
  return output;
};

// ============================================================================
// EXPORTS
// ============================================================================

module.exports = {
  transforms: {
    'color/css': colorCssTransform,
    'custom/color/UIColor': colorUIColorTransform,
    'custom/size/px': sizePxTransform,
    'custom/size/ios-points': sizeIosPointsTransform,
    'size/rem': sizeRemTransform,
    'custom/opacity': opacityTransform,
    'custom/fontWeight': fontWeightTransform,
    'custom/number': numberTransform,
    'name/custom/kebab': nameKebabTransform,
    'name/custom/js': nameJsTransform,
    'name/custom/ios-swift': nameIosSwiftTransform,
    'name/custom/android': nameAndroidTransform,
    'name/custom/flutter-dart': nameFlutterDartTransform,
    'name/custom/compose': nameComposeTransform,
    'color/custom/compose': colorComposeTransform,
    'size/custom/compose': sizeComposeTransform,
    'value/round': valueRoundTransform
  },
  transformGroups: customTransformGroups,
  formats: {
    // Classic Token Formats - Custom versions with hierarchical grouping
    'custom/css/variables': cssVariablesFormat,
    'custom/scss/variables': scssVariablesFormat,
    'custom/javascript/es6': javascriptEs6Format,
    'custom/json/nested': jsonNestedFormat,
    'ios-swift/class': iosSwiftClassFormat,
    'flutter/class': flutterDartClassFormat,
    'android/resources': androidResourcesFormat,

    // Themed CSS Format - Data-attribute based theme switching
    'custom/css/themed-variables': cssThemedVariablesFormat,

    // CSS Formats with Alias References (var() pattern)
    'custom/css/variables-with-alias': cssVariablesWithAliasFormat,
    'custom/css/themed-variables-with-alias': cssThemedVariablesWithAliasFormat,

    // Composite Token Formats
    'css/typography-classes': cssTypographyClassesFormat,
    'css/effect-classes': cssEffectClassesFormat,
    'javascript/effects': javascriptEffectsFormat,
    'javascript/typography': javascriptTypographyFormat,
    'flutter/effects': flutterEffectsFormat,
    'flutter/typography': flutterTypographyFormat,
    'ios-swift/effects': iosSwiftEffectsFormat,
    'ios-swift/typography': iosSwiftTypographyFormat,
    'scss/effects': scssEffectsFormat,
    'scss/typography': scssTypographyFormat,
    'android/effects': androidXmlEffectsFormat,
    'android/typography-styles': androidXmlTypographyFormat,

    // Jetpack Compose Formats
    'compose/primitives': composePrimitivesFormat,
    'compose/semantic-colors': composeSemanticColorsFormat,
    'compose/spacing': composeSpacingFormat,
    'compose/component-tokens': composeComponentTokensFormat,
    'compose/typography': composeTypographyFormat
  }
};

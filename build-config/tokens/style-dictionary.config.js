/**
 * Style Dictionary Konfiguration für BILD Design System (v4)
 *
 * Diese Datei exportiert Custom Transforms und Formats
 * für Style Dictionary v4
 */

const path = require('path');
const packageJson = require('../../package.json');

// ============================================================================
// FILE HEADER GENERATORS
// ============================================================================

/**
 * Generates standardized file header for all output formats
 * @param {Object} options - Header configuration
 * @param {String} options.fileName - Name of the generated file
 * @param {String} options.commentStyle - Comment style: 'block' | 'line' | 'xml'
 * @param {String} [options.brand] - Brand name (e.g., 'BILD', 'SportBILD')
 * @param {String} [options.context] - Additional context (e.g., 'Light', 'Dark', 'Compact')
 * @returns {String} - Formatted header string
 */
function generateFileHeader({ fileName, commentStyle, brand, context }) {
  const version = packageJson.version;
  const repoUrl = packageJson.homepage;

  const lines = [
    'Do not edit directly, this file was auto-generated.',
    '',
    `BILD Design System Tokens v${version}`,
    'Generated by Style Dictionary v4.0.0',
    ''
  ];

  // Add Brand + Context if available
  if (brand && context) {
    lines.push(`Brand: ${brand} | Context: ${context}`);
    lines.push('');
  } else if (brand) {
    lines.push(`Brand: ${brand}`);
    lines.push('');
  } else if (context) {
    lines.push(`Context: ${context}`);
    lines.push('');
  }

  lines.push(
    'Copyright (c) 2024 Axel Springer Deutschland GmbH',
    'Proprietary and confidential. All rights reserved.',
    '',
    `Documentation: ${repoUrl}`
  );

  // Format based on comment style
  switch (commentStyle) {
    case 'block': // CSS, JS, Swift
      return '/**\n * ' + lines.join('\n * ') + '\n */\n\n';

    case 'line': // SCSS, Dart, Swift alternative
      return '//\n// ' + lines.join('\n// ') + '\n//\n\n';

    case 'xml': // Android XML
      return '<!--\n  ' + lines.join('\n  ') + '\n-->\n';

    default:
      return '/**\n * ' + lines.join('\n * ') + '\n */\n\n';
  }
}

/**
 * Helper to extract context information from options
 */
function getContextString(options) {
  const contexts = [];
  if (options.mode) contexts.push(options.mode);
  if (options.colorMode) contexts.push(options.colorMode);
  if (options.density) contexts.push(options.density);
  if (options.breakpoint) contexts.push(options.breakpoint);
  if (options.sizeClass) contexts.push(options.sizeClass);
  if (options.layer) contexts.push(options.layer);

  return contexts.length > 0 ? contexts.join(', ') : null;
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Groups tokens hierarchically by path segments
 * Returns a structure: { topLevel: { subLevel: [tokens] } }
 */
function groupTokensHierarchically(tokens) {
  const grouped = {};

  tokens.forEach(token => {
    const pathSegments = token.path.slice(0, -1); // All segments except last (token name)

    if (pathSegments.length === 0) {
      if (!grouped['Other']) grouped['Other'] = {};
      if (!grouped['Other']['']) grouped['Other'][''] = [];
      grouped['Other'][''].push(token);
      return;
    }

    const topLevel = pathSegments[0]; // First segment (e.g., "Semantic", "Component")
    const subLevel = pathSegments.slice(1).join(' - '); // Remaining segments (e.g., "Text", "Button - Primary")

    if (!grouped[topLevel]) {
      grouped[topLevel] = {};
    }

    if (!grouped[topLevel][subLevel]) {
      grouped[topLevel][subLevel] = [];
    }

    grouped[topLevel][subLevel].push(token);
  });

  return grouped;
}

/**
 * Name transformation functions for different platforms
 */
const nameTransformers = {
  // Kebab-case für CSS, SCSS
  kebab: (str) => {
    return str
      .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
      .replace(/([a-zA-Z])(\d)/g, '$1-$2')    // Separate letter-to-number (e.g., red50 → red-50)
      .replace(/(\d)([a-zA-Z])/g, '$1-$2')    // Separate number-to-letter (e.g., 1x → 1-x)
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  },

  // snake_case für Android (hyphens sind in Android XML nicht erlaubt)
  snake: (str) => {
    return str
      .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
      .toLowerCase()
      .replace(/[^a-z0-9_]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '');
  },

  // camelCase für JavaScript, Flutter, iOS Swift
  camel: (str) => {
    const kebab = nameTransformers.kebab(str);
    // First: Keep letters after numbers lowercase (e.g., 1-x → 1x, not 1X)
    let result = kebab.replace(/(\d)-([a-z])/g, '$1$2');
    // Then: Uppercase letters after hyphens (standard camelCase)
    result = result.replace(/-([a-z0-9])/g, (_, letter) => letter.toUpperCase());

    // Prefix with underscore if starts with a number (invalid JS identifier)
    if (/^[0-9]/.test(result)) {
      result = '_' + result;
    }

    return result;
  },

  // PascalCase (kept for potential future use)
  pascal: (str) => {
    const camel = nameTransformers.camel(str);
    if (camel.length === 0) return camel;

    // If starts with underscore followed by number, keep underscore
    if (camel.startsWith('_')) {
      return '_' + camel.charAt(1).toUpperCase() + camel.slice(2);
    }

    return camel.charAt(0).toUpperCase() + camel.slice(1);
  }
};

/**
 * Generates unique token names by using the minimum number of path segments needed
 * to avoid collisions. Starts with the last segment, adds previous segments as needed.
 *
 * @param {Array} tokens - Array of tokens to process
 * @param {String} transformType - Type of transformation: 'kebab', 'camel', or 'pascal'
 * @returns {Map} - Map of token path string to unique name
 */
function generateUniqueNames(tokens, transformType = 'kebab') {
  const transformFn = nameTransformers[transformType];
  const nameMap = new Map();
  const collisionGroups = new Map();

  // First pass: Group tokens by their base name (last segment only)
  tokens.forEach(token => {
    const lastSegment = token.path[token.path.length - 1];
    const baseName = transformFn(lastSegment);
    const pathKey = token.path.join('.');

    if (!collisionGroups.has(baseName)) {
      collisionGroups.set(baseName, []);
    }
    collisionGroups.get(baseName).push({ token, pathKey });
  });

  // Second pass: Generate unique names, resolving collisions
  collisionGroups.forEach((tokenGroup, baseName) => {
    if (tokenGroup.length === 1) {
      // No collision - use simple name
      nameMap.set(tokenGroup[0].pathKey, baseName);
    } else {
      // Collision detected - resolve by adding more path segments
      tokenGroup.forEach(({ token, pathKey }) => {
        let uniqueName = baseName;
        let segmentCount = 1;

        // Incrementally add more segments until name is unique within this collision group
        while (segmentCount < token.path.length) {
          segmentCount++;
          const segments = token.path.slice(-segmentCount);
          const candidateName = transformFn(segments.join('-'));

          // Check if candidate is unique within this collision group
          const hasCollision = tokenGroup.some(other => {
            if (other.pathKey === pathKey) return false; // Don't compare with self
            const otherSegments = other.token.path.slice(-segmentCount);
            return transformFn(otherSegments.join('-')) === candidateName;
          });

          if (!hasCollision) {
            uniqueName = candidateName;
            break;
          }
        }

        // Fallback: use full path if still not unique (edge case)
        if (segmentCount >= token.path.length && tokenGroup.length > 1) {
          uniqueName = transformFn(token.path.join('-'));
        }

        nameMap.set(pathKey, uniqueName);
      });
    }
  });

  return nameMap;
}

// ============================================================================
// SEMANTIC REFERENCE DETECTION HELPERS
// ============================================================================

/**
 * Checks if a token references the semantic layer (ColorMode or BreakpointMode)
 * @param {Object} token - Style Dictionary token
 * @returns {boolean}
 */
function isSemanticReference(token) {
  return token.$alias?.collectionType === 'semantic';
}

/**
 * Checks if ALL tokens in an array are semantic references
 * @param {Array} tokens - Array of Style Dictionary tokens
 * @returns {boolean}
 */
function allTokensAreSemantic(tokens) {
  if (!tokens || tokens.length === 0) return false;
  return tokens.every(token => isSemanticReference(token));
}

/**
 * Partitions tokens into semantic and non-semantic groups
 * @param {Array} tokens - Array of Style Dictionary tokens
 * @returns {Object} { semantic: [...], nonSemantic: [...] }
 */
function partitionTokensByReferenceType(tokens) {
  const semantic = [];
  const nonSemantic = [];

  tokens.forEach(token => {
    if (isSemanticReference(token)) {
      semantic.push(token);
    } else {
      nonSemantic.push(token);
    }
  });

  return { semantic, nonSemantic };
}

// ============================================================================
// CUSTOM TRANSFORMS
// ============================================================================

/**
 * Transform: Color zu CSS hex/rgba
 */
const colorCssTransform = {
  name: 'color/css',
  type: 'value',
  filter: (token) => token.$type === 'color' || token.type === 'color',
  transform: (token) => {
    // If already a valid color value, return directly
    if (typeof token.$value === 'string' || typeof token.value === 'string') {
      return token.$value || token.value;
    }
    return token.$value || token.value;
  }
};

/**
 * Transform: Color zu iOS UIColor
 */
const colorUIColorTransform = {
  name: 'custom/color/UIColor',
  type: 'value',
  transitive: true,
  filter: (token) => token.$type === 'color' || token.type === 'color',
  transform: (token) => {
    const value = token.$value || token.value;

    // Hex zu UIColor
    if (value.startsWith('#')) {
      const hex = value.replace('#', '');
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      const a = hex.length === 8 ? parseInt(hex.substring(6, 8), 16) / 255 : 1;

      return `UIColor(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: ${a.toFixed(3)})`;
    }

    // RGBA zu UIColor
    if (value.startsWith('rgb')) {
      const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (match) {
        const r = parseInt(match[1]) / 255;
        const g = parseInt(match[2]) / 255;
        const b = parseInt(match[3]) / 255;
        const a = match[4] ? parseFloat(match[4]) : 1;

        return `UIColor(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: ${a.toFixed(3)})`;
      }
    }

    return value;
  }
};

/**
 * Helper function to round numeric values (defined here for use in transforms)
 */
function roundValue(value) {
  if (typeof value === 'number') {
    // If it's a whole number, return as-is
    if (Number.isInteger(value)) {
      return value;
    }
    // Round to 2 decimal places
    return Math.round(value * 100) / 100;
  }
  return value;
}

/**
 * Transform: Dimension zu px (with rounding)
 */
const sizePxTransform = {
  name: 'custom/size/px',  // Renamed to avoid conflicts with built-in transforms
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;

    // Only match if type is dimension-related AND value is numeric
    const isMatchingType = ['spacing', 'size', 'fontSize', 'dimension'].includes(type);
    const isNumeric = typeof value === 'number';

    return isMatchingType && isNumeric;
  },
  transform: (token) => {
    const value = token.$value || token.value;

    // Safety check: only transform if value is actually a number
    if (typeof value === 'number') {
      // Round the value before adding 'px' to remove floating-point precision errors
      const rounded = roundValue(value);
      return `${rounded}px`;
    }

    // If not a number, return unchanged (shouldn't happen due to filter, but safety first)
    return value;
  }
};

/**
 * Transform: Spacing/Sizing zu rem (with rounding)
 */
const sizeRemTransform = {
  name: 'size/rem',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    return ['spacing', 'size', 'fontSize', 'dimension'].includes(type);
  },
  transform: (token) => {
    const value = token.$value || token.value;
    if (typeof value === 'number') {
      // Konvertiere px zu rem (angenommen 16px = 1rem) and round
      const remValue = value / 16;
      const rounded = roundValue(remValue);
      return `${rounded}rem`;
    }
    return value;
  }
};

/**
 * Transform: Dimension zu iOS Points (CGFloat - reine Zahlen ohne Einheit)
 * iOS nutzt Points statt Pixels. 1pt ≈ 1px auf @1x screens
 */
const sizeIosPointsTransform = {
  name: 'custom/size/ios-points',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;

    // Only match if type is dimension-related AND value is numeric
    const isMatchingType = ['spacing', 'size', 'fontSize', 'dimension'].includes(type);
    const isNumeric = typeof value === 'number';

    return isMatchingType && isNumeric;
  },
  transform: (token) => {
    const value = token.$value || token.value;

    // Return rounded number (CGFloat) without any unit
    if (typeof value === 'number') {
      return roundValue(value);
    }

    return value;
  }
};

/**
 * Transform: Name zu CSS Custom Property (Kebab-Case)
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameKebabTransform = {
  name: 'name/custom/kebab',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    return nameTransformers.kebab(lastSegment);
  }
};

/**
 * Transform: Name zu gültigem JavaScript Identifier (Camel-Case)
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameJsTransform = {
  name: 'name/custom/js',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    return nameTransformers.camel(lastSegment);
  }
};

/**
 * Transform: Name für iOS Swift (PascalCase, behält Unterstriche in Dezimalzahlen)
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameIosSwiftTransform = {
  name: 'name/custom/ios-swift',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    // Changed from PascalCase to camelCase - more consistent with Swift property naming
    return nameTransformers.camel(lastSegment);
  }
};

/**
 * Transform: Name für Jetpack Compose (camelCase für Properties)
 * Verwendet nur das letzte Pfad-Segment für den Token-Namen
 */
const nameComposeTransform = {
  name: 'name/custom/compose',
  type: 'name',
  transform: (token) => {
    const lastSegment = token.path[token.path.length - 1];
    return nameTransformers.camel(lastSegment);
  }
};

/**
 * Transform: Color für Jetpack Compose - Color(0xFFRRGGBB) Format
 */
const colorComposeTransform = {
  name: 'color/custom/compose',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    return type === 'color';
  },
  transform: (token) => {
    const value = token.$value || token.value;

    // Handle hex colors: #RRGGBB or #AARRGGBB
    if (typeof value === 'string' && value.startsWith('#')) {
      let hex = value.replace('#', '').toUpperCase();
      // If 6 chars, add FF alpha prefix
      if (hex.length === 6) {
        hex = 'FF' + hex;
      }
      // If 8 chars (AARRGGBB), use as-is
      return `Color(0x${hex})`;
    }

    // Handle rgba: rgba(r, g, b, a)
    if (typeof value === 'string' && value.startsWith('rgba')) {
      const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*([\d.]*)\)/);
      if (match) {
        const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
        const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
        const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
        const a = match[4] ? Math.round(parseFloat(match[4]) * 255).toString(16).padStart(2, '0').toUpperCase() : 'FF';
        return `Color(0x${a}${r}${g}${b})`;
      }
    }

    // Handle rgb: rgb(r, g, b)
    if (typeof value === 'string' && value.startsWith('rgb(')) {
      const match = value.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (match) {
        const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
        const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
        const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
        return `Color(0xFF${r}${g}${b})`;
      }
    }

    // Fallback
    return value;
  }
};

/**
 * Transform: Size/Dimension für Jetpack Compose - X.dp Format
 */
const sizeComposeTransform = {
  name: 'size/custom/compose',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    return type === 'dimension' || type === 'float' || type === 'sizing' || type === 'spacing';
  },
  transform: (token) => {
    let value = token.$value || token.value;

    // Remove 'px' if present and convert to number
    if (typeof value === 'string') {
      value = parseFloat(value.replace('px', ''));
    }

    // Return as Dp value
    if (Number.isInteger(value)) {
      return `${value}.dp`;
    }
    return `${value}.dp`;
  }
};

/**
 * Transform: Opacity - Convert Figma % (5, 10, 70) to CSS decimal (0.05, 0.1, 0.7)
 */
const opacityTransform = {
  name: 'custom/opacity',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;
    return type === 'opacity' && typeof value === 'number';
  },
  transform: (token) => {
    const value = token.$value || token.value;
    // Figma exports % (5, 10, 70), CSS needs 0-1 (0.05, 0.1, 0.7)
    const cssValue = value / 100;
    return roundValue(cssValue); // Round to avoid precision errors
  }
};

/**
 * Transform: Font Weight - Unitless integer
 */
const fontWeightTransform = {
  name: 'custom/fontWeight',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;
    return type === 'fontWeight' && typeof value === 'number';
  },
  transform: (token) => {
    return Math.round(token.$value || token.value); // 700, no "px"
  }
};

/**
 * Transform: Number - Unitless rounded number (for columns, z-index, etc.)
 */
const numberTransform = {
  name: 'custom/number',
  type: 'value',
  filter: (token) => {
    const type = token.$type || token.type;
    const value = token.$value || token.value;
    return type === 'number' && typeof value === 'number';
  },
  transform: (token) => {
    return Math.round(token.$value || token.value); // Unitless integer
  }
};

/**
 * Transform: Round numeric values to remove floating-point precision errors
 * This transform runs AFTER all other value transforms (color, size, etc.)
 * and rounds numeric values in strings to 2 decimal places
 */
const valueRoundTransform = {
  name: 'value/round',
  type: 'value',
  transitive: true,
  filter: () => true,
  transform: (token) => {
    let value = token.$value || token.value;

    // Only process string values that might contain numbers
    if (typeof value !== 'string') {
      return value;
    }

    // Round rgba() alpha values (0.699999988079071 -> 0.7)
    value = value.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/g, (match, r, g, b, a) => {
      const roundedAlpha = Math.round(parseFloat(a) * 100) / 100;
      return `rgba(${r}, ${g}, ${b}, ${roundedAlpha})`;
    });

    // Round UIColor values (for iOS)
    value = value.replace(/(red|green|blue|alpha):\s*([\d.]+)/g, (match, component, num) => {
      const rounded = Math.round(parseFloat(num) * 1000) / 1000; // 3 decimals for UIColor
      return `${component}: ${rounded}`;
    });

    // Round pixel values (0.33000001311302185px -> 0.33px, 16.0px -> 16px)
    value = value.replace(/([\d.]+)px/g, (match, num) => {
      const n = parseFloat(num);
      if (Number.isInteger(n)) {
        return `${n}px`;
      }
      const rounded = Math.round(n * 100) / 100;
      return `${rounded}px`;
    });

    // Round rem values
    value = value.replace(/([\d.]+)rem/g, (match, num) => {
      const n = parseFloat(num);
      if (Number.isInteger(n)) {
        return `${n}rem`;
      }
      const rounded = Math.round(n * 100) / 100;
      return `${rounded}rem`;
    });

    // Round em values
    value = value.replace(/([\d.]+)em/g, (match, num) => {
      const n = parseFloat(num);
      if (Number.isInteger(n)) {
        return `${n}em`;
      }
      const rounded = Math.round(n * 100) / 100;
      return `${rounded}em`;
    });

    // Round percentage values
    value = value.replace(/([\d.]+)%/g, (match, num) => {
      const n = parseFloat(num);
      if (Number.isInteger(n)) {
        return `${n}%`;
      }
      const rounded = Math.round(n * 100) / 100;
      return `${rounded}%`;
    });

    // Round standalone decimal numbers (for opacity, line-height, etc.)
    // Only if they have more than 2 decimal places
    if (/^[\d.]+$/.test(value) && value.includes('.')) {
      const num = parseFloat(value);
      if (!Number.isInteger(num) && value.split('.')[1].length > 2) {
        const rounded = Math.round(num * 100) / 100;
        return rounded.toString();
      }
    }

    return value;
  }
};

// ============================================================================
// CUSTOM FORMATS
// ============================================================================

/**
 * Format: CSS Custom Properties mit Kategorisierung und Gruppierung
 */
const cssVariablesFormat = ({ dictionary, options, file }) => {
  const selector = options.selector || ':root';
  const context = getContextString(options);

  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: options.brand,
    context: context
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  output += `${selector} {\n`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `  /* ============================================\n`;
    output += `     ${topLevel.toUpperCase()}\n`;
    output += `     ============================================ */\n\n`;
    isFirstTopLevel = false;

    // Sort sub-level keys
    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `  /* ${topLevel} - ${subLevel} */\n`;
      }

      // Add tokens
      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `  /**\n   * ${comment}\n   */\n`;
        }
        // Use $value (transformed) or fallback to value (original)
        const finalValue = token.$value !== undefined ? token.$value : token.value;
        output += `  --${uniqueName}: ${finalValue};\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

/**
 * Format: SCSS Variables mit Gruppierung
 */
const scssVariablesFormat = ({ dictionary, options, file }) => {
  const context = getContextString(options);
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'line',
    brand: options.brand,
    context: context
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `// ${comment}\n`;
        }
        output += `$${uniqueName}: ${token.$value !== undefined ? token.$value : token.value};\n`;
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * Format: JavaScript/TypeScript ES6 Module mit Gruppierung
 */
const javascriptEs6Format = ({ dictionary, options, file }) => {
  const context = getContextString(options);
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: options.brand,
    context: context
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `/** ${comment} */\n`;
        }
        output += `export const ${uniqueName} = "${token.$value !== undefined ? token.$value : token.value}";\n`;
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * Format: JSON strukturiert
 */
const jsonNestedFormat = ({ dictionary }) => {
  return JSON.stringify(dictionary.tokens, null, 2);
};

/**
 * Format: iOS Swift Class mit korrekter className Handhabung und Gruppierung
 */
const iosSwiftClassFormat = ({ dictionary, options, file }) => {
  const className = options.className || file.className || 'StyleDictionary';
  const context = getContextString(options);
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'line',
    brand: options.brand,
    context: context
  });

  output += `import UIKit\n\npublic class ${className} {\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `    // MARK: - ============================================\n`;
    output += `    // MARK: - ${topLevel.toUpperCase()}\n`;
    output += `    // MARK: - ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `    // MARK: - ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `    /** ${comment} */\n`;
        }

        let valueOutput;
        const value = token.$value !== undefined ? token.$value : token.value;
        const type = token.$type || token.type;

        if (type === 'color') {
          // Value from custom/color/UIColor transform is already formatted as UIColor constructor
          if (value.startsWith('UIColor(')) {
            valueOutput = value;  // Use directly without quotes
          } else if (value.startsWith('#')) {
            const hex = value.replace('#', '');
            const r = (parseInt(hex.substring(0, 2), 16) / 255).toFixed(3);
            const g = (parseInt(hex.substring(2, 4), 16) / 255).toFixed(3);
            const b = (parseInt(hex.substring(4, 6), 16) / 255).toFixed(3);
            const a = hex.length === 8 ? (parseInt(hex.substring(6, 8), 16) / 255).toFixed(3) : '1.000';
            valueOutput = `UIColor(red: ${r}, green: ${g}, blue: ${b}, alpha: ${a})`;
          } else if (value.startsWith('rgb')) {
            const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (match) {
              const r = (parseInt(match[1]) / 255).toFixed(3);
              const g = (parseInt(match[2]) / 255).toFixed(3);
              const b = (parseInt(match[3]) / 255).toFixed(3);
              const a = match[4] ? parseFloat(match[4]).toFixed(3) : '1.000';
              valueOutput = `UIColor(red: ${r}, green: ${g}, blue: ${b}, alpha: ${a})`;
            } else {
              valueOutput = `"${value}"`;
            }
          } else {
            valueOutput = `"${value}"`;
          }
        } else if (typeof value === 'number') {
          valueOutput = value;
        } else if (typeof value === 'string') {
          valueOutput = `"${value}"`;
        } else {
          valueOutput = value;
        }

        output += `    public static let ${uniqueName} = ${valueOutput}\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

// ============================================================================
// COMPOSITE TOKEN FORMATS
// ============================================================================

/**
 * Format: CSS Typography Classes
 * Generiert fertige CSS-Klassen für Typography Composite Tokens
 */
const cssTypographyClassesFormat = ({ dictionary, options }) => {
  const { brand, breakpoint } = options;

  let output = generateFileHeader({
    fileName: `typography-${breakpoint}.css`,
    commentStyle: 'block',
    brand: brand,
    context: `Breakpoint: ${breakpoint}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  // Build data-attribute selector for Strategy A (full brand + breakpoint scoping)
  const brandLowercase = brand.toLowerCase();
  const dataSelector = `[data-brand="${brandLowercase}"][data-breakpoint="${breakpoint}"]`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `/* ============================================\n`;
    output += `   ${topLevel.toUpperCase()}\n`;
    output += `   ============================================ */\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `/* ${topLevel} - ${subLevel} */\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const style = token.$value;
          const aliases = token.$aliases || {};

          // Helper to get value with var() reference if alias exists
          const getValueWithAlias = (property, value, unit = '') => {
            const alias = aliases[property];
            if (alias?.token) {
              const varName = nameTransformers.kebab(alias.token);
              const formattedValue = unit && typeof value === 'number' ? `${value}${unit}` : value;
              return `var(--${varName}, ${formattedValue})`;
            }
            return unit && typeof value === 'number' ? `${value}${unit}` : value;
          };

          // Use only the last path segment as class name, convert to kebab-case for CSS
          let className = nameTransformers.kebab(token.path[token.path.length - 1]);
          // Remove leading dot if present (token names may already include it)
          if (className.startsWith('.')) {
            className = className.substring(1);
          }

          if (token.comment) {
            output += `/* ${token.comment} */\n`;
          }

          // Wrap class selector with data-attribute selector (Strategy A)
          output += `${dataSelector} .${className} {\n`;
          if (style.fontFamily) output += `  font-family: ${getValueWithAlias('fontFamily', style.fontFamily)};\n`;
          if (style.fontWeight) output += `  font-weight: ${getValueWithAlias('fontWeight', style.fontWeight)};\n`;
          if (style.fontSize) output += `  font-size: ${getValueWithAlias('fontSize', style.fontSize, 'px')};\n`;
          if (style.lineHeight) output += `  line-height: ${getValueWithAlias('lineHeight', style.lineHeight, 'px')};\n`;
          if (style.letterSpacing) output += `  letter-spacing: ${getValueWithAlias('letterSpacing', style.letterSpacing, 'px')};\n`;
          if (style.fontStyle && style.fontStyle !== 'null') output += `  font-style: ${style.fontStyle.toLowerCase()};\n`;
          if (style.textCase && style.textCase !== 'ORIGINAL') {
            output += `  text-transform: ${mapTextCase(style.textCase)};\n`;
          }
          if (style.textDecoration && style.textDecoration !== 'NONE') {
            output += `  text-decoration: ${style.textDecoration.toLowerCase()};\n`;
          }
          output += `}\n\n`;
        }
      });
    });
  });

  return output;
};

/**
 * Format: CSS Effect Classes
 * Generiert fertige CSS-Klassen für Effect Composite Tokens
 */
const cssEffectClassesFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;

  let output = generateFileHeader({
    fileName: `effects-${colorMode}.css`,
    commentStyle: 'block',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  // Build data-attribute selector for Strategy A (full brand + theme scoping)
  const brandLowercase = brand.toLowerCase();
  const dataSelector = `[data-brand="${brandLowercase}"][data-theme="${colorMode}"]`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `/* ============================================\n`;
    output += `   ${topLevel.toUpperCase()}\n`;
    output += `   ============================================ */\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `/* ${topLevel} - ${subLevel} */\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const aliases = token.$aliases || [];

          // Use only the last path segment as class name, convert to kebab-case for CSS
          let className = nameTransformers.kebab(token.path[token.path.length - 1]);
          // Remove leading dot if present (token names may already include it)
          if (className.startsWith('.')) {
            className = className.substring(1);
          }

          if (token.comment) {
            output += `/* ${token.comment} */\n`;
          }

          // Wrap class selector with data-attribute selector (Strategy A)
          output += `${dataSelector} .${className} {\n`;

          // Convert to CSS box-shadow with var() references for colors
          const shadows = token.$value.map((effect, index) => {
            if (effect.type === 'dropShadow') {
              // Check if there's an alias for this effect's color
              const aliasEntry = aliases.find(a => a.index === index);
              let colorValue = effect.color;

              if (aliasEntry?.color?.token) {
                const varName = nameTransformers.kebab(aliasEntry.color.token);
                colorValue = `var(--${varName}, ${effect.color})`;
              }

              return `${effect.offsetX}px ${effect.offsetY}px ${effect.radius}px ${effect.spread}px ${colorValue}`;
            }
            return null;
          }).filter(Boolean);

          if (shadows.length > 0) {
            output += `  box-shadow: ${shadows.join(', ')};\n`;
          }

          output += `}\n\n`;
        }
      });
    });
  });

  return output;
};

/**
 * Format: iOS Swift Typography Extension
 */
const iosSwiftTypographyFormat = ({ dictionary, options }) => {
  const { brand, breakpoint, sizeClass } = options;
  const className = `Typography${brand}${sizeClass || breakpoint}`;

  let output = generateFileHeader({
    fileName: `typography-${sizeClass || breakpoint}.swift`,
    commentStyle: 'line',
    brand: brand,
    context: `SizeClass: ${sizeClass || breakpoint}`
  });

  output += `import UIKit\n\n`;
  output += `extension UIFont {\n`;
  output += `    struct ${className} {\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `        // MARK: - ============================================\n`;
    output += `        // MARK: - ${topLevel.toUpperCase()}\n`;
    output += `        // MARK: - ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `        // MARK: - ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const style = token.$value;
          // Use only the last path segment as property name, transformed to camelCase
          const rawName = token.path[token.path.length - 1];
          const propName = nameTransformers.camel(rawName);

          if (token.comment) {
            output += `        /** ${token.comment} */\n`;
          }

          const family = style.fontFamily || 'System';
          const size = parseFloat(style.fontSize) || 16;
          const weight = style.fontWeight || 400;

          // Map weight to UIFont.Weight
          let weightString = 'regular';
          if (weight >= 900) weightString = 'black';
          else if (weight >= 800) weightString = 'heavy';
          else if (weight >= 700) weightString = 'bold';
          else if (weight >= 600) weightString = 'semibold';
          else if (weight >= 500) weightString = 'medium';
          else if (weight >= 300) weightString = 'light';
          else if (weight >= 200) weightString = 'ultraLight';
          else if (weight >= 100) weightString = 'thin';

          output += `        static let ${propName} = UIFont(name: "${family}", size: ${size})?.withWeight(.${weightString}) ?? UIFont.systemFont(ofSize: ${size}, weight: .${weightString})\n`;
        }
      });
    });
  });

  output += `    }\n`;
  output += `}\n`;

  return output;
};

/**
 * Format: iOS Swift Effects
 * Exports shadow tokens as properly formatted Swift code
 */
const iosSwiftEffectsFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;
  const className = `Effects${brand}${colorMode.charAt(0).toUpperCase() + colorMode.slice(1)}`;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: `effects-${colorMode}.swift`,
    commentStyle: 'line',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  output += `import UIKit\n\n`;
  output += `public class ${className} {\n`;

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    output += `    // MARK: - ============================================\n`;
    output += `    // MARK: - ${topLevel.toUpperCase()}\n`;
    output += `    // MARK: - ============================================\n\n`;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `    // MARK: - ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const uniqueName = uniqueNames.get(token.path.join('.'));

          if (token.comment) {
            output += `    /** ${token.comment} */\n`;
          }

          // Convert shadow array to NSShadow array
          const shadowsSwift = token.$value.map(effect => {
            if (effect.type === 'dropShadow') {
              // Parse color
              let colorValue = 'UIColor.black';
              if (effect.color) {
                const colorStr = effect.color.replace(/\s/g, '');
                if (colorStr.startsWith('rgba')) {
                  const match = colorStr.match(/rgba?\((\d+),(\d+),(\d+),?([\d.]*)\)/);
                  if (match) {
                    const r = (parseInt(match[1]) / 255).toFixed(3);
                    const g = (parseInt(match[2]) / 255).toFixed(3);
                    const b = (parseInt(match[3]) / 255).toFixed(3);
                    const a = match[4] || '1';
                    colorValue = `UIColor(red: ${r}, green: ${g}, blue: ${b}, alpha: ${a})`;
                  }
                }
              }

              return `NSShadow(offset: CGSize(width: ${effect.offsetX || 0}, height: ${effect.offsetY || 0}), blurRadius: ${effect.radius || 0}, color: ${colorValue})`;
            }
            return null;
          }).filter(Boolean);

          output += `    public static let ${uniqueName}: [NSShadow] = [${shadowsSwift.join(', ')}]\n`;
        }
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

/**
 * Format: JavaScript/TypeScript Effects
 * Exports shadow tokens as properly formatted objects
 */
const javascriptEffectsFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: `effects-${colorMode}.js`,
    commentStyle: 'block',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const uniqueName = uniqueNames.get(token.path.join('.'));

          if (token.comment) {
            output += `/** ${token.comment} */\n`;
          }

          // Convert shadow array to JS object array
          const shadowsJS = token.$value.map(effect => {
            if (effect.type === 'dropShadow') {
              return `{
    offsetX: ${effect.offsetX || 0},
    offsetY: ${effect.offsetY || 0},
    radius: ${effect.radius || 0},
    spread: ${effect.spread || 0},
    color: "${effect.color || 'rgba(0, 0, 0, 0)'}"
  }`;
            }
            return null;
          }).filter(Boolean);

          output += `export const ${uniqueName} = [\n  ${shadowsJS.join(',\n  ')}\n];\n`;
        }
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * Format: JavaScript/TypeScript Typography
 * Exports typography tokens as properly formatted objects
 */
const javascriptTypographyFormat = ({ dictionary, options }) => {
  const { brand, breakpoint } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = generateFileHeader({
    fileName: `typography-${breakpoint}.js`,
    commentStyle: 'block',
    brand: brand,
    context: `Breakpoint: ${breakpoint}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const style = token.$value;

          if (token.comment) {
            output += `/** ${token.comment} */\n`;
          }

          output += `export const ${uniqueName} = {\n`;
          if (style.fontFamily) output += `  fontFamily: "${style.fontFamily}",\n`;
          if (style.fontWeight) output += `  fontWeight: ${style.fontWeight},\n`;
          if (style.fontSize) output += `  fontSize: "${typeof style.fontSize === 'number' ? style.fontSize + 'px' : style.fontSize}",\n`;
          if (style.lineHeight) output += `  lineHeight: "${typeof style.lineHeight === 'number' ? style.lineHeight + 'px' : style.lineHeight}",\n`;
          if (style.letterSpacing) output += `  letterSpacing: "${typeof style.letterSpacing === 'number' ? style.letterSpacing + 'px' : style.letterSpacing}",\n`;
          if (style.fontStyle && style.fontStyle !== 'null') output += `  fontStyle: "${style.fontStyle.toLowerCase()}",\n`;
          if (style.textCase && style.textCase !== 'ORIGINAL') output += `  textTransform: "${mapTextCase(style.textCase)}",\n`;
          if (style.textDecoration && style.textDecoration !== 'NONE') output += `  textDecoration: "${style.textDecoration.toLowerCase()}",\n`;
          output += `};\n`;
        }
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * Helper: Map Figma textCase to CSS text-transform value
 * Figma exports: UPPER, LOWER, TITLE, ORIGINAL
 * CSS expects: uppercase, lowercase, capitalize, none
 */
function mapTextCase(figmaTextCase) {
  const mapping = {
    'UPPER': 'uppercase',
    'LOWER': 'lowercase',
    'TITLE': 'capitalize',
    'SMALL_CAPS': 'small-caps',
    'SMALL_CAPS_FORCED': 'small-caps'
  };
  return mapping[figmaTextCase] || figmaTextCase.toLowerCase();
}

/**
 * SCSS Effects Format - Outputs shadow tokens as SCSS maps
 */
const scssEffectsFormat = ({ dictionary, options }) => {
  const { brand, colorMode } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: `effects-${colorMode}.scss`,
    commentStyle: 'line',
    brand: brand,
    context: `Mode: ${colorMode}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'shadow' && Array.isArray(token.$value)) {
          const uniqueName = uniqueNames.get(token.path.join('.'));

          if (token.comment) {
            output += `/** ${token.comment} */\n`;
          }

          // Convert shadow array to SCSS map array with kebab-case keys
          const shadowsSCSS = token.$value.map((effect, idx) => {
            if (effect.type === 'dropShadow') {
              return `  ${idx + 1}: (\n    offset-x: ${effect.offsetX || 0}px,\n    offset-y: ${effect.offsetY || 0}px,\n    blur-radius: ${effect.radius || 0}px,\n    spread-radius: ${effect.spread || 0}px,\n    color: ${effect.color || 'rgba(0, 0, 0, 0)'}\n  )`;
            }
            return null;
          }).filter(Boolean);

          output += `$${uniqueName}: (\n${shadowsSCSS.join(',\n')}\n);\n`;
        }
      });

      output += `\n`;
    });
  });

  return output;
};

/**
 * SCSS Typography Format - Outputs typography tokens as SCSS maps
 */
const scssTypographyFormat = ({ dictionary, options }) => {
  const { brand, breakpoint } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: `typography-${breakpoint}.scss`,
    commentStyle: 'line',
    brand: brand,
    context: `Breakpoint: ${breakpoint}`
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `// ============================================\n`;
    output += `// ${topLevel.toUpperCase()}\n`;
    output += `// ============================================\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `// ${topLevel} - ${subLevel}\n`;
      }

      tokens.forEach(token => {
        if (token.$type === 'typography' && token.$value) {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const style = token.$value;

          if (token.comment) {
            output += `/** ${token.comment} */\n`;
          }

          output += `$${uniqueName}: (\n`;
          // Use kebab-case for SCSS map keys (CSS property naming convention)
          if (style.fontFamily) output += `  font-family: ${style.fontFamily},\n`;
          if (style.fontWeight) output += `  font-weight: ${style.fontWeight},\n`;
          if (style.fontSize) output += `  font-size: ${typeof style.fontSize === 'number' ? style.fontSize + 'px' : style.fontSize},\n`;
          if (style.lineHeight) output += `  line-height: ${typeof style.lineHeight === 'number' ? style.lineHeight + 'px' : style.lineHeight},\n`;
          if (style.letterSpacing) output += `  letter-spacing: ${typeof style.letterSpacing === 'number' ? style.letterSpacing + 'px' : style.letterSpacing},\n`;
          if (style.fontStyle && style.fontStyle !== 'null') output += `  font-style: ${style.fontStyle.toLowerCase()},\n`;
          if (style.textCase && style.textCase !== 'ORIGINAL') output += `  text-transform: ${mapTextCase(style.textCase)},\n`;
          if (style.textDecoration && style.textDecoration !== 'NONE') output += `  text-decoration: ${style.textDecoration.toLowerCase()},\n`;
          output += `);\n`;
        }
      });

      output += `\n`;
    });
  });

  return output;
};

// ============================================================================
// TRANSFORM GROUPS
// ============================================================================

/**
 * Custom Transform Groups that use our shortened token names
 * IMPORTANT: We do NOT use 'attribute/cti' or 'name/cti/*', as these
 * use the full path. Instead, we only use our custom name transforms.
 *
 * NOTE: 'value/round' is placed LAST in each group to round values
 * AFTER all other transforms (color conversion, size conversion, etc.)
 */
const customTransformGroups = {
  'custom/css': ['name/custom/kebab', 'color/css', 'custom/size/px', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/scss': ['name/custom/kebab', 'color/css', 'custom/size/px', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/js': ['name/custom/js', 'color/css', 'custom/size/px', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/ios-swift': ['name/custom/ios-swift', 'custom/color/UIColor', 'custom/size/ios-points', 'custom/opacity', 'custom/fontWeight', 'custom/number', 'value/round'],
  'custom/compose': ['name/custom/compose', 'color/custom/compose', 'size/custom/compose', 'custom/opacity', 'custom/fontWeight', 'custom/number']
};

// ============================================================================
// THEMED CSS FORMAT - Data-Attribute Based Theme Switching
// ============================================================================

/**
 * Format: CSS Themed Variables with Data-Attributes
 * Generates CSS with [data-brand] and [data-theme/data-breakpoint] selectors
 * for runtime theme switching without file swapping.
 *
 * Options:
 * - brand: Brand name (e.g., 'bild', 'sportbild')
 * - mode: Color mode, breakpoint, or density (e.g., 'light', 'dark', 'xs', 'dense')
 * - modeType: Type of mode ('theme', 'breakpoint', 'density')
 * - includeRoot: Whether to include default :root fallback (default: false)
 */
const cssThemedVariablesFormat = ({ dictionary, options, file }) => {
  const { brand, mode, modeType = 'theme', includeRoot = false } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: brand ? brand.charAt(0).toUpperCase() + brand.slice(1) : 'All Brands',
    context: modeType && mode ? `${modeType}: ${mode}` : 'All Modes'
  });

  // Build selector based on brand and mode
  let selector;
  if (brand && mode) {
    // Specific brand + mode combination
    const dataMode = modeType === 'theme' ? 'data-theme' :
                     modeType === 'breakpoint' ? 'data-breakpoint' :
                     modeType === 'density' ? 'data-density' : 'data-mode';
    selector = `[data-brand="${brand}"][${dataMode}="${mode}"]`;
  } else if (brand) {
    // Brand only
    selector = `[data-brand="${brand}"]`;
  } else if (mode) {
    // Mode only
    const dataMode = modeType === 'theme' ? 'data-theme' :
                     modeType === 'breakpoint' ? 'data-breakpoint' :
                     modeType === 'density' ? 'data-density' : 'data-mode';
    selector = `[${dataMode}="${mode}"]`;
  } else {
    // Fallback to root if no brand/mode specified
    selector = ':root';
  }

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  // Optional: Include :root fallback for default values
  if (includeRoot) {
    output += `:root {\n`;
    output += `  /* Default values (will be overridden by data-attributes) */\n`;

    Object.keys(hierarchicalGroups).forEach(topLevel => {
      const subGroups = hierarchicalGroups[topLevel];
      Object.keys(subGroups).forEach(subLevel => {
        const tokens = subGroups[subLevel];
        tokens.forEach(token => {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const finalValue = token.$value !== undefined ? token.$value : token.value;
          output += `  --${uniqueName}: ${finalValue};\n`;
        });
      });
    });

    output += `}\n\n`;
  }

  // Main themed selector
  output += `${selector} {\n`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `  /* ============================================\n`;
    output += `     ${topLevel.toUpperCase()}\n`;
    output += `     ============================================ */\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `  /* ${topLevel} - ${subLevel} */\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment) {
          output += `  /**\n   * ${comment}\n   */\n`;
        }
        const finalValue = token.$value !== undefined ? token.$value : token.value;
        output += `  --${uniqueName}: ${finalValue};\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

// ============================================================================
// CSS FORMAT WITH ALIAS REFERENCES (var() pattern)
// ============================================================================

/**
 * Converts alias token name to CSS variable name
 * Uses kebab-case transformation
 * @param {string} tokenName - Token name from alias
 * @returns {string} - CSS variable name (without --)
 */
function aliasToVarName(tokenName) {
  if (!tokenName) return null;
  return nameTransformers.kebab(tokenName);
}

/**
 * Format: CSS Variables with Alias References
 * Generates CSS with var(--reference, fallback) pattern for tokens with $alias
 * Other platforms ignore $alias and use resolved values
 *
 * For simple tokens: Uses $alias field
 * For combined tokens (typography/effects): Uses $aliases object/array
 */
const cssVariablesWithAliasFormat = ({ dictionary, options, file }) => {
  const selector = options.selector || ':root';
  const context = getContextString(options);
  const { outputReferences = true } = options;

  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: options.brand,
    context: context
  });

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  output += `${selector} {\n`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    // Add top-level header
    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `  /* ============================================\n`;
    output += `     ${topLevel.toUpperCase()}\n`;
    output += `     ============================================ */\n\n`;
    isFirstTopLevel = false;

    // Sort sub-level keys
    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      // Add sub-level header if exists
      if (subLevel) {
        output += `  /* ${topLevel} - ${subLevel} */\n`;
      }

      // Add tokens
      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment && options.showDescriptions !== false) {
          output += `  /**\n   * ${comment}\n   */\n`;
        }

        // Use $value (transformed) or fallback to value (original)
        const finalValue = token.$value !== undefined ? token.$value : token.value;

        // Check for $alias (simple tokens) and generate var() reference
        // Skip self-references (when token name equals alias name, e.g., breakpoint → density with same name)
        if (outputReferences && token.$alias && token.$alias.token) {
          const refName = aliasToVarName(token.$alias.token);
          if (refName && refName !== uniqueName) {
            output += `  --${uniqueName}: var(--${refName}, ${finalValue});\n`;
            return;
          }
        }

        // No alias or outputReferences disabled → direct value
        output += `  --${uniqueName}: ${finalValue};\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

/**
 * Format: CSS Themed Variables with Alias References
 * Combines themed data-attribute selectors with var() references
 */
const cssThemedVariablesWithAliasFormat = ({ dictionary, options, file }) => {
  const { brand, mode, modeType = 'theme', includeRoot = false, outputReferences = true } = options;
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'kebab');

  let output = generateFileHeader({
    fileName: file.destination,
    commentStyle: 'block',
    brand: brand ? brand.charAt(0).toUpperCase() + brand.slice(1) : 'All Brands',
    context: modeType && mode ? `${modeType}: ${mode}` : 'All Modes'
  });

  // Build selector based on brand and mode
  let selector;
  if (brand && mode) {
    const dataMode = modeType === 'theme' ? 'data-theme' :
                     modeType === 'breakpoint' ? 'data-breakpoint' :
                     modeType === 'density' ? 'data-density' : 'data-mode';
    selector = `[data-brand="${brand}"][${dataMode}="${mode}"]`;
  } else if (brand) {
    selector = `[data-brand="${brand}"]`;
  } else if (mode) {
    const dataMode = modeType === 'theme' ? 'data-theme' :
                     modeType === 'breakpoint' ? 'data-breakpoint' :
                     modeType === 'density' ? 'data-density' : 'data-mode';
    selector = `[${dataMode}="${mode}"]`;
  } else {
    selector = ':root';
  }

  const hierarchicalGroups = groupTokensHierarchically(dictionary.allTokens);

  // Optional: Include :root fallback for default values
  if (includeRoot) {
    output += `:root {\n`;
    output += `  /* Default values (will be overridden by data-attributes) */\n`;

    Object.keys(hierarchicalGroups).forEach(topLevel => {
      const subGroups = hierarchicalGroups[topLevel];
      Object.keys(subGroups).forEach(subLevel => {
        const tokens = subGroups[subLevel];
        tokens.forEach(token => {
          const uniqueName = uniqueNames.get(token.path.join('.'));
          const finalValue = token.$value !== undefined ? token.$value : token.value;
          output += `  --${uniqueName}: ${finalValue};\n`;
        });
      });
    });

    output += `}\n\n`;
  }

  // Main themed selector
  output += `${selector} {\n`;

  let isFirstTopLevel = true;
  Object.keys(hierarchicalGroups).forEach(topLevel => {
    const subGroups = hierarchicalGroups[topLevel];

    if (!isFirstTopLevel) {
      output += `\n`;
    }
    output += `  /* ============================================\n`;
    output += `     ${topLevel.toUpperCase()}\n`;
    output += `     ============================================ */\n\n`;
    isFirstTopLevel = false;

    Object.keys(subGroups).forEach(subLevel => {
      const tokens = subGroups[subLevel];

      if (subLevel) {
        output += `  /* ${topLevel} - ${subLevel} */\n`;
      }

      tokens.forEach(token => {
        const uniqueName = uniqueNames.get(token.path.join('.'));
        const comment = token.comment || token.description;
        if (comment && options.showDescriptions !== false) {
          output += `  /**\n   * ${comment}\n   */\n`;
        }

        const finalValue = token.$value !== undefined ? token.$value : token.value;

        // Check for $alias and generate var() reference
        // Skip self-references (when token name equals alias name, e.g., breakpoint → density with same name)
        if (outputReferences && token.$alias && token.$alias.token) {
          const refName = aliasToVarName(token.$alias.token);
          if (refName && refName !== uniqueName) {
            // Semantic references: var(--semantic-token) WITHOUT fallback
            // The semantic layer already provides the mode-specific value
            if (isSemanticReference(token)) {
              output += `  --${uniqueName}: var(--${refName});\n`;
            } else {
              // Non-semantic references: var(--primitive, fallback) as before
              output += `  --${uniqueName}: var(--${refName}, ${finalValue});\n`;
            }
            return;
          }
        }

        output += `  --${uniqueName}: ${finalValue};\n`;
      });

      output += `\n`;
    });
  });

  output += `}\n`;
  return output;
};

// ============================================================================
// JETPACK COMPOSE FORMATS
// ============================================================================

/**
 * Helper: Convert brand name to PascalCase for Kotlin class names
 */
function brandToPascalCase(brand) {
  if (brand === 'sportbild') return 'Sportbild';
  if (brand === 'advertorial') return 'Advertorial';
  return brand.charAt(0).toUpperCase() + brand.slice(1);
}

/**
 * Format: Jetpack Compose Primitives Object
 * Generates a Kotlin object with internal val declarations for primitive tokens
 *
 * Output example:
 * object ColorPrimitives {
 *     internal val BildRed = Color(0xFFDD0000)
 *     internal val Bild015 = Color(0xFF232629)
 * }
 */
/**
 * Helper: Transform a color value to Compose Color format
 */
function toComposeColor(value) {
  if (!value) return value;

  // Already in Compose format
  if (typeof value === 'string' && value.startsWith('Color(')) {
    return value;
  }

  // Handle hex colors: #RRGGBB or #AARRGGBB
  if (typeof value === 'string' && value.startsWith('#')) {
    let hex = value.replace('#', '').toUpperCase();
    if (hex.length === 6) {
      hex = 'FF' + hex;
    }
    return `Color(0x${hex})`;
  }

  // Handle rgba: rgba(r, g, b, a)
  if (typeof value === 'string' && value.startsWith('rgba')) {
    const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*([\d.]*)\)/);
    if (match) {
      const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
      const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
      const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
      const a = match[4] ? Math.round(parseFloat(match[4]) * 255).toString(16).padStart(2, '0').toUpperCase() : 'FF';
      return `Color(0x${a}${r}${g}${b})`;
    }
  }

  // Handle rgb: rgb(r, g, b)
  if (typeof value === 'string' && value.startsWith('rgb(')) {
    const match = value.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (match) {
      const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
      const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
      const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
      return `Color(0xFF${r}${g}${b})`;
    }
  }

  return value;
}

/**
 * Helper: Transform a size value to Compose Dp format
 */
function toComposeDp(value) {
  // Handle null/undefined
  if (value === null || value === undefined) return value;

  // Already in Compose format
  if (typeof value === 'string' && (value.endsWith('.dp') || value.endsWith('.sp'))) {
    return value;
  }

  // Handle number (including 0)
  if (typeof value === 'number') {
    return `${value}.dp`;
  }

  // Handle string with px
  if (typeof value === 'string') {
    const num = parseFloat(value.replace('px', ''));
    if (!isNaN(num)) {
      return `${num}.dp`;
    }
  }

  return value;
}

/**
 * Helper: Transform a font size value to Compose Sp format
 */
function toComposeSp(value) {
  // Handle null/undefined
  if (value === null || value === undefined) return value;

  // Already in Compose format
  if (typeof value === 'string' && value.endsWith('.sp')) {
    return value;
  }

  // Handle number (including 0)
  if (typeof value === 'number') {
    return `${value}.sp`;
  }

  // Handle string with px
  if (typeof value === 'string') {
    const num = parseFloat(value.replace('px', ''));
    if (!isNaN(num)) {
      return `${num}.sp`;
    }
  }

  return value;
}

// ============================================================================
// SWIFTUI HELPER FUNCTIONS
// ============================================================================

/**
 * Helper: Transform a color value to SwiftUI Color format
 * Output: Color(hex: 0xRRGGBB) or Color(hex: 0xRRGGBB, alpha: 0.5)
 */
function toSwiftUIColor(value) {
  if (!value) return value;

  // Already in SwiftUI format
  if (typeof value === 'string' && value.startsWith('Color(')) {
    return value;
  }

  // Handle hex colors: #RRGGBB or #AARRGGBB
  if (typeof value === 'string' && value.startsWith('#')) {
    let hex = value.replace('#', '').toUpperCase();
    if (hex.length === 6) {
      return `Color(hex: 0x${hex})`;
    } else if (hex.length === 8) {
      // #AARRGGBB format
      const alpha = parseInt(hex.substring(0, 2), 16) / 255;
      const rgb = hex.substring(2);
      return `Color(hex: 0x${rgb}, alpha: ${alpha.toFixed(2)})`;
    }
  }

  // Handle rgba: rgba(r, g, b, a)
  if (typeof value === 'string' && value.startsWith('rgba')) {
    const match = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*([\d.]*)\)/);
    if (match) {
      const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
      const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
      const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
      const a = match[4] ? parseFloat(match[4]) : 1.0;
      if (a === 1.0) {
        return `Color(hex: 0x${r}${g}${b})`;
      }
      return `Color(hex: 0x${r}${g}${b}, alpha: ${a.toFixed(2)})`;
    }
  }

  // Handle rgb: rgb(r, g, b)
  if (typeof value === 'string' && value.startsWith('rgb(')) {
    const match = value.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (match) {
      const r = parseInt(match[1]).toString(16).padStart(2, '0').toUpperCase();
      const g = parseInt(match[2]).toString(16).padStart(2, '0').toUpperCase();
      const b = parseInt(match[3]).toString(16).padStart(2, '0').toUpperCase();
      return `Color(hex: 0x${r}${g}${b})`;
    }
  }

  // Handle UIColor format: UIColor(red: 0.867, green: 0, blue: 0, alpha: 1)
  if (typeof value === 'string' && value.startsWith('UIColor(')) {
    const match = value.match(/UIColor\(red:\s*([\d.]+),\s*green:\s*([\d.]+),\s*blue:\s*([\d.]+),\s*alpha:\s*([\d.]+)\)/);
    if (match) {
      const r = Math.round(parseFloat(match[1]) * 255).toString(16).padStart(2, '0').toUpperCase();
      const g = Math.round(parseFloat(match[2]) * 255).toString(16).padStart(2, '0').toUpperCase();
      const b = Math.round(parseFloat(match[3]) * 255).toString(16).padStart(2, '0').toUpperCase();
      const a = parseFloat(match[4]);
      if (a === 1.0 || a === 1) {
        return `Color(hex: 0x${r}${g}${b})`;
      }
      return `Color(hex: 0x${r}${g}${b}, alpha: ${a.toFixed(2)})`;
    }
  }

  return value;
}

/**
 * Helper: Transform a size value to SwiftUI CGFloat (number only, no unit)
 */
function toSwiftUICGFloat(value) {
  if (value === null || value === undefined) return value;

  // Handle number
  if (typeof value === 'number') {
    return value;
  }

  // Handle string with px
  if (typeof value === 'string') {
    const num = parseFloat(value.replace('px', ''));
    if (!isNaN(num)) {
      return num;
    }
  }

  return value;
}

/**
 * Helper: Transform font weight to SwiftUI Font.Weight
 */
function toSwiftUIFontWeight(value) {
  const weightMap = {
    100: '.ultraLight',
    200: '.thin',
    300: '.light',
    350: '.light',
    400: '.regular',
    500: '.medium',
    600: '.semibold',
    700: '.bold',
    800: '.heavy',
    900: '.black',
    1000: '.black'
  };

  const numValue = typeof value === 'string' ? parseInt(value) : value;
  return weightMap[numValue] || '.regular';
}

/**
 * Helper: Get Swift type and formatted value from token's $type
 * Uses the source $type to determine the correct Swift type (per-token type detection)
 *
 * @param {Object} token - The token object with $type, $value, etc.
 * @returns {{ swiftType: string, formattedValue: string }}
 */
function getSwiftTypeAndValue(token) {
  const tokenType = token.$type || token.type;
  const value = token.$value !== undefined ? token.$value : token.value;

  switch (tokenType) {
    case 'color':
      return {
        swiftType: 'Color',
        formattedValue: toSwiftUIColor(value)
      };

    case 'dimension':
    case 'fontSize':
    case 'lineHeight':
    case 'letterSpacing':
    case 'number':
      return {
        swiftType: 'CGFloat',
        formattedValue: toSwiftUICGFloat(value)
      };

    case 'fontWeight':
      return {
        swiftType: 'Font.Weight',
        formattedValue: toSwiftUIFontWeight(value)
      };

    case 'fontFamily':
    case 'string':
      return {
        swiftType: 'String',
        formattedValue: `"${value}"`
      };

    case 'opacity':
      // Opacity as CGFloat (0.0 - 1.0)
      const opacityValue = typeof value === 'number' && value > 1 ? value / 100 : value;
      return {
        swiftType: 'CGFloat',
        formattedValue: opacityValue
      };

    case 'boolean':
      return {
        swiftType: 'Bool',
        formattedValue: value === true || value === 'true' ? 'true' : 'false'
      };

    default:
      // Default to CGFloat for unknown numeric types
      if (typeof value === 'number') {
        return {
          swiftType: 'CGFloat',
          formattedValue: toSwiftUICGFloat(value)
        };
      }
      // Default to String for unknown string types
      if (typeof value === 'string' && isNaN(parseFloat(value))) {
        return {
          swiftType: 'String',
          formattedValue: `"${value}"`
        };
      }
      return {
        swiftType: 'CGFloat',
        formattedValue: toSwiftUICGFloat(value)
      };
  }
}

/**
 * Complete Token Type Mapping for iOS (Swift/SwiftUI)
 *
 * Token $type values from Figma → Swift types:
 * ─────────────────────────────────────────────────────────────────
 * $type          | Swift Type   | Format Example
 * ─────────────────────────────────────────────────────────────────
 * dimension      | CGFloat      | 24 (no unit, raw number)
 * fontSize       | CGFloat      | 16 (no unit for sizing tokens)
 * lineHeight     | CGFloat      | 24 (no unit)
 * letterSpacing  | CGFloat      | -0.5
 * fontWeight     | CGFloat      | 700 (numeric)
 * fontFamily     | String       | "Gotham XNarrow"
 * string         | String       | "xs/sm/md"
 * boolean        | Bool         | true/false
 * opacity        | Int          | 50 (0-100 percentage)
 * number         | CGFloat      | 4.5
 * color          | Color        | Color(hex: 0xDD0000)
 * shadow         | ShadowStyle  | (composite type)
 * typography     | TextStyle    | (composite type)
 * ─────────────────────────────────────────────────────────────────
 */

/**
 * Helper: Determine Swift type from token $type or type attribute
 * Returns { swiftType, isString, isBool, isInt }
 */
function getSwiftTypeInfo(token) {
  const tokenType = token.$type || token.type;
  const name = token.name || '';
  const value = token.$value !== undefined ? token.$value : token.value;

  // ═══════════════════════════════════════════════════════════════
  // STRING TYPES
  // ═══════════════════════════════════════════════════════════════

  // Explicit string types from Figma
  if (tokenType === 'fontFamily' || tokenType === 'string') {
    return { swiftType: 'String', isString: true, isBool: false, isInt: false };
  }

  // Token name patterns that indicate string values
  const stringNamePatterns = [
    'fontfamily',
    'breakpointname',
    'bpspecific',
    'changeon',
    'textcase',
    'textdecoration'
  ];

  const lowerName = name.toLowerCase();
  if (stringNamePatterns.some(pattern => lowerName.includes(pattern))) {
    // Verify value is actually a string (not a number)
    if (typeof value === 'string' && isNaN(parseFloat(value))) {
      return { swiftType: 'String', isString: true, isBool: false, isInt: false };
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // BOOLEAN TYPES
  // ═══════════════════════════════════════════════════════════════

  if (tokenType === 'boolean') {
    return { swiftType: 'Bool', isString: false, isBool: true, isInt: false };
  }

  // Check if value is actually a boolean
  if (typeof value === 'boolean') {
    return { swiftType: 'Bool', isString: false, isBool: true, isInt: false };
  }

  // ═══════════════════════════════════════════════════════════════
  // INTEGER TYPES (opacity is 0-100 percentage)
  // ═══════════════════════════════════════════════════════════════

  if (tokenType === 'opacity') {
    return { swiftType: 'Int', isString: false, isBool: false, isInt: true };
  }

  // ═══════════════════════════════════════════════════════════════
  // NUMERIC TYPES (CGFloat) - Default for sizing tokens
  // dimension, fontSize, lineHeight, letterSpacing, fontWeight, number
  // ═══════════════════════════════════════════════════════════════

  return { swiftType: 'CGFloat', isString: false, isBool: false, isInt: false };
}

/**
 * Helper: Format value for Swift based on type info
 */
function formatSwiftValue(value, typeInfo) {
  // String type - wrap in quotes
  if (typeInfo.isString) {
    const strValue = String(value);
    return `"${strValue}"`;
  }

  // Boolean type
  if (typeInfo.isBool) {
    return value === true || value === 'true' ? 'true' : 'false';
  }

  // Integer type (opacity)
  if (typeInfo.isInt) {
    return Math.round(Number(value));
  }

  // Numeric CGFloat value
  return toSwiftUICGFloat(value);
}

/**
 * Helper: Convert camelCase to PascalCase
 */
function toPascalCase(str) {
  if (!str) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Helper: Convert name to valid Swift identifier
 */
function toSwiftIdentifier(name) {
  // Handle names starting with numbers
  if (/^\d/.test(name)) {
    return `n${name}`;
  }
  // Handle Swift reserved keywords
  const reserved = ['default', 'class', 'struct', 'enum', 'protocol', 'extension', 'import', 'let', 'var', 'func', 'return', 'if', 'else', 'switch', 'case', 'break', 'continue', 'for', 'while', 'repeat', 'in', 'where', 'guard', 'defer', 'do', 'catch', 'throw', 'throws', 'try', 'as', 'is', 'nil', 'true', 'false', 'self', 'Self', 'super', 'init', 'deinit', 'subscript', 'typealias', 'associatedtype', 'static', 'public', 'private', 'fileprivate', 'internal', 'open', 'final', 'override', 'mutating', 'nonmutating', 'lazy', 'weak', 'unowned', 'inout', 'some', 'any', 'Type', 'Protocol'];
  if (reserved.includes(name)) {
    return `\`${name}\``;
  }
  return name;
}

// ============================================================================
// SWIFTUI FORMAT FUNCTIONS
// ============================================================================

/**
 * Format: SwiftUI Shared Enums (Density, SizeClass, Brand)
 */
const swiftuiEnumsFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;

  let output = `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import Foundation

/// UI density modes for the BILD Design System
public enum Density: String, CaseIterable, Sendable {
    case dense
    case \`default\`
    case spacious
}

/// Size class for responsive layouts
/// Maps to iOS UITraitCollection.horizontalSizeClass
public enum SizeClass: String, CaseIterable, Sendable {
    case compact   // Phones (Portrait), small screens - maps to xs/sm breakpoints
    case regular   // Tablets, Phones (Landscape) - maps to md/lg breakpoints
}

/// Available brands in the BILD Design System
public enum Brand: String, CaseIterable, Sendable {
    case bild
    case sportbild
    case advertorial
}
`;

  return output;
};

/**
 * Format: SwiftUI TextStyle struct
 */
const swiftuiTextStyleFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;

  return `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

/// Composite typography token representing a complete text style
public struct TextStyle: Equatable, Sendable {
    public let fontFamily: String
    public let fontWeight: Font.Weight
    public let fontSize: CGFloat
    public let lineHeight: CGFloat
    public let letterSpacing: CGFloat
    public let textCase: TextCase
    public let textDecoration: TextDecoration

    public init(
        fontFamily: String,
        fontWeight: Font.Weight,
        fontSize: CGFloat,
        lineHeight: CGFloat,
        letterSpacing: CGFloat,
        textCase: TextCase = .original,
        textDecoration: TextDecoration = .none
    ) {
        self.fontFamily = fontFamily
        self.fontWeight = fontWeight
        self.fontSize = fontSize
        self.lineHeight = lineHeight
        self.letterSpacing = letterSpacing
        self.textCase = textCase
        self.textDecoration = textDecoration
    }

    public enum TextCase: String, Sendable {
        case original = "ORIGINAL"
        case upper = "UPPER"
        case lower = "LOWER"
        case capitalize = "CAPITALIZE"

        var swiftUICase: Text.Case? {
            switch self {
            case .original: return nil
            case .upper: return .uppercase
            case .lower: return .lowercase
            case .capitalize: return nil
            }
        }
    }

    public enum TextDecoration: String, Sendable {
        case none = "NONE"
        case underline = "UNDERLINE"
        case strikethrough = "STRIKETHROUGH"
    }

    /// Create a SwiftUI Font from this text style with Dynamic Type support
    public func font(relativeTo textStyle: Font.TextStyle = .body) -> Font {
        Font.custom(fontFamily, size: fontSize, relativeTo: textStyle)
            .weight(fontWeight)
    }

    /// Line spacing value for SwiftUI (lineHeight - fontSize)
    public var lineSpacing: CGFloat {
        max(0, lineHeight - fontSize)
    }
}

/// View modifier for applying TextStyle
public struct TextStyleModifier: ViewModifier {
    let style: TextStyle
    let relativeTo: Font.TextStyle

    public init(_ style: TextStyle, relativeTo: Font.TextStyle = .body) {
        self.style = style
        self.relativeTo = relativeTo
    }

    public func body(content: Content) -> some View {
        content
            .font(style.font(relativeTo: relativeTo))
            .tracking(style.letterSpacing)
            .lineSpacing(style.lineSpacing)
            .textCase(style.textCase.swiftUICase)
    }
}

public extension View {
    func textStyle(_ style: TextStyle, relativeTo: Font.TextStyle = .body) -> some View {
        modifier(TextStyleModifier(style, relativeTo: relativeTo))
    }
}
`;
};

/**
 * Format: SwiftUI Shadow structs
 */
const swiftuiShadowFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;

  return `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

/// Single drop shadow definition
public struct DropShadow: Equatable, Sendable {
    public let color: Color
    public let offsetX: CGFloat
    public let offsetY: CGFloat
    public let radius: CGFloat
    public let spread: CGFloat

    public init(
        color: Color,
        offsetX: CGFloat,
        offsetY: CGFloat,
        radius: CGFloat,
        spread: CGFloat = 0
    ) {
        self.color = color
        self.offsetX = offsetX
        self.offsetY = offsetY
        self.radius = radius
        self.spread = spread
    }
}

/// Composite shadow token (can contain multiple layers)
public struct ShadowStyle: Equatable, Sendable {
    public let shadows: [DropShadow]

    public init(shadows: [DropShadow]) {
        self.shadows = shadows
    }

    public init(_ shadow: DropShadow) {
        self.shadows = [shadow]
    }
}

/// View modifier for applying ShadowStyle (applies all shadow layers)
public struct ShadowStyleModifier: ViewModifier {
    let style: ShadowStyle

    public init(_ style: ShadowStyle) {
        self.style = style
    }

    public func body(content: Content) -> some View {
        style.shadows.reduce(AnyView(content)) { view, shadow in
            AnyView(view.shadow(
                color: shadow.color,
                radius: shadow.radius,
                x: shadow.offsetX,
                y: shadow.offsetY
            ))
        }
    }
}

public extension View {
    func shadowStyle(_ style: ShadowStyle) -> some View {
        modifier(ShadowStyleModifier(style))
    }
}
`;
};

/**
 * Format: SwiftUI Color Extension (hex initializer)
 */
const swiftuiColorExtensionFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;

  return `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

public extension Color {
    /// Initialize Color from hex value
    /// - Parameters:
    ///   - hex: Hex color value (e.g., 0xDD0000)
    ///   - alpha: Optional alpha value (0.0 - 1.0)
    init(hex: UInt, alpha: Double = 1.0) {
        self.init(
            .sRGB,
            red: Double((hex >> 16) & 0xFF) / 255,
            green: Double((hex >> 8) & 0xFF) / 255,
            blue: Double(hex & 0xFF) / 255,
            opacity: alpha
        )
    }
}
`;
};

/**
 * Format: SwiftUI Primitives (consolidated with separate Opacity enum)
 * Best practice: Single file with nested enums for Color, Font, Size, Space
 * Opacity tokens are separated with Double type for proper SwiftUI usage
 */
const swiftuiPrimitivesFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;

  // Helper to detect opacity tokens
  const isOpacityToken = (token) => {
    const tokenType = token.$type || token.type;
    const name = (token.name || '').toLowerCase();
    return tokenType === 'opacity' || name.includes('opacity');
  };

  // Separate opacity tokens from other tokens
  const opacityTokens = dictionary.allTokens.filter(isOpacityToken);
  const nonOpacityTokens = dictionary.allTokens.filter(t => !isOpacityToken(t));

  let output = `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

/// Primitive design tokens - raw values without semantic meaning
/// Organized by category with nested enums following SwiftUI best practices
public enum DesignTokenPrimitives {
`;

  // Group non-opacity tokens by their collection/category
  const grouped = {};
  nonOpacityTokens.forEach(token => {
    const collectionName = token.$extensions?.['com.figma']?.collectionName || 'Other';
    // Normalize category name - remove 'Primitive' suffix and underscores
    let category = collectionName.replace(/_/g, '').replace(/Primitive$/i, '');
    // Ensure Color category stays as Color (not just empty)
    if (category === '' || category.toLowerCase() === 'color') {
      category = 'Color';
    }
    if (!grouped[category]) grouped[category] = [];
    grouped[category].push(token);
  });

  // Process each category (excluding opacity which is handled separately)
  Object.keys(grouped).sort().forEach(category => {
    const tokens = grouped[category];
    const enumName = toPascalCase(category);

    output += `\n    // MARK: - ${enumName}\n`;
    output += `    public enum ${enumName} {\n`;

    // Track used names to avoid duplicates
    const usedNames = new Set();

    tokens.forEach(token => {
      let name = toSwiftIdentifier(token.name);

      // Skip if name already used (deduplication)
      if (usedNames.has(name)) {
        return;
      }
      usedNames.add(name);

      const type = token.$type || token.type;
      const value = token.$value !== undefined ? token.$value : token.value;
      const comment = token.comment || token.description;

      if (comment) {
        output += `        /// ${comment}\n`;
      }

      let valueOutput;
      let typeAnnotation = '';

      if (type === 'color') {
        // Use SwiftUI.Color to avoid collision with enum name
        const colorValue = toSwiftUIColor(value);
        valueOutput = colorValue.replace('Color(', 'SwiftUI.Color(');
        typeAnnotation = ': SwiftUI.Color';
      } else if (type === 'fontFamily') {
        valueOutput = `"${value}"`;
        typeAnnotation = ': String';
      } else if (type === 'fontWeight') {
        valueOutput = toSwiftUIFontWeight(value);
        typeAnnotation = ': SwiftUI.Font.Weight';  // Use full path to avoid collision with Font enum
      } else if (typeof value === 'number') {
        valueOutput = `CGFloat(${value})`;
        typeAnnotation = ': CGFloat';
      } else if (typeof value === 'string' && !isNaN(parseFloat(value))) {
        valueOutput = `CGFloat(${parseFloat(value)})`;
        typeAnnotation = ': CGFloat';
      } else {
        valueOutput = `"${value}"`;
        typeAnnotation = ': String';
      }

      output += `        public static let ${name}${typeAnnotation} = ${valueOutput}\n`;
    });

    output += `    }\n`;
  });

  // Generate separate Opacity enum with Double type (SwiftUI best practice)
  if (opacityTokens.length > 0) {
    output += `\n    // MARK: - Opacity\n`;
    output += `    /// Opacity values as Double (0.0 - 1.0) for use with SwiftUI .opacity() modifier\n`;
    output += `    public enum Opacity {\n`;

    const usedOpacityNames = new Set();
    opacityTokens.forEach(token => {
      let name = toSwiftIdentifier(token.name);

      if (usedOpacityNames.has(name)) {
        return;
      }
      usedOpacityNames.add(name);

      const value = token.$value !== undefined ? token.$value : token.value;
      const comment = token.comment || token.description;

      if (comment) {
        output += `        /// ${comment}\n`;
      }

      // Opacity should be Double, not CGFloat
      let numValue = typeof value === 'number' ? value : parseFloat(value);
      output += `        public static let ${name}: Double = ${numValue}\n`;
    });

    output += `    }\n`;
  }

  output += `}\n`;
  return output;
};

/**
 * Format: SwiftUI Color Scheme (Protocol + Light/Dark implementations)
 */
const swiftuiColorSchemeFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;
  const brand = options.brand || 'Bild';
  const brandPascal = toPascalCase(brand);
  const mode = options.mode || 'light';
  const isLight = mode === 'light';

  // Generate unique names for tokens
  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

`;

  // Helper to detect opacity tokens
  const isOpacityToken = (token) => {
    const tokenType = token.$type || token.type;
    const name = token.name || '';
    return tokenType === 'opacity' || name.toLowerCase().includes('opacity');
  };

  // Filter color tokens and opacity tokens
  const colorTokens = dictionary.allTokens.filter(t => !isOpacityToken(t));
  const opacityTokens = dictionary.allTokens.filter(t => isOpacityToken(t));

  // Only generate protocol in light mode file
  if (isLight) {
    output += `/// Protocol for type-safe color access across Light/Dark modes
public protocol ${brandPascal}ColorScheme: Sendable {
`;

    colorTokens.forEach(token => {
      const name = uniqueNames.get(token.path.join('.')) || token.name;
      const comment = token.comment || token.description;
      if (comment) {
        output += `    /// ${comment}\n`;
      }
      output += `    var ${name}: Color { get }\n`;
    });

    // Add opacity tokens to protocol
    opacityTokens.forEach(token => {
      const name = uniqueNames.get(token.path.join('.')) || token.name;
      const comment = token.comment || token.description;
      if (comment) {
        output += `    /// ${comment}\n`;
      }
      output += `    var ${name}: Double { get }\n`;
    });

    output += `}

`;
  }

  // Generate implementation struct (conforms to both brand-specific and unified protocols)
  const structName = `${brandPascal}${isLight ? 'Light' : 'Dark'}Colors`;
  output += `/// ${isLight ? 'Light' : 'Dark'} mode color implementation
public struct ${structName}: ${brandPascal}ColorScheme, DesignColorScheme {
    public static let shared = ${structName}()
    private init() {}

`;

  // Output color tokens
  colorTokens.forEach(token => {
    const name = uniqueNames.get(token.path.join('.')) || token.name;
    const value = token.$value !== undefined ? token.$value : token.value;
    const colorValue = toSwiftUIColor(value);

    output += `    public let ${name}: Color = ${colorValue}\n`;
  });

  // Output opacity tokens as Double
  opacityTokens.forEach(token => {
    const name = uniqueNames.get(token.path.join('.')) || token.name;
    const value = token.$value !== undefined ? token.$value : token.value;
    // Extract numeric value from various formats
    let opacityValue = value;
    if (typeof value === 'string') {
      const num = parseFloat(value);
      if (!isNaN(num)) opacityValue = num;
    }
    output += `    public let ${name}: Double = ${opacityValue}\n`;
  });

  output += `}
`;

  return output;
};

/**
 * Format: SwiftUI Sizing Scheme (Protocol + Compact/Regular implementations)
 */
const swiftuiSizingSchemeFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;
  const brand = options.brand || 'Bild';
  const brandPascal = toPascalCase(brand);
  const sizeClass = options.sizeClass || 'compact';
  const isCompact = sizeClass === 'compact';

  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  let output = `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

`;

  // Only generate protocol in compact file
  if (isCompact) {
    output += `/// Protocol for type-safe sizing access across Compact/Regular size classes
public protocol ${brandPascal}SizingScheme: Sendable {
`;

    dictionary.allTokens.forEach(token => {
      const name = uniqueNames.get(token.path.join('.')) || token.name;
      const comment = token.comment || token.description;
      const typeInfo = getSwiftTypeInfo(token);
      if (comment) {
        output += `    /// ${comment}\n`;
      }
      output += `    var ${name}: ${typeInfo.swiftType} { get }\n`;
    });

    output += `}

`;
  }

  // Generate implementation struct (conforms to both brand-specific and unified protocols)
  const structName = `${brandPascal}Sizing${isCompact ? 'Compact' : 'Regular'}`;
  output += `/// ${isCompact ? 'Compact' : 'Regular'} size class implementation
public struct ${structName}: ${brandPascal}SizingScheme, DesignSizingScheme {
    public static let shared = ${structName}()
    private init() {}

`;

  dictionary.allTokens.forEach(token => {
    const name = uniqueNames.get(token.path.join('.')) || token.name;
    const value = token.$value !== undefined ? token.$value : token.value;
    const typeInfo = getSwiftTypeInfo(token);
    const formattedValue = formatSwiftValue(value, typeInfo);

    output += `    public let ${name}: ${typeInfo.swiftType} = ${formattedValue}\n`;
  });

  output += `}
`;

  return output;
};

/**
 * Format: SwiftUI Typography (TextStyle composites per SizeClass)
 */
const swiftuiTypographyFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;
  const brand = options.brand || 'Bild';
  const brandPascal = toPascalCase(brand);
  const sizeClass = options.sizeClass || 'compact';
  const isCompact = sizeClass === 'compact';

  let output = `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

`;

  // Only generate protocol in compact file
  if (isCompact) {
    output += `/// Protocol for type-safe typography access
/// Extends DesignTypographyScheme for unified polymorphic access
public protocol ${brandPascal}TypographyScheme: DesignTypographyScheme {
`;

    dictionary.allTokens.forEach(token => {
      const name = token.name;
      const comment = token.comment || token.description;
      if (comment) {
        output += `    /// ${comment}\n`;
      }
      output += `    var ${name}: TextStyle { get }\n`;
    });

    output += `}

`;
  }

  // Generate implementation struct
  const structName = `${brandPascal}Typography${isCompact ? 'Compact' : 'Regular'}`;
  output += `/// ${isCompact ? 'Compact' : 'Regular'} typography implementation
public struct ${structName}: ${brandPascal}TypographyScheme, DesignTypographyScheme {
    public static let shared = ${structName}()
    private init() {}

`;

  dictionary.allTokens.forEach(token => {
    const name = token.name;
    const value = token.$value !== undefined ? token.$value : token.value;

    if (typeof value === 'object' && value.fontFamily) {
      const fontWeight = toSwiftUIFontWeight(value.fontWeight || 400);
      const textCase = value.textCase || 'ORIGINAL';
      const textDecoration = value.textDecoration || 'NONE';

      output += `    public let ${name} = TextStyle(
        fontFamily: "${value.fontFamily}",
        fontWeight: ${fontWeight},
        fontSize: ${value.fontSize || 16},
        lineHeight: ${value.lineHeight || value.fontSize || 16},
        letterSpacing: ${value.letterSpacing || 0},
        textCase: .${textCase.toLowerCase()},
        textDecoration: .${textDecoration.toLowerCase()}
    )
`;
    }
  });

  output += `}
`;

  return output;
};

/**
 * Format: SwiftUI Effects (ShadowStyle composites per ColorMode)
 */
const swiftuiEffectsFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;
  const brand = options.brand || 'Bild';
  const brandPascal = toPascalCase(brand);
  const mode = options.mode || 'light';
  const isLight = mode === 'light';

  let output = `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

`;

  // Only generate protocol in light file
  if (isLight) {
    output += `/// Protocol for type-safe effects access
public protocol ${brandPascal}EffectsScheme: Sendable {
`;

    dictionary.allTokens.forEach(token => {
      const name = token.name;
      const comment = token.comment || token.description;
      if (comment) {
        output += `    /// ${comment}\n`;
      }
      output += `    var ${name}: ShadowStyle { get }\n`;
    });

    output += `}

`;
  }

  // Generate implementation struct (conforms to both brand-specific and unified protocols)
  const structName = `${brandPascal}Effects${isLight ? 'Light' : 'Dark'}`;
  output += `/// ${isLight ? 'Light' : 'Dark'} mode effects implementation
public struct ${structName}: ${brandPascal}EffectsScheme, DesignEffectsScheme {
    public static let shared = ${structName}()
    private init() {}

`;

  dictionary.allTokens.forEach(token => {
    const name = token.name;
    const value = token.$value !== undefined ? token.$value : token.value;

    if (Array.isArray(value)) {
      output += `    public let ${name} = ShadowStyle(shadows: [\n`;
      value.forEach((shadow, index) => {
        const colorValue = toSwiftUIColor(shadow.color);
        output += `        DropShadow(color: ${colorValue}, offsetX: ${shadow.offsetX || 0}, offsetY: ${shadow.offsetY || 0}, radius: ${shadow.radius || 0}, spread: ${shadow.spread || 0})${index < value.length - 1 ? ',' : ''}\n`;
      });
      output += `    ])\n`;
    }
  });

  output += `}
`;

  return output;
};

/**
 * Format: SwiftUI Theme Provider
 */
const swiftuiThemeProviderFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;
  const brand = options.brand || 'Bild';
  const brandPascal = toPascalCase(brand);
  const brandLower = brand.toLowerCase();

  return `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

/// Central theme provider for ${brandPascal} brand
/// Provides reactive access to all design tokens based on current context
@Observable
public final class ${brandPascal}Theme: @unchecked Sendable {

    // MARK: - Shared Instance
    public static let shared = ${brandPascal}Theme()

    // MARK: - Theme State
    public var isDarkTheme: Bool = false
    public var sizeClass: SizeClass = .compact
    public var density: Density = .default

    // MARK: - Token Access

    /// Current color scheme (Light/Dark)
    public var colors: any ${brandPascal}ColorScheme {
        isDarkTheme ? ${brandPascal}DarkColors.shared : ${brandPascal}LightColors.shared
    }

    /// Current sizing scheme (Compact/Regular)
    public var sizing: any ${brandPascal}SizingScheme {
        sizeClass == .compact ? ${brandPascal}SizingCompact.shared : ${brandPascal}SizingRegular.shared
    }

    /// Current typography (Compact/Regular)
    public var typography: any ${brandPascal}TypographyScheme {
        sizeClass == .compact ? ${brandPascal}TypographyCompact.shared : ${brandPascal}TypographyRegular.shared
    }

    /// Current effects (Light/Dark)
    public var effects: any ${brandPascal}EffectsScheme {
        isDarkTheme ? ${brandPascal}EffectsDark.shared : ${brandPascal}EffectsLight.shared
    }

    private init() {}
}

// MARK: - Environment Integration

private struct ${brandPascal}ThemeKey: EnvironmentKey {
    static let defaultValue = ${brandPascal}Theme.shared
}

public extension EnvironmentValues {
    var ${brandLower}Theme: ${brandPascal}Theme {
        get { self[${brandPascal}ThemeKey.self] }
        set { self[${brandPascal}ThemeKey.self] = newValue }
    }
}

// MARK: - View Modifier

public extension View {
    /// Apply ${brandPascal} theme to view hierarchy
    func ${brandLower}Theme(
        darkTheme: Bool? = nil,
        sizeClass: SizeClass? = nil,
        density: Density? = nil
    ) -> some View {
        let theme = ${brandPascal}Theme.shared
        if let darkTheme { theme.isDarkTheme = darkTheme }
        if let sizeClass { theme.sizeClass = sizeClass }
        if let density { theme.density = density }
        return self.environment(\\.${brandLower}Theme, theme)
    }
}
`;
};

/**
 * Format: SwiftUI Component Tokens (aggregated with current() accessors)
 *
 * Uses per-token type detection from $type to determine Swift types.
 * This ensures that color tokens in sizing files get Color type, not CGFloat.
 */
const swiftuiComponentTokensFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;
  const brand = options.brand || 'Bild';
  const brandPascal = toPascalCase(brand);
  const component = options.component || 'Component';
  const componentPascal = toPascalCase(component);
  const tokenType = options.tokenType || 'color'; // color, sizing, density, typography, effects
  const mode = options.mode; // light/dark for colors, compact/regular for sizing

  const uniqueNames = generateUniqueNames(dictionary.allTokens, 'camel');

  // Pre-calculate types for all tokens using source $type
  const tokenTypeMap = new Map();
  dictionary.allTokens.forEach(token => {
    const name = uniqueNames.get(token.path.join('.')) || token.name;
    const { swiftType, formattedValue } = getSwiftTypeAndValue(token);
    tokenTypeMap.set(name, { swiftType, formattedValue });
  });

  // Check if we have mixed types (e.g., Color in a sizing file)
  const uniqueTypes = new Set([...tokenTypeMap.values()].map(t => t.swiftType));
  const hasMixedTypes = uniqueTypes.size > 1;

  let output = `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

`;

  // Determine protocol and struct names based on category
  let protocolName, structName;

  switch (tokenType) {
    case 'color':
      protocolName = `${componentPascal}ColorTokens`;
      structName = mode === 'light' ? `${componentPascal}ColorsLight` : `${componentPascal}ColorsDark`;
      break;
    case 'sizing':
    case 'breakpoint':
      protocolName = `${componentPascal}SizingTokens`;
      structName = mode === 'compact' ? `${componentPascal}SizingCompact` : `${componentPascal}SizingRegular`;
      break;
    case 'density':
      const densityMode = mode || 'default';
      const densityPascal = toPascalCase(densityMode.replace('`', ''));
      protocolName = `${componentPascal}DensityTokens`;
      structName = `${componentPascal}Density${densityPascal}`;
      break;
    default:
      protocolName = `${componentPascal}${toPascalCase(tokenType)}Tokens`;
      structName = `${componentPascal}${toPascalCase(tokenType)}${toPascalCase(mode || 'Default')}`;
  }

  // Generate protocol (only for first mode) - with per-token types
  const isFirstMode = mode === 'light' || mode === 'compact' || mode === 'dense';
  if (isFirstMode) {
    output += `/// Protocol for ${component} ${tokenType} tokens\n`;
    output += `public protocol ${protocolName}: Sendable {\n`;

    dictionary.allTokens.forEach(token => {
      const name = uniqueNames.get(token.path.join('.')) || token.name;
      const { swiftType } = tokenTypeMap.get(name);
      output += `    var ${name}: ${swiftType} { get }\n`;
    });

    output += `}\n\n`;
  }

  // Generate implementation - with per-token types and values
  output += `/// ${structName} implementation\n`;
  output += `public struct ${structName}: ${protocolName} {\n`;
  output += `    public static let shared = ${structName}()\n`;
  output += `    private init() {}\n\n`;

  dictionary.allTokens.forEach(token => {
    const name = uniqueNames.get(token.path.join('.')) || token.name;
    const { swiftType, formattedValue } = tokenTypeMap.get(name);
    output += `    public let ${name}: ${swiftType} = ${formattedValue}\n`;
  });

  output += `}\n`;

  return output;
};

/**
 * Format: SwiftUI DesignSystemTheme (Multi-brand theme provider)
 */
const swiftuiDesignSystemThemeFormat = ({ dictionary, options, file }) => {
  const version = packageJson.version;

  return `//
// Do not edit directly, this file was auto-generated.
//
// BILD Design System Tokens v${version}
// Generated by Style Dictionary
//
// Copyright (c) 2024 Axel Springer Deutschland GmbH
//

import SwiftUI

/// Multi-brand theme provider for white-label apps
@Observable
public final class DesignSystemTheme: @unchecked Sendable {

    // MARK: - Shared Instance
    public static let shared = DesignSystemTheme()

    // MARK: - Theme State
    public var brand: Brand = .bild
    public var isDarkTheme: Bool = false
    public var sizeClass: SizeClass = .compact
    public var density: Density = .default

    private init() {}

    // MARK: - Factory

    public init(
        brand: Brand = .bild,
        isDarkTheme: Bool = false,
        sizeClass: SizeClass = .compact,
        density: Density = .default
    ) {
        self.brand = brand
        self.isDarkTheme = isDarkTheme
        self.sizeClass = sizeClass
        self.density = density
    }
}

// MARK: - Environment Integration

private struct DesignSystemThemeKey: EnvironmentKey {
    static let defaultValue = DesignSystemTheme.shared
}

public extension EnvironmentValues {
    var designSystemTheme: DesignSystemTheme {
        get { self[DesignSystemThemeKey.self] }
        set { self[DesignSystemThemeKey.self] = newValue }
    }
}

// MARK: - View Modifier

public extension View {
    /// Apply design system theme to view hierarchy
    func designSystemTheme(
        brand: Brand,
        darkTheme: Bool = false,
        sizeClass: SizeClass = .compact,
        density: Density = .default
    ) -> some View {
        let theme = DesignSystemTheme(
            brand: brand,
            isDarkTheme: darkTheme,
            sizeClass: sizeClass,
            density: density
        )
        return self.environment(\\.designSystemTheme, theme)
    }
}
`;
};

const composePrimitivesFormat = ({ dictionary, options, file }) => {
  const { packageName, className } = options;
  const version = packageJson.version;

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

/**
 * ${className} - Primitive design tokens
 * These are the raw values that semantic and component tokens reference.
 */
object ${className} {
`;

  // Group tokens by their first path segment for organization
  const grouped = {};
  dictionary.allTokens.forEach(token => {
    const category = token.path[0] || 'Other';
    if (!grouped[category]) grouped[category] = [];
    grouped[category].push(token);
  });

  Object.keys(grouped).sort().forEach(category => {
    output += `    // ${category}\n`;
    grouped[category].forEach(token => {
      // Use token.name directly - already camelCase from name/custom/compose transform
      const name = token.name;
      const type = token.$type || token.type;
      let value = token.value;

      // Apply Compose-specific formatting based on $type (set by preprocessor)
      if (type === 'color') {
        value = toComposeColor(value);
      } else if (type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing') {
        // Text-related types use sp units
        value = toComposeSp(value);
      } else if (type === 'fontWeight' || type === 'number') {
        // Unitless integers - parse string if needed
        if (typeof value === 'string' && /^\d+$/.test(value)) {
          value = parseInt(value, 10);
        }
      } else if (type === 'opacity') {
        // Opacity stays as float
        if (typeof value === 'string') {
          value = parseFloat(value);
        }
      } else if (type === 'fontFamily' || type === 'string') {
        // Quote string values (font family names, etc.)
        value = `"${value}"`;
      } else if (type === 'dimension') {
        value = toComposeDp(value);
      } else if (type === 'boolean') {
        value = value ? 'true' : 'false';
      }

      output += `    internal val ${name} = ${value}\n`;
    });
    output += `\n`;
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Jetpack Compose Semantic Colors Data Class
 * Generates @Immutable data class with color properties
 *
 * Output example:
 * @Immutable
 * data class BildColorScheme(
 *     val textColorPrimary: Color,
 *     val surfaceColorPrimary: Color,
 * )
 *
 * val BildLightColorScheme = BildColorScheme(
 *     textColorPrimary = Color(0xFF232629),
 *     surfaceColorPrimary = Color(0xFFFFFFFF),
 * )
 */
const composeSemanticColorsFormat = ({ dictionary, options, file }) => {
  const { packageName, brand, mode } = options;
  const brandPascal = brandToPascalCase(brand);
  const modePascal = mode.charAt(0).toUpperCase() + mode.slice(1);
  const version = packageJson.version;

  // Collect all tokens and their properties
  const tokens = dictionary.allTokens.filter(t => {
    const type = t.$type || t.type;
    return type === 'color';
  });

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Brand: ${brandPascal} | Mode: ${modePascal}
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

import androidx.compose.runtime.Immutable
import androidx.compose.runtime.Stable
import androidx.compose.ui.graphics.Color
import com.bild.designsystem.shared.DesignColorScheme

`;

  // Generate interface (only for Light mode to avoid duplication)
  if (mode.toLowerCase() === 'light') {
    output += `/**
 * Color scheme interface for ${brandPascal}
 * Extends DesignColorScheme for Dual-Axis theming compatibility
 * Allows type-safe access to colors and enables color scheme sharing across brands
 */
@Stable
interface ${brandPascal}ColorScheme : DesignColorScheme {
`;
    tokens.forEach(token => {
      output += `    val ${token.name}: Color\n`;
    });
    output += `}

`;
  }

  // Generate object implementing the interface
  output += `/**
 * ${brandPascal} Color Scheme - ${modePascal} Mode
 */
@Immutable
object ${brandPascal}${modePascal}Colors : ${brandPascal}ColorScheme {
`;

  tokens.forEach(token => {
    const name = token.name;
    const value = toComposeColor(token.value);
    output += `    override val ${name} = ${value}\n`;
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Jetpack Compose Spacing/Sizing Object
 * Generates object with Dp values and interfaces for type safety
 * Android uses Material 3 WindowSizeClass: Compact, Medium, Expanded
 */
const composeSpacingFormat = ({ dictionary, options, file }) => {
  const { packageName, brand, mode, modeType, platform } = options;
  const brandPascal = brandToPascalCase(brand);
  const version = packageJson.version;

  // Map mode to correct name based on platform
  // Android (Material 3): sm -> Compact, md -> Medium, lg -> Expanded
  // iOS: sm -> Compact, lg -> Regular (handled in Swift formats)
  let modePascal = '';
  if (mode) {
    if (mode === 'sm' || mode === 'compact') {
      modePascal = 'Compact';
    } else if (mode === 'md' || mode === 'medium') {
      modePascal = 'Medium';
    } else if (mode === 'lg' || mode === 'expanded') {
      modePascal = 'Expanded';
    } else if (mode === 'regular') {
      // Legacy support for 'regular' (maps to Expanded for Android)
      modePascal = platform === 'android' ? 'Expanded' : 'Regular';
    } else {
      modePascal = mode.charAt(0).toUpperCase() + mode.slice(1);
    }
  }

  // Determine class name and interface based on mode type
  let className;
  let interfaceName;
  let generateInterface = false;

  if (modeType === 'sizeclass') {
    className = `${brandPascal}Sizing${modePascal}`;
    interfaceName = `${brandPascal}SizingScheme`;
    // Generate interface only for Compact mode to avoid duplication
    generateInterface = modePascal === 'Compact';
  } else if (modeType === 'density') {
    className = `${brandPascal}Density${modePascal}`;
  } else {
    className = `${brandPascal}Spacing`;
  }

  // Check if any tokens need sp import (font sizes, line heights, letter spacing)
  // Uses $type from preprocessor instead of name-based heuristics
  const needsSpImport = dictionary.allTokens.some(token => {
    const type = token.$type || token.type;
    return type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing';
  });

  const imports = ['import androidx.compose.runtime.Stable', 'import androidx.compose.ui.unit.Dp', 'import androidx.compose.ui.unit.dp'];
  if (needsSpImport) {
    imports.push('import androidx.compose.ui.unit.sp');
    imports.push('import androidx.compose.ui.unit.TextUnit');
  }
  // Add import for DesignSizingScheme for sizeclass mode
  if (modeType === 'sizeclass') {
    imports.push('import com.bild.designsystem.shared.DesignSizingScheme');
  }

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Brand: ${brandPascal}${mode ? ` | ${modeType}: ${modePascal}` : ''}
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

${imports.join('\n')}

`;

  // Helper function to determine if a token should be filtered out
  // Filter out generic string tokens that aren't useful for Compose (e.g., breakpointName, changeOnLg)
  const shouldFilterStringToken = (token) => {
    const type = token.$type || token.type;
    // Keep fontFamily strings, filter out generic strings
    if (type === 'fontFamily') return false;
    if (type === 'string') return true;  // Filter out generic strings
    return false;
  };

  // Filter tokens to exclude generic string tokens
  const filteredTokens = dictionary.allTokens.filter(token => !shouldFilterStringToken(token));

  // Generate interface for sizeclass (only for Compact mode)
  if (generateInterface && modeType === 'sizeclass') {
    output += `/**
 * Sizing scheme interface for ${brandPascal}
 * Extends DesignSizingScheme for Dual-Axis theming compatibility
 * Provides type-safe access to sizing tokens across WindowSizeClass variants
 */
@Stable
interface ${interfaceName} : DesignSizingScheme {
`;
    filteredTokens.forEach(token => {
      const type = token.$type || token.type;

      // Determine Kotlin type based on $type
      let propType = 'Dp';  // Default
      if (type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing') {
        propType = 'TextUnit';
      } else if (type === 'fontFamily') {
        propType = 'String';
      } else if (type === 'fontWeight' || type === 'number' || type === 'opacity') {
        propType = 'Int';
      } else if (type === 'color') {
        propType = 'Color';
      } else if (type === 'boolean') {
        propType = 'Boolean';
      }
      // type === 'dimension' → stays 'Dp'

      output += `    val ${token.name}: ${propType}\n`;
    });
    output += `}

`;
  }

  // Generate object (implementing interface for sizeclass)
  const implementsClause = modeType === 'sizeclass' ? ` : ${interfaceName}` : '';
  const overrideKeyword = modeType === 'sizeclass' ? 'override ' : '';

  output += `/**
 * ${className} - Spacing and sizing tokens
 */
object ${className}${implementsClause} {
`;

  filteredTokens.forEach(token => {
    const name = token.name;
    const type = token.$type || token.type;
    let value = token.value;

    // Apply Compose-specific formatting based on $type (set by preprocessor)
    if (type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing') {
      // Text-related types use sp units
      value = toComposeSp(value);
    } else if (type === 'fontWeight') {
      // FontWeight should always be an integer (e.g., 700, not "700")
      if (typeof value === 'string' && /^\d+$/.test(value)) {
        value = parseInt(value, 10);
      }
    } else if (type === 'number') {
      // Unitless integers
      if (typeof value === 'string' && /^\d+$/.test(value)) {
        value = parseInt(value, 10);
      }
    } else if (type === 'opacity') {
      // Opacity as float
      if (typeof value === 'string') {
        value = parseFloat(value);
      }
    } else if (type === 'fontFamily') {
      // Quote string values
      value = `"${value}"`;
    } else if (type === 'dimension') {
      value = toComposeDp(value);
    } else if (type === 'color') {
      value = toComposeColor(value);
    } else if (type === 'boolean') {
      value = value ? 'true' : 'false';
    }

    output += `    ${overrideKeyword}val ${name} = ${value}\n`;
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Jetpack Compose Component Tokens (Aggregated)
 * Generates a single file with Colors, Sizing, Density data classes for a component
 */
const composeComponentTokensFormat = ({ dictionary, options, file }) => {
  const { packageName, componentName, brand, tokenType, mode } = options;
  const brandPascal = brandToPascalCase(brand);
  const version = packageJson.version;

  // Map mode to correct name (sm -> Compact, lg -> Regular)
  let modePascal = '';
  if (mode) {
    if (mode === 'sm' || mode === 'compact') {
      modePascal = 'Compact';
    } else if (mode === 'lg' || mode === 'regular') {
      modePascal = 'Regular';
    } else {
      modePascal = mode.charAt(0).toUpperCase() + mode.slice(1);
    }
  }

  // Check if any tokens need sp import (font sizes, line heights, letter spacing)
  // Uses $type from preprocessor instead of name-based heuristics
  const needsSpImport = dictionary.allTokens.some(token => {
    const type = token.$type || token.type;
    return type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing';
  });

  // Determine output class name
  let className;
  let imports = [];

  if (tokenType === 'color') {
    className = `${componentName}Colors${modePascal}`;
    imports.push('import androidx.compose.ui.graphics.Color');
  } else if (tokenType === 'sizing' || tokenType === 'breakpoint') {
    className = `${componentName}Sizing${modePascal}`;
    imports.push('import androidx.compose.ui.unit.Dp');
    imports.push('import androidx.compose.ui.unit.dp');
    if (needsSpImport) imports.push('import androidx.compose.ui.unit.sp');
  } else if (tokenType === 'density') {
    className = `${componentName}Density${modePascal}`;
    imports.push('import androidx.compose.ui.unit.Dp');
    imports.push('import androidx.compose.ui.unit.dp');
    if (needsSpImport) imports.push('import androidx.compose.ui.unit.sp');
  } else if (tokenType === 'typography') {
    className = `${componentName}Typography${modePascal}`;
    imports.push('import androidx.compose.ui.text.font.FontWeight');
    imports.push('import androidx.compose.ui.text.style.TextDecoration');
    imports.push('import androidx.compose.ui.unit.sp');
    imports.push('import com.bild.designsystem.shared.DesignTextStyle');
    imports.push('import com.bild.designsystem.shared.DesignTextCase');
  } else {
    className = `${componentName}Tokens${modePascal}`;
    imports.push('import androidx.compose.ui.graphics.Color');
    imports.push('import androidx.compose.ui.unit.Dp');
    imports.push('import androidx.compose.ui.unit.dp');
    if (needsSpImport) imports.push('import androidx.compose.ui.unit.sp');
  }

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Component: ${componentName} | Brand: ${brandPascal}${mode ? ` | ${tokenType}: ${modePascal}` : ''}
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

${imports.join('\n')}

/**
 * ${className}
 */
object ${className} {
`;

  // Helper functions for typography conversion (same as in composeTypographySchemeFormat)
  const toComposeFontWeightComponent = (weight) => {
    if (!weight) return 'FontWeight.Normal';
    const w = parseInt(weight, 10);
    if (w >= 900) return 'FontWeight.Black';
    if (w >= 800) return 'FontWeight.ExtraBold';
    if (w >= 700) return 'FontWeight.Bold';
    if (w >= 600) return 'FontWeight.SemiBold';
    if (w >= 500) return 'FontWeight.Medium';
    if (w >= 400) return 'FontWeight.Normal';
    if (w >= 300) return 'FontWeight.Light';
    if (w >= 200) return 'FontWeight.ExtraLight';
    return 'FontWeight.Thin';
  };

  const toComposeTextCaseComponent = (textCase) => {
    if (!textCase) return 'DesignTextCase.Original';
    switch (textCase.toUpperCase()) {
      case 'UPPER': return 'DesignTextCase.Uppercase';
      case 'LOWER': return 'DesignTextCase.Lowercase';
      case 'TITLE': return 'DesignTextCase.Capitalize';
      default: return 'DesignTextCase.Original';
    }
  };

  const toComposeTextDecorationComponent = (textDecoration) => {
    if (!textDecoration || textDecoration === 'NONE') return 'TextDecoration.None';
    if (textDecoration.toUpperCase() === 'UNDERLINE') return 'TextDecoration.Underline';
    if (textDecoration.toUpperCase() === 'LINE_THROUGH' || textDecoration.toUpperCase() === 'STRIKETHROUGH') return 'TextDecoration.LineThrough';
    return 'TextDecoration.None';
  };

  dictionary.allTokens.forEach(token => {
    const name = token.name;
    const type = token.$type || token.type;
    let value = token.$value || token.value;

    // Special handling for typography composite tokens
    if (type === 'typography' && typeof value === 'object' && value !== null) {
      const fontFamily = value.fontFamily ? `"${value.fontFamily}"` : '"System"';
      const fontWeight = toComposeFontWeightComponent(value.fontWeight);
      const fontSize = value.fontSize ? `${value.fontSize}.sp` : '16.sp';
      const lineHeight = value.lineHeight ? `${value.lineHeight}.sp` : fontSize;
      const letterSpacing = value.letterSpacing !== null && value.letterSpacing !== undefined ? `(${value.letterSpacing}).sp` : '0.sp';
      const textCase = toComposeTextCaseComponent(value.textCase);
      const textDecoration = toComposeTextDecorationComponent(value.textDecoration);

      output += `    val ${name} = DesignTextStyle(
        fontFamily = ${fontFamily},
        fontWeight = ${fontWeight},
        fontSize = ${fontSize},
        lineHeight = ${lineHeight},
        letterSpacing = ${letterSpacing},
        textCase = ${textCase},
        textDecoration = ${textDecoration}
    )
`;
    } else {
      // Apply Compose-specific formatting based on $type (set by preprocessor)
      if (type === 'color') {
        value = toComposeColor(value);
      } else if (type === 'fontSize' || type === 'lineHeight' || type === 'letterSpacing') {
        // Text-related types use sp units
        value = toComposeSp(value);
      } else if (type === 'fontWeight') {
        // FontWeight should always be an integer (e.g., 700, not "700")
        if (typeof value === 'string' && /^\d+$/.test(value)) {
          value = parseInt(value, 10);
        }
      } else if (type === 'number') {
        // Unitless integers
        if (typeof value === 'string' && /^\d+$/.test(value)) {
          value = parseInt(value, 10);
        }
      } else if (type === 'opacity') {
        // Opacity as float
        if (typeof value === 'string') {
          value = parseFloat(value);
        }
      } else if (type === 'fontFamily' || type === 'string') {
        // Quote string values
        value = `"${value}"`;
      } else if (type === 'dimension') {
        value = toComposeDp(value);
      } else if (type === 'boolean') {
        value = value ? 'true' : 'false';
      }

      output += `    val ${name} = ${value}\n`;
    }
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Jetpack Compose Typography Scheme with TextStyle objects
 * Generates a DesignTypographyScheme interface and brand-specific implementations
 * with complete TextStyle objects (parallel to iOS implementation)
 */
const composeTypographySchemeFormat = ({ dictionary, options, file }) => {
  const { packageName, brand, sizeClass } = options;
  const brandPascal = brandToPascalCase(brand);
  const sizeClassPascal = sizeClass ? sizeClass.charAt(0).toUpperCase() + sizeClass.slice(1) : '';
  const version = packageJson.version;
  const isCompact = sizeClass === 'compact';

  // Filter typography tokens
  const tokens = dictionary.allTokens.filter(t => {
    const type = t.$type || t.type;
    return type === 'typography';
  });

  // Helper to convert fontWeight number to Compose FontWeight
  const toComposeFontWeight = (weight) => {
    if (!weight) return 'FontWeight.Normal';
    const w = parseInt(weight, 10);
    if (w >= 900) return 'FontWeight.Black';
    if (w >= 800) return 'FontWeight.ExtraBold';
    if (w >= 700) return 'FontWeight.Bold';
    if (w >= 600) return 'FontWeight.SemiBold';
    if (w >= 500) return 'FontWeight.Medium';
    if (w >= 400) return 'FontWeight.Normal';
    if (w >= 300) return 'FontWeight.Light';
    if (w >= 200) return 'FontWeight.ExtraLight';
    return 'FontWeight.Thin';
  };

  // Helper to convert textCase to Compose enum
  const toComposeTextCase = (textCase) => {
    if (!textCase) return 'DesignTextCase.Original';
    switch (textCase.toUpperCase()) {
      case 'UPPER': return 'DesignTextCase.Uppercase';
      case 'LOWER': return 'DesignTextCase.Lowercase';
      case 'TITLE': return 'DesignTextCase.Capitalize';
      default: return 'DesignTextCase.Original';
    }
  };

  // Helper to convert textDecoration
  const toComposeTextDecoration = (textDecoration) => {
    if (!textDecoration || textDecoration === 'NONE') return 'TextDecoration.None';
    if (textDecoration.toUpperCase() === 'UNDERLINE') return 'TextDecoration.Underline';
    if (textDecoration.toUpperCase() === 'LINE_THROUGH' || textDecoration.toUpperCase() === 'STRIKETHROUGH') return 'TextDecoration.LineThrough';
    return 'TextDecoration.None';
  };

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Brand: ${brandPascal} | SizeClass: ${sizeClassPascal}
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

import androidx.compose.runtime.Immutable
import androidx.compose.runtime.Stable
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.unit.sp
import com.bild.designsystem.shared.DesignTypographyScheme
import com.bild.designsystem.shared.DesignTextStyle
import com.bild.designsystem.shared.DesignTextCase

`;

  // Generate interface only for Compact mode to avoid duplication
  if (isCompact) {
    output += `/**
 * Typography scheme interface for ${brandPascal}
 * Extends DesignTypographyScheme for Dual-Axis theming compatibility
 */
@Stable
interface ${brandPascal}TypographyScheme : DesignTypographyScheme {
`;
    tokens.forEach(token => {
      const comment = token.comment ? `    /** ${token.comment.split('\n')[0]} */\n` : '';
      output += `${comment}    override val ${token.name}: DesignTextStyle\n`;
    });
    output += `}

`;
  }

  // Generate object implementing the interface
  output += `/**
 * ${brandPascal} Typography - ${sizeClassPascal} Size Class
 */
@Immutable
object ${brandPascal}Typography${sizeClassPascal} : ${brandPascal}TypographyScheme {
`;

  tokens.forEach(token => {
    const value = token.$value || token.value;
    if (typeof value === 'object' && value !== null) {
      const fontFamily = value.fontFamily ? `"${value.fontFamily}"` : '"System"';
      const fontWeight = toComposeFontWeight(value.fontWeight);
      const fontSize = value.fontSize ? `${value.fontSize}.sp` : '16.sp';
      const lineHeight = value.lineHeight ? `${value.lineHeight}.sp` : fontSize;
      const letterSpacing = value.letterSpacing !== null && value.letterSpacing !== undefined ? `(${value.letterSpacing}).sp` : '0.sp';
      const textCase = toComposeTextCase(value.textCase);
      const textDecoration = toComposeTextDecoration(value.textDecoration);

      output += `    override val ${token.name} = DesignTextStyle(
        fontFamily = ${fontFamily},
        fontWeight = ${fontWeight},
        fontSize = ${fontSize},
        lineHeight = ${lineHeight},
        letterSpacing = ${letterSpacing},
        textCase = ${textCase},
        textDecoration = ${textDecoration}
    )
`;
    }
  });

  output += `}
`;
  return output;
};

/**
 * Format: Jetpack Compose Typography Tokens (Legacy - exploded properties)
 * Generates typography values (not full TextStyle, as FontFamily needs runtime injection)
 */
const composeTypographyFormat = ({ dictionary, options, file }) => {
  const { packageName, brand, mode, componentName } = options;
  const brandPascal = brandToPascalCase(brand);
  const modePascal = mode ? mode.charAt(0).toUpperCase() + mode.slice(1) : '';
  const version = packageJson.version;

  const prefix = componentName ? componentName : brandPascal;
  const className = `${prefix}Typography${modePascal}`;

  // Helper functions for typography conversion
  const toComposeFontWeight = (weight) => {
    if (!weight) return 'FontWeight.Normal';
    const w = parseInt(weight, 10);
    if (w >= 900) return 'FontWeight.Black';
    if (w >= 800) return 'FontWeight.ExtraBold';
    if (w >= 700) return 'FontWeight.Bold';
    if (w >= 600) return 'FontWeight.SemiBold';
    if (w >= 500) return 'FontWeight.Medium';
    if (w >= 400) return 'FontWeight.Normal';
    if (w >= 300) return 'FontWeight.Light';
    if (w >= 200) return 'FontWeight.ExtraLight';
    return 'FontWeight.Thin';
  };

  const toComposeTextCase = (textCase) => {
    if (!textCase) return 'DesignTextCase.Original';
    switch (textCase.toUpperCase()) {
      case 'UPPER': return 'DesignTextCase.Uppercase';
      case 'LOWER': return 'DesignTextCase.Lowercase';
      case 'TITLE': return 'DesignTextCase.Capitalize';
      default: return 'DesignTextCase.Original';
    }
  };

  const toComposeTextDecoration = (textDecoration) => {
    if (!textDecoration || textDecoration === 'NONE') return 'TextDecoration.None';
    if (textDecoration.toUpperCase() === 'UNDERLINE') return 'TextDecoration.Underline';
    if (textDecoration.toUpperCase() === 'LINE_THROUGH' || textDecoration.toUpperCase() === 'STRIKETHROUGH') return 'TextDecoration.LineThrough';
    return 'TextDecoration.None';
  };

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Brand: ${brandPascal}${mode ? ` | SizeClass: ${modePascal}` : ''}${componentName ? ` | Component: ${componentName}` : ''}
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package ${packageName}

import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.unit.sp
import com.bild.designsystem.shared.DesignTextStyle
import com.bild.designsystem.shared.DesignTextCase

/**
 * ${className}
 * Typography composite tokens as DesignTextStyle objects
 */
object ${className} {
`;

  dictionary.allTokens.forEach(token => {
    const value = token.$value || token.value;

    // Handle composite typography tokens - output as DesignTextStyle
    if (typeof value === 'object' && value !== null) {
      const fontFamily = value.fontFamily ? `"${value.fontFamily}"` : '"System"';
      const fontWeight = toComposeFontWeight(value.fontWeight);
      const fontSize = value.fontSize ? `${value.fontSize}.sp` : '16.sp';
      const lineHeight = value.lineHeight ? `${value.lineHeight}.sp` : fontSize;
      const letterSpacing = value.letterSpacing !== null && value.letterSpacing !== undefined ? `(${value.letterSpacing}).sp` : '0.sp';
      const textCase = toComposeTextCase(value.textCase);
      const textDecoration = toComposeTextDecoration(value.textDecoration);

      output += `    val ${token.name} = DesignTextStyle(
        fontFamily = ${fontFamily},
        fontWeight = ${fontWeight},
        fontSize = ${fontSize},
        lineHeight = ${lineHeight},
        letterSpacing = ${letterSpacing},
        textCase = ${textCase},
        textDecoration = ${textDecoration}
    )
`;
    } else {
      output += `    val ${token.name} = ${token.value}\n`;
    }
  });

  output += `}\n`;
  return output;
};

/**
 * Format: Jetpack Compose Effects (Shadows)
 * Generates EffectsLight/EffectsDark objects implementing DesignEffectsScheme
 * Brand-independent: shadows only depend on light/dark mode
 */
const composeEffectsFormat = ({ dictionary, options, file }) => {
  const { colorMode } = options;
  const version = packageJson.version;
  const isLight = colorMode === 'light';
  const className = isLight ? 'EffectsLight' : 'EffectsDark';

  // Helper to convert token names to proper camelCase (shadowSoftSM → shadowSoftSm)
  const toCamelCase = (name) => {
    // Convert trailing uppercase sequence to have only first char uppercase
    // e.g., shadowSoftSM → shadowSoftSm, shadowHardXL → shadowHardXl
    return name.replace(/([A-Z]+)$/, (match) => {
      return match.charAt(0) + match.slice(1).toLowerCase();
    });
  };

  // Helper to convert rgba to Compose Color
  const toComposeColorFromRgba = (rgbaString) => {
    if (!rgbaString) return 'Color.Black';
    const match = rgbaString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (match) {
      const r = parseInt(match[1], 10);
      const g = parseInt(match[2], 10);
      const b = parseInt(match[3], 10);
      const a = match[4] !== undefined ? parseFloat(match[4]) : 1.0;
      // Use copy(alpha) for cleaner output
      if (r === 0 && g === 0 && b === 0) {
        return `Color.Black.copy(alpha = ${a.toFixed(2)}f)`;
      }
      if (r === 255 && g === 255 && b === 255) {
        return `Color.White.copy(alpha = ${a.toFixed(2)}f)`;
      }
      // Generic ARGB
      const alpha = Math.round(a * 255);
      const hex = ((alpha << 24) | (r << 16) | (g << 8) | b) >>> 0;
      return `Color(0x${hex.toString(16).toUpperCase().padStart(8, '0')})`;
    }
    return 'Color.Black';
  };

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * ${isLight ? 'Light' : 'Dark'} Mode Effects (Shadows)
 * Brand-independent: shadows only depend on light/dark mode
 *
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package com.bild.designsystem.shared

import androidx.compose.ui.graphics.Color

/**
 * ${isLight ? 'Light' : 'Dark'} mode effects implementation
 *
 * Usage:
 *   DesignSystemTheme.effects.shadowSoftMd.toModifier()
 */
object ${className} : DesignEffectsScheme {
`;

  dictionary.allTokens.forEach(token => {
    const name = toCamelCase(token.name);
    const value = token.$value !== undefined ? token.$value : token.value;
    const comment = token.comment || token.description;

    if (comment) {
      output += `    /** ${comment} */\n`;
    }

    if (Array.isArray(value)) {
      output += `    override val ${name} = ShadowStyle(listOf(\n`;
      value.forEach((shadow, index) => {
        const colorValue = toComposeColorFromRgba(shadow.color);
        const isLast = index === value.length - 1;
        output += `        DropShadow(color = ${colorValue}, offsetX = ${shadow.offsetX || 0}f, offsetY = ${shadow.offsetY || 0}f, blur = ${shadow.radius || 0}f, spread = ${shadow.spread || 0}f)${isLast ? '' : ','}\n`;
      });
      output += `    ))\n`;
    }
  });

  output += `}
`;

  return output;
};

/**
 * Format: Jetpack Compose Component Effects
 * Generates individual component effect files (e.g., MenuEffectsLight.kt)
 * These files are later aggregated into {Component}Tokens.kt
 */
const composeComponentEffectsFormat = ({ dictionary, options, file }) => {
  const { colorMode, componentName, brand } = options;
  const version = packageJson.version;
  const isLight = colorMode === 'light';
  const className = `${componentName}Effects${isLight ? 'Light' : 'Dark'}`;

  // Helper to convert rgba to Compose Color
  const toComposeColorFromRgba = (rgbaString) => {
    if (!rgbaString) return 'Color.Black';
    const match = rgbaString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (match) {
      const r = parseInt(match[1], 10);
      const g = parseInt(match[2], 10);
      const b = parseInt(match[3], 10);
      const a = match[4] !== undefined ? parseFloat(match[4]) : 1.0;
      if (r === 0 && g === 0 && b === 0) {
        return `Color.Black.copy(alpha = ${a.toFixed(2)}f)`;
      }
      if (r === 255 && g === 255 && b === 255) {
        return `Color.White.copy(alpha = ${a.toFixed(2)}f)`;
      }
      const alpha = Math.round(a * 255);
      const hex = ((alpha << 24) | (r << 16) | (g << 8) | b) >>> 0;
      return `Color(0x${hex.toString(16).toUpperCase().padStart(8, '0')})`;
    }
    return 'Color.Black';
  };

  let output = `/**
 * Do not edit directly, this file was auto-generated.
 *
 * BILD Design System Tokens v${version}
 * Generated by Style Dictionary
 *
 * Component: ${componentName} | Brand: ${brand}
 * ${isLight ? 'Light' : 'Dark'} Mode Effects (Shadows)
 *
 * Copyright (c) 2024 Axel Springer Deutschland GmbH
 */

package com.bild.designsystem.${brand.toLowerCase()}.components

import androidx.compose.ui.graphics.Color
import com.bild.designsystem.shared.DropShadow
import com.bild.designsystem.shared.ShadowStyle

/**
 * ${componentName} ${isLight ? 'Light' : 'Dark'} mode effects
 */
object ${className} {
`;

  dictionary.allTokens.forEach(token => {
    const name = token.name;
    const value = token.$value !== undefined ? token.$value : token.value;
    const comment = token.comment || token.description;

    if (comment) {
      output += `    /** ${comment} */\n`;
    }

    if (Array.isArray(value)) {
      output += `    val ${name} = ShadowStyle(listOf(\n`;
      value.forEach((shadow, index) => {
        const colorValue = toComposeColorFromRgba(shadow.color);
        const isLast = index === value.length - 1;
        output += `        DropShadow(color = ${colorValue}, offsetX = ${shadow.offsetX || 0}f, offsetY = ${shadow.offsetY || 0}f, blur = ${shadow.radius || 0}f, spread = ${shadow.spread || 0}f)${isLast ? '' : ','}\n`;
      });
      output += `    ))\n`;
    }
  });

  output += `}
`;

  return output;
};

// ============================================================================
// EXPORTS
// ============================================================================

module.exports = {
  transforms: {
    'color/css': colorCssTransform,
    'custom/color/UIColor': colorUIColorTransform,
    'custom/size/px': sizePxTransform,
    'custom/size/ios-points': sizeIosPointsTransform,
    'size/rem': sizeRemTransform,
    'custom/opacity': opacityTransform,
    'custom/fontWeight': fontWeightTransform,
    'custom/number': numberTransform,
    'name/custom/kebab': nameKebabTransform,
    'name/custom/js': nameJsTransform,
    'name/custom/ios-swift': nameIosSwiftTransform,
    'name/custom/compose': nameComposeTransform,
    'color/custom/compose': colorComposeTransform,
    'size/custom/compose': sizeComposeTransform,
    'value/round': valueRoundTransform
  },
  transformGroups: customTransformGroups,
  formats: {
    // Classic Token Formats - Custom versions with hierarchical grouping
    'custom/css/variables': cssVariablesFormat,
    'custom/scss/variables': scssVariablesFormat,
    'custom/javascript/es6': javascriptEs6Format,
    'custom/json/nested': jsonNestedFormat,
    'ios-swift/class': iosSwiftClassFormat,

    // Themed CSS Format - Data-attribute based theme switching
    'custom/css/themed-variables': cssThemedVariablesFormat,

    // CSS Formats with Alias References (var() pattern)
    'custom/css/variables-with-alias': cssVariablesWithAliasFormat,
    'custom/css/themed-variables-with-alias': cssThemedVariablesWithAliasFormat,

    // Composite Token Formats
    'css/typography-classes': cssTypographyClassesFormat,
    'css/effect-classes': cssEffectClassesFormat,
    'javascript/effects': javascriptEffectsFormat,
    'javascript/typography': javascriptTypographyFormat,
    'ios-swift/effects': iosSwiftEffectsFormat,
    'ios-swift/typography': iosSwiftTypographyFormat,
    'scss/effects': scssEffectsFormat,
    'scss/typography': scssTypographyFormat,

    // Jetpack Compose Formats
    'compose/primitives': composePrimitivesFormat,
    'compose/semantic-colors': composeSemanticColorsFormat,
    'compose/spacing': composeSpacingFormat,
    'compose/component-tokens': composeComponentTokensFormat,
    'compose/typography': composeTypographyFormat,
    'compose/typography-scheme': composeTypographySchemeFormat,
    'compose/effects': composeEffectsFormat,
    'compose/component-effects': composeComponentEffectsFormat,

    // SwiftUI Formats
    'swiftui/enums': swiftuiEnumsFormat,
    'swiftui/text-style': swiftuiTextStyleFormat,
    'swiftui/shadow': swiftuiShadowFormat,
    'swiftui/color-extension': swiftuiColorExtensionFormat,
    'swiftui/primitives': swiftuiPrimitivesFormat,
    'swiftui/color-scheme': swiftuiColorSchemeFormat,
    'swiftui/sizing-scheme': swiftuiSizingSchemeFormat,
    'swiftui/typography': swiftuiTypographyFormat,
    'swiftui/effects': swiftuiEffectsFormat,
    'swiftui/theme-provider': swiftuiThemeProviderFormat,
    'swiftui/component-tokens': swiftuiComponentTokensFormat,
    'swiftui/design-system-theme': swiftuiDesignSystemThemeFormat
  }
};
